Comments,Surrounding Code Context,Class
/*READ_INT_FUNCTIONS*/,"-5.    if (png_ptr != NULL)
-4.       png_warning(png_ptr, ""PNG fixed point integer out of range"");
-3.    return PNG_FIXED_ERROR;
-2. }
-1. #endif
#ifdef PNG_READ_INT_FUNCTIONS_SUPPORTED

/*READ_INT_FUNCTIONS*/

 ",Not Useful
/*Put the chunk name into png_ptr->chunk_name.*/,"-2.    png_read_data(png_ptr, buf, 8);
-1.    length = png_get_uint_31(png_ptr, buf);

/*Put the chunk name into png_ptr->chunk_name.*/

1.    png_ptr->chunk_name = PNG_CHUNK_FROM_STRING(buf+4);
2.    png_debug2(0, ""Reading %lx chunk, length = %lu"",
3.        (unsigned long)png_ptr->chunk_name, (unsigned long)length);",Not Useful
/*critical*/,"-8. png_crc_read(png_structrp png_ptr, png_bytep buf, png_uint_32 length)
-7. {
-6.    if (png_ptr == NULL)
-5.       return;
-4.    png_read_data(png_ptr, buf, length);
-3.    png_calculate_crc(png_ptr, buf, length);
-2. }
-1. /* Optionally skip data and then check the CRC.  Depending on whether we
 * are reading an ancillary or critical chunk, and how the program has set

/*critical*/

1.  * things up, we may calculate the CRC on the data and print a message.
2.  * Returns '1' if there was a CRC error, '0' otherwise.
3.  */",Not Useful
/*READ_iCCP|iTXt|pCAL|sCAL|sPLT|tEXt|zTXt|SEQUENTIAL_READ*/,"-9.       {
-8.          if (warn != 0)
-7.              png_chunk_warning(png_ptr, ""insufficient memory to read chunk"");
-6.          else
-5.              png_chunk_error(png_ptr, ""insufficient memory to read chunk"");
-4.       }
-3.    }
-2.    return buffer;
-1. }

/*READ_iCCP|iTXt|pCAL|sCAL|sPLT|tEXt|zTXt|SEQUENTIAL_READ*/

 ",Not Useful
/*ZLIB_VERNUM >= 0x1240*/,"#if ZLIB_VERNUM >= 0x1240

/*ZLIB_VERNUM >= 0x1240*/

1.       int window_bits = 0;
2. # if defined(PNG_SET_OPTION_SUPPORTED) && defined(PNG_MAXIMUM_INFLATE_WINDOW)
3.       if (((png_ptr->options >> PNG_MAXIMUM_INFLATE_WINDOW) & 3) ==
4.           PNG_OPTION_ON)
5.       {
6.          window_bits = 15;",Not Useful
/*Zlib >= 1.2.4*/,"-10.    {
-9.       if ((*png_ptr->zstream.next_in >> 4) > 7)
-8.       {
-7.          png_ptr->zstream.msg = ""invalid window size (libpng)"";
-6.          return Z_DATA_ERROR;
-5.       }
-4.       png_ptr->zstream_start = 0;
-3.    }
-2.    return inflate(&png_ptr->zstream, flush);
-1. }

/*Zlib >= 1.2.4*/

1. #ifdef PNG_READ_COMPRESSED_TEXT_SUPPORTED
2. #if defined(PNG_READ_zTXt_SUPPORTED) || defined (PNG_READ_iTXt_SUPPORTED)
3. /* png_inflate now returns zlib error codes including Z_OK and Z_STREAM_END to
4.  * allow the caller to do multiple calls if required.  If the 'finish' flag is
5.  * set Z_FINISH will be passed to the final inflate() call and Z_STREAM_END must
6.  * be returned or there has been a problem, otherwise Z_SYNC_FLUSH is used and
7.  * Z_OK or Z_STREAM_END will be returned on success.
8.  *
9.  * The input and output sizes are updated to the actual amounts of data consumed
10.  * or written, not the amount available (as in a z_stream).  The data pointers",Not Useful
/*safe: < than ZLIB_IO_MAX*/,"-2.          avail = ZLIB_IO_MAX;
-1.          if (avail_in < avail)

/*safe: < than ZLIB_IO_MAX*/

1.          avail_in -= avail;
2.          png_ptr->zstream.avail_in = avail;",Not Useful
/*safe: < ZLIB_IO_MAX*/,"-5.             png_ptr->zstream.next_out = local_buffer;
-4.             if ((sizeof local_buffer) < avail)
-3.                avail = (sizeof local_buffer);
-2.          }
-1.          if (avail_out < avail)

/*safe: < ZLIB_IO_MAX*/

1.          png_ptr->zstream.avail_out = avail;
2.          avail_out -= avail;",Not Useful
/*zlib inflate call*/,"-2.          png_ptr->zstream.avail_out = avail;
-1.          avail_out -= avail;

/*zlib inflate call*/

 ",Not Useful
/*finish*/,"png_crc_finish(png_structrp png_ptr, png_uint_32 skip)

/*finish*/

1. {",Not Useful
/*finish*/,"png_crc_finish(png_structrp png_ptr, png_uint_32 skip)

/*finish*/

1. {",Not Useful
/*impossible!*/,"-2.          png_ptr->zowner = 0;
-1.       }

/*impossible!*/

1.          ret = PNG_UNEXPECTED_ZLIB_RETURN;
2.       return ret;
3.    }
4.    else
5.    {",Not Useful
/*READ_zTXt || READ_iTXt*/,"-4.       png_zstream_error(png_ptr, Z_MEM_ERROR);
-3.       return Z_MEM_ERROR;
-2.    }
-1. }

/*READ_zTXt || READ_iTXt*/

 ",Not Useful
/*READ_iCCP*/,"-9.    png_read_data(png_ptr, crc_bytes, 4);
-8.    if (need_crc != 0)
-7.    {
-6.       crc = png_get_uint_32(crc_bytes);
-5.       return ((int)(crc != png_ptr->crc));
-4.    }
-3.    else
-2.       return (0);
-1. }
#if defined(PNG_READ_iCCP_SUPPORTED) || defined(PNG_READ_iTXt_SUPPORTED) ||\

/*READ_iCCP*/

1.     defined(PNG_READ_pCAL_SUPPORTED) || defined(PNG_READ_sCAL_SUPPORTED) ||\
2.     defined(PNG_READ_sPLT_SUPPORTED) || defined(PNG_READ_tEXt_SUPPORTED) ||\
3.     defined(PNG_READ_zTXt_SUPPORTED) || defined(PNG_SEQUENTIAL_READ_SUPPORTED)",Not Useful
"/*invalid, png_set_IHDR calls png_error*/","-2.    switch (png_ptr->color_type)
-1.    {

/*invalid, png_set_IHDR calls png_error*/

1.       case PNG_COLOR_TYPE_GRAY:
2.       case PNG_COLOR_TYPE_PALETTE:
3.          png_ptr->channels = 1;
4.          break;
5.       case PNG_COLOR_TYPE_RGB:
6.          png_ptr->channels = 3;
7.          break;
8.       case PNG_COLOR_TYPE_GRAY_ALPHA:
9.          png_ptr->channels = 2;
10.          break;",Not Useful
"/*Otherwise, we (optionally) emit a warning and use the chunk.*/","-10.        * chunk type to determine whether to check the ancillary or the critical
-9.        * flags.
-8.        */
-7.       if ((png_ptr->flags & PNG_FLAG_CRC_ANCILLARY_USE) == 0)
-6.       {
-5.          if ((png_ptr->flags & PNG_FLAG_CRC_ANCILLARY_NOWARN) != 0)
-4.             return;
-3.          else
-2.             png_chunk_error(png_ptr, ""CRC error"");
-1.       }

/*Otherwise, we (optionally) emit a warning and use the chunk.*/

1.       else if ((png_ptr->flags & PNG_FLAG_CRC_ANCILLARY_NOWARN) == 0)
2.          png_chunk_warning(png_ptr, ""CRC error"");
3.    }
4. #endif
5.    /* TODO: png_set_PLTE has the side effect of setting png_ptr->palette to its
6.     * own copy of the palette.  This has the side effect that when png_start_row
7.     * is called (this happens after any call to png_read_update_info) the
8.     * info_ptr palette gets changed.  This is extremely unexpected and
9.     * confusing.
10.     *",Not Useful
/*prefer cHRM values*/,"-10.       return;
-9.    if ((png_ptr->colorspace.flags & PNG_COLORSPACE_FROM_cHRM) != 0)
-8.    {
-7.       png_ptr->colorspace.flags |= PNG_COLORSPACE_INVALID;
-6.       png_colorspace_sync(png_ptr, info_ptr);
-5.       png_chunk_benign_error(png_ptr, ""duplicate"");
-4.       return;
-3.    }
-2.    png_ptr->colorspace.flags |= PNG_COLORSPACE_FROM_cHRM;
-1.    (void)png_colorspace_set_chromaticities(png_ptr, &png_ptr->colorspace, &xy,

/*prefer cHRM values*/

1.    png_colorspace_sync(png_ptr, info_ptr);
2. }
3. #endif
4. #ifdef PNG_READ_sRGB_SUPPORTED",Not Useful
/*READ_sRGB*/,"-3.    png_colorspace_sync(png_ptr, info_ptr);
-2. }
-1. #endif
#ifdef PNG_READ_sRGB_SUPPORTED

/*READ_sRGB*/

 ",Not Useful
/*finish*/,"png_crc_finish(png_structrp png_ptr, png_uint_32 skip)

/*finish*/

1. {",Not Useful
/*steal*/,"-10.                                        info_ptr->iccp_name = png_voidcast(char*,
-9.                                            png_malloc_base(png_ptr,
-8.                                            keyword_length+1));
-7.                                        if (info_ptr->iccp_name != NULL)
-6.                                        {
-5.                                           memcpy(info_ptr->iccp_name, keyword,
-4.                                               keyword_length+1);
-3.                                           info_ptr->iccp_proflen =
-2.                                               profile_length;
-1.                                           info_ptr->iccp_profile = profile;

/*steal*/

1.                                           info_ptr->free_me |= PNG_FREE_ICCP;
2.                                           info_ptr->valid |= PNG_INFO_iCCP;
3.                                        }
4.                                        else
5.                                        {
6.                                           png_ptr->colorspace.flags |=
7.                                              PNG_COLORSPACE_INVALID;
8.                                           errmsg = ""out of memory"";
9.                                        }
10.                                     }",Not Useful
/*profile truncated*/,"-1.                            }

/*profile truncated*/

1.                               errmsg = png_ptr->zstream.msg;
2.                         }
3.                         else
4.                            errmsg = ""out of memory"";
5.                      }",Not Useful
/*profile truncated*/,"-1.                            }

/*profile truncated*/

1.                               errmsg = png_ptr->zstream.msg;
2.                         }
3.                         else
4.                            errmsg = ""out of memory"";
5.                      }",Not Useful
/*png_inflate_claim failed*/,"-2.                png_ptr->zowner = 0;
-1.             }

/*png_inflate_claim failed*/

1.                errmsg = png_ptr->zstream.msg;
2.          }
3.          else",Not Useful
/*or missing*/,"-3.                errmsg = png_ptr->zstream.msg;
-2.          }
-1.          else

/*or missing*/

1.       }
2.       else
3.          errmsg = ""bad keyword"";
4.    }
5.    else
6.       errmsg = ""too many profiles"";",Not Useful
/*READ_iCCP*/,"-9.    png_read_data(png_ptr, crc_bytes, 4);
-8.    if (need_crc != 0)
-7.    {
-6.       crc = png_get_uint_32(crc_bytes);
-5.       return ((int)(crc != png_ptr->crc));
-4.    }
-3.    else
-2.       return (0);
-1. }
#if defined(PNG_READ_iCCP_SUPPORTED) || defined(PNG_READ_iTXt_SUPPORTED) ||\

/*READ_iCCP*/

1.     defined(PNG_READ_pCAL_SUPPORTED) || defined(PNG_READ_sCAL_SUPPORTED) ||\
2.     defined(PNG_READ_sPLT_SUPPORTED) || defined(PNG_READ_tEXt_SUPPORTED) ||\
3.     defined(PNG_READ_zTXt_SUPPORTED) || defined(PNG_SEQUENTIAL_READ_SUPPORTED)",Not Useful
"/*This must fit in a png_uint_32 because it is derived from the original
    * chunk data length.*/","-7.    if (length < 2U || entry_start > buffer + (length - 2U))
-6.    {
-5.       png_warning(png_ptr, ""malformed sPLT chunk"");
-4.       return;
-3.    }
-2.    new_palette.depth = *entry_start++;
-1.    entry_size = (new_palette.depth == 8 ? 6 : 10);
   /* This must fit in a png_uint_32 because it is derived from the original
    * chunk data length.

/*This must fit in a png_uint_32 because it is derived from the original
    * chunk data length.*/

1.     */
2.    data_length = length - (png_uint_32)(entry_start - buffer);",Not Useful
/*READ_sPLT*/,"-10.    if (need_crc != 0)
-9.    {
-8.       crc = png_get_uint_32(crc_bytes);
-7.       return ((int)(crc != png_ptr->crc));
-6.    }
-5.    else
-4.       return (0);
-3. }
-2. #if defined(PNG_READ_iCCP_SUPPORTED) || defined(PNG_READ_iTXt_SUPPORTED) ||\
-1.     defined(PNG_READ_pCAL_SUPPORTED) || defined(PNG_READ_sCAL_SUPPORTED) ||\
    defined(PNG_READ_sPLT_SUPPORTED) || defined(PNG_READ_tEXt_SUPPORTED) ||\

/*READ_sPLT*/

1.     defined(PNG_READ_zTXt_SUPPORTED) || defined(PNG_SEQUENTIAL_READ_SUPPORTED)",Not Useful
/*Read the sCAL chunk*/,"-10.          png_chunk_benign_error(png_ptr, ""invalid data"");
-9.          return;
-8.       }
-7.    }
-6.    png_set_pCAL(png_ptr, info_ptr, (png_charp)buffer, X0, X1, type, nparams,
-5.        (png_charp)units, params);
-4.    png_free(png_ptr, params);
-3. }
-2. #endif
-1. #ifdef PNG_READ_sCAL_SUPPORTED

/*Read the sCAL chunk*/

 ",Not Useful
/*warn*/,"-10. png_get_uint_31(png_const_structrp png_ptr, png_const_bytep buf)
-9. {
-8.    png_uint_32 uval = png_get_uint_32(buf);
-7.    if (uval > PNG_UINT_31_MAX)
-6.       png_error(png_ptr, ""PNG unsigned integer out of range"");
-5.    return (uval);
-4. }
-3. #if defined(PNG_READ_gAMA_SUPPORTED) || defined(PNG_READ_cHRM_SUPPORTED)
-2. /* The following is a variation on the above for use with the fixed
-1.  * point values used for gAMA and cHRM.  Instead of png_error it
 * issues a warning and returns (-1) - an invalid value because both

/*warn*/

1.  * gAMA and cHRM use *unsigned* integers for fixed point values.
2.  */
3. #define PNG_FIXED_ERROR (-1)",Not Useful
/*warn*/,"-10. png_get_uint_31(png_const_structrp png_ptr, png_const_bytep buf)
-9. {
-8.    png_uint_32 uval = png_get_uint_32(buf);
-7.    if (uval > PNG_UINT_31_MAX)
-6.       png_error(png_ptr, ""PNG unsigned integer out of range"");
-5.    return (uval);
-4. }
-3. #if defined(PNG_READ_gAMA_SUPPORTED) || defined(PNG_READ_cHRM_SUPPORTED)
-2. /* The following is a variation on the above for use with the fixed
-1.  * point values used for gAMA and cHRM.  Instead of png_error it
 * issues a warning and returns (-1) - an invalid value because both

/*warn*/

1.  * gAMA and cHRM use *unsigned* integers for fixed point values.
2.  */
3. #define PNG_FIXED_ERROR (-1)",Not Useful
/*Now the language tag*/,"-10.     */
-9.    else if (prefix_length + 5 > length)
-8.       errmsg = ""truncated"";
-7.    else if (buffer[prefix_length+1] == 0 ||
-6.       (buffer[prefix_length+1] == 1 &&
-5.       buffer[prefix_length+2] == PNG_COMPRESSION_TYPE_BASE))
-4.    {
-3.       int compressed = buffer[prefix_length+1] != 0;
-2.       png_uint_32 language_offset, translated_keyword_offset;
-1.       png_alloc_size_t uncompressed_length = 0;

/*Now the language tag*/

1.       prefix_length += 3;
2.       language_offset = prefix_length;
3.       for (; prefix_length < length && buffer[prefix_length] != 0;
4.          ++prefix_length)",Not Useful
/*SAFE*/,"-10.        png_ptr->user_chunk_malloc_max < limit)
-9.       limit = png_ptr->user_chunk_malloc_max;
-8. #  elif PNG_USER_CHUNK_MALLOC_MAX > 0
-7.    if (PNG_USER_CHUNK_MALLOC_MAX < limit)
-6.       limit = PNG_USER_CHUNK_MALLOC_MAX;
-5. #  endif
-4.    if (length <= limit)
-3.    {
-2.       PNG_CSTRING_FROM_CHUNK(png_ptr->unknown_chunk.name, png_ptr->chunk_name);

/*SAFE*/

 ",Not Useful
/*SAFE*/,"-10.        png_ptr->user_chunk_malloc_max < limit)
-9.       limit = png_ptr->user_chunk_malloc_max;
-8. #  elif PNG_USER_CHUNK_MALLOC_MAX > 0
-7.    if (PNG_USER_CHUNK_MALLOC_MAX < limit)
-6.       limit = PNG_USER_CHUNK_MALLOC_MAX;
-5. #  endif
-4.    if (length <= limit)
-3.    {
-2.       PNG_CSTRING_FROM_CHUNK(png_ptr->unknown_chunk.name, png_ptr->chunk_name);

/*SAFE*/

 ",Not Useful
/*This is benign because we clean up correctly*/,"-6.          png_ptr->unknown_chunk.data = png_voidcast(png_bytep,
-5.              png_malloc_warn(png_ptr, length));
-4.       }
-3.    }
-2.    if (png_ptr->unknown_chunk.data == NULL && length > 0)
-1.    {

/*This is benign because we clean up correctly*/

1.       png_crc_finish(png_ptr, length);
2.       png_chunk_benign_error(png_ptr, ""unknown chunk exceeds memory limits"");
3.       return 0;
4.    }
5.    else
6.    {
7.       if (length > 0)
8.          png_crc_read(png_ptr, png_ptr->unknown_chunk.data, length);
9.       png_crc_finish(png_ptr, 0);
10.       return 1;",Not Useful
/*READ_UNKNOWN_CHUNKS*/,"-10.          if (png_set_text_2(png_ptr, info_ptr, &text, 1) != 0)
-9.             errmsg = ""insufficient memory"";
-8.       }
-7.    }
-6.    else
-5.       errmsg = ""bad compression info"";
-4.    if (errmsg != NULL)
-3.       png_chunk_benign_error(png_ptr, errmsg);
-2. }
-1. #endif
#ifdef PNG_READ_UNKNOWN_CHUNKS_SUPPORTED

/*READ_UNKNOWN_CHUNKS*/

 ",Not Useful
/*with keep = PNG_HANDLE_CHUNK_IF_SAFE*/,"-10.              */
-9.             if (keep < PNG_HANDLE_CHUNK_IF_SAFE)
-8.             {
-7. #              ifdef PNG_SET_UNKNOWN_CHUNKS_SUPPORTED
-6.                if (png_ptr->unknown_default < PNG_HANDLE_CHUNK_IF_SAFE)
-5.                {
-4.                   png_chunk_warning(png_ptr, ""Saving unknown chunk:"");
-3.                   png_app_warning(png_ptr,
-2.                       ""forcing save of an unhandled chunk;""
-1.                       "" please call png_set_keep_unknown_chunks"");

/*with keep = PNG_HANDLE_CHUNK_IF_SAFE*/

1.                }
2. #              endif
3.                keep = PNG_HANDLE_CHUNK_IF_SAFE;
4.             }
5.          }",Not Useful
/*Use the SAVE_UNKNOWN_CHUNKS code or skip the chunk*/,"-2.    }
-1.    else

/*Use the SAVE_UNKNOWN_CHUNKS code or skip the chunk*/

 ",Not Useful
/*READ_USER_CHUNKS*/,"
#  ifdef PNG_READ_USER_CHUNKS_SUPPORTED



/*READ_USER_CHUNKS*/

 ",Not Useful
/*FALLTHROUGH*/,"-10.    if (keep == PNG_HANDLE_CHUNK_ALWAYS ||
-9.       (keep == PNG_HANDLE_CHUNK_IF_SAFE &&
-8.        PNG_CHUNK_ANCILLARY(png_ptr->chunk_name)))
-7.    {
-6. #     ifdef PNG_USER_LIMITS_SUPPORTED
-5.       switch (png_ptr->user_chunk_cache_max)
-4.       {
-3.          case 2:
-2.             png_ptr->user_chunk_cache_max = 1;
-1.             png_chunk_benign_error(png_ptr, ""no space in chunk cache"");

/*FALLTHROUGH*/

1.          case 1:",Not Useful
/*FALLTHROUGH*/,"-10.    if (keep == PNG_HANDLE_CHUNK_ALWAYS ||
-9.       (keep == PNG_HANDLE_CHUNK_IF_SAFE &&
-8.        PNG_CHUNK_ANCILLARY(png_ptr->chunk_name)))
-7.    {
-6. #     ifdef PNG_USER_LIMITS_SUPPORTED
-5.       switch (png_ptr->user_chunk_cache_max)
-4.       {
-3.          case 2:
-2.             png_ptr->user_chunk_cache_max = 1;
-1.             png_chunk_benign_error(png_ptr, ""no space in chunk cache"");

/*FALLTHROUGH*/

1.          case 1:",Not Useful
/*no limit*/,"-2.             --(png_ptr->user_chunk_cache_max);

/*no limit*/

 ",Not Useful
/*USER_LIMITS*/,"-1.    png_alloc_size_t limit = PNG_SIZE_MAX;
# ifdef PNG_SET_USER_LIMITS_SUPPORTED

/*USER_LIMITS*/

1.    if (png_ptr->user_chunk_malloc_max > 0 &&
2.        png_ptr->user_chunk_malloc_max < limit)
3.       limit = png_ptr->user_chunk_malloc_max;
4. # elif PNG_USER_CHUNK_MALLOC_MAX > 0
5.    if (PNG_USER_CHUNK_MALLOC_MAX < limit)
6.       limit = PNG_USER_CHUNK_MALLOC_MAX;
7. # endif
8.    if (limit >= prefix_size + (terminate != 0))
9.    {
10.       int ret;",Not Useful
/*!PNG_READ_UNKNOWN_CHUNKS_SUPPORTED*/,"-3.    if (png_ptr->unknown_chunk.data != NULL)
-2.       png_free(png_ptr, png_ptr->unknown_chunk.data);
-1.    png_ptr->unknown_chunk.data = NULL;

/*!PNG_READ_UNKNOWN_CHUNKS_SUPPORTED*/

 ",Not Useful
/*!READ_UNKNOWN_CHUNKS*/,"-3.    png_crc_finish(png_ptr, length);
-2.    PNG_UNUSED(info_ptr)
-1.    PNG_UNUSED(keep)

/*!READ_UNKNOWN_CHUNKS*/

 ",Not Useful
/*zlib+deflate overhead*/,"-10.    {
-9.       png_alloc_size_t idat_limit = PNG_UINT_31_MAX;
-8.       size_t row_factor =
-7.          (png_ptr->width * png_ptr->channels * (png_ptr->bit_depth > 8? 2: 1)
-6.           + 1 + (png_ptr->interlaced? 6: 0));
-5.       if (png_ptr->height > PNG_UINT_32_MAX/row_factor)
-4.          idat_limit=PNG_UINT_31_MAX;
-3.       else
-2.          idat_limit = png_ptr->height * row_factor;
-1.       row_factor = row_factor > 32566? 32566 : row_factor;

/*zlib+deflate overhead*/

1.       idat_limit=idat_limit < PNG_UINT_31_MAX? idat_limit : PNG_UINT_31_MAX;
2.       limit = limit < idat_limit? idat_limit : limit;
3.    }
4.    if (length > limit)
5.    {
6.       png_debug2(0,"" length = %lu, limit = %lu"",
7.          (unsigned long)length,(unsigned long)limit);
8.       png_chunk_error(png_ptr, ""chunk data is too large"");
9.    }
10. }",Not Useful
/*PACKSWAP*/,"-2.       end_ptr = dp + PNG_ROWBYTES(pixel_depth, row_width) - 1;
-1.       end_byte = *end_ptr;
#     ifdef PNG_READ_PACKSWAP_SUPPORTED

/*PACKSWAP*/

1.       if ((png_ptr->transformations & PNG_PACKSWAP) != 0)",Not Useful
/*depth*/,"-4. png_handle_IHDR(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)
-3. {
-2.    png_byte buf[13];
-1.    png_uint_32 width, height;
   int bit_depth, color_type, compression_type, filter_type;

/*depth*/

1.    int interlace_type;
2.    png_debug(1, ""in png_handle_IHDR"");
3.    if ((png_ptr->mode & PNG_HAVE_IHDR) != 0)
4.       png_chunk_error(png_ptr, ""out of place"");",Not Useful
/*!PNG_USE_COMPILE_TIME_MASKS*/,"-5.             { B_MASKS(1,1), B_MASKS(2,1), B_MASKS(4,1) }
-4.          };
-3. #        define MASK(pass,depth,display,png)\
-2.             ((display)?display_mask[png][DEPTH_INDEX(depth)][pass>>1]:\
-1.                row_mask[png][DEPTH_INDEX(depth)][pass])

/*!PNG_USE_COMPILE_TIME_MASKS*/

 ",Not Useful
/*!USE_COMPILE_TIME_MASKS*/,"-2. #        define MASK(pass,depth,display,png)\
-1.             ((display)?B_MASK(pass,depth,png):S_MASK(pass,depth,png))

/*!USE_COMPILE_TIME_MASKS*/

 ",Not Useful
/*something to copy*/,"-1.             m &= 0xff;

/*something to copy*/

1.             {
2.                if (m != 0xff)
3.                   *dp = (png_byte)((*dp & ~m) | (*sp & m));
4.                else
5.                   *dp = *sp;
6.             }",Not Useful
/*SAFE*/,"-10.        png_ptr->user_chunk_malloc_max < limit)
-9.       limit = png_ptr->user_chunk_malloc_max;
-8. #  elif PNG_USER_CHUNK_MALLOC_MAX > 0
-7.    if (PNG_USER_CHUNK_MALLOC_MAX < limit)
-6.       limit = PNG_USER_CHUNK_MALLOC_MAX;
-5. #  endif
-4.    if (length <= limit)
-3.    {
-2.       PNG_CSTRING_FROM_CHUNK(png_ptr->unknown_chunk.name, png_ptr->chunk_name);

/*SAFE*/

 ",Not Useful
/*ALIGN_TYPE code*/,"-8.                      dp = (png_bytep)dp16;
-7.                      sp = (png_const_bytep)sp16;
-6.                      do
-5.                         *dp++ = *sp++;
-4.                      while (--row_width > 0);
-3.                      return;
-2.                   }
-1.                }

/*ALIGN_TYPE code*/

 ",Not Useful
/*SAFE*/,"-10.        png_ptr->user_chunk_malloc_max < limit)
-9.       limit = png_ptr->user_chunk_malloc_max;
-8. #  elif PNG_USER_CHUNK_MALLOC_MAX > 0
-7.    if (PNG_USER_CHUNK_MALLOC_MAX < limit)
-6.       limit = PNG_USER_CHUNK_MALLOC_MAX;
-5. #  endif
-4.    if (length <= limit)
-3.    {
-2.       PNG_CSTRING_FROM_CHUNK(png_ptr->unknown_chunk.name, png_ptr->chunk_name);

/*SAFE*/

 ",Not Useful
/*READ_INTERLACING*/,"
#ifdef PNG_READ_INTERLACING_SUPPORTED



/*READ_INTERLACING*/

1.    if (png_ptr->interlaced != 0 &&
2.        (png_ptr->transformations & PNG_INTERLACE) != 0 &&
3.        pass < 6 && (display == 0 ||",Not Useful
/*READ_INTERLACING*/,"
#ifdef PNG_READ_INTERLACING_SUPPORTED



/*READ_INTERLACING*/

1.    if (png_ptr->interlaced != 0 &&
2.        (png_ptr->transformations & PNG_INTERLACE) != 0 &&
3.        pass < 6 && (display == 0 ||",Not Useful
/*safety*/,"
      /* Set this for safety, just in case the previous owner left pointers to



/*safety*/

1.        * memory allocations.
2.        */
3.       png_ptr->zstream.next_in = NULL;
4.       png_ptr->zstream.avail_in = 0;
5.       png_ptr->zstream.next_out = NULL;
6.       png_ptr->zstream.avail_out = 0;
7.       if ((png_ptr->flags & PNG_FLAG_ZSTREAM_INITIALIZED) != 0)
8.       {
9. #if ZLIB_VERNUM >= 0x1240
10.          ret = inflateReset2(&png_ptr->zstream, window_bits);",Not Useful
/*SEQUENTIAL_READ*/,"-10.    {
-9.       crc = png_get_uint_32(crc_bytes);
-8.       return ((int)(crc != png_ptr->crc));
-7.    }
-6.    else
-5.       return (0);
-4. }
-3. #if defined(PNG_READ_iCCP_SUPPORTED) || defined(PNG_READ_iTXt_SUPPORTED) ||\
-2.     defined(PNG_READ_pCAL_SUPPORTED) || defined(PNG_READ_sCAL_SUPPORTED) ||\
-1.     defined(PNG_READ_sPLT_SUPPORTED) || defined(PNG_READ_tEXt_SUPPORTED) ||\
    defined(PNG_READ_zTXt_SUPPORTED) || defined(PNG_SEQUENTIAL_READ_SUPPORTED)

/*SEQUENTIAL_READ*/

 ",Not Useful
/*bad signature*/,"-2.     fread(sig, 1, 8, infile);
-1.     if (png_sig_cmp(sig, 0, 8))

/*bad signature*/

 ",Not Useful
/*bit_depth == 4*/,"-10.      * bit-depth transformations, so check depth and adjust if necessary */
-9.     if (bit_depth == 16) {
-8.         *red   = pBackground->red   >> 8;
-7.         *green = pBackground->green >> 8;
-6.         *blue  = pBackground->blue  >> 8;
-5.     } else if (color_type == PNG_COLOR_TYPE_GRAY && bit_depth < 8) {
-4.         if (bit_depth == 1)
-3.             *red = *green = *blue = pBackground->gray? 255 : 0;
-2.         else if (bit_depth == 2)
-1.             *red = *green = *blue = (255/3) * pBackground->gray;

/*bit_depth == 4*/

1.             *red = *green = *blue = (255/15) * pBackground->gray;
2.     } else {
3.         *red   = (uch)pBackground->red;
4.         *green = (uch)pBackground->green;
5.         *blue  = (uch)pBackground->blue;
6.     }
7.     return 0;
8. }",Not Useful
/*display_exponent == LUT_exponent * CRT_exponent*/,"-8.             *red = *green = *blue = (255/15) * pBackground->gray;
-7.     } else {
-6.         *red   = (uch)pBackground->red;
-5.         *green = (uch)pBackground->green;
-4.         *blue  = (uch)pBackground->blue;
-3.     }
-2.     return 0;
-1. }

/*display_exponent == LUT_exponent * CRT_exponent*/

1. uch *readpng_get_image(double display_exponent, int *pChannels, ulg *pRowbytes)
2. {
3.     double  gamma;
4.     png_uint_32  i, rowbytes;
5.     png_bytepp  row_pointers = NULL;",Not Useful
"/*READ_PNG and WRITE_PNG were not defined, so:*/","-6. #if PNG_LIBPNG_VER >= 10601 && defined(HAVE_CONFIG_H)
-5. #  define SKIP 77
-4. #else
-3. #  define SKIP 0
-2. #endif
-1. #if PNG_LIBPNG_VER < 10700

/*READ_PNG and WRITE_PNG were not defined, so:*/

1. #  ifdef PNG_INFO_IMAGE_SUPPORTED
2. #     ifdef PNG_SEQUENTIAL_READ_SUPPORTED
3. #        define PNG_READ_PNG_SUPPORTED",Not Useful
/*SEQUENTIAL_READ*/,"-1. #  ifdef PNG_INFO_IMAGE_SUPPORTED
#     ifdef PNG_SEQUENTIAL_READ_SUPPORTED

/*SEQUENTIAL_READ*/

1. #        define PNG_READ_PNG_SUPPORTED",Not Useful
/*pre 1.7.0*/,"-4. #     ifdef PNG_WRITE_SUPPORTED
-3. #        define PNG_WRITE_PNG_SUPPORTED

/*pre 1.7.0*/

1. #ifdef PNG_READ_PNG_SUPPORTED
2. /* If a transform is valid on both read and write this implies that if the
3.  * transform is applied to read it must also be applied on write to produce
4.  * meaningful data.  This is because these transforms when performed on read
5.  * produce data with a memory format that does not correspond to a PNG format.
6.  *
7.  * Most of these transforms are invertible; after applying the transform on
8.  * write the result is the original PNG data that would have would have been
9.  * read if no transform were applied.
10.  *",Not Useful
/*the transform was tested somewhere*/,"-4.    png_byte    when;
-3. #     define TRANSFORM_R  1
-2. #     define TRANSFORM_W  2
-1. #     define TRANSFORM_RW 3

/*the transform was tested somewhere*/

1. } transform_info[] =
2. {",Not Useful
/*!tested*/,"-3. #  define T(name,chunk,cm_required,cm_absent,bd,when)\
-2.    {  #name, PNG_TRANSFORM_ ## name, CHUNK_ ## chunk,\
-1.       COLOR_MASK_ ## cm_required, COLOR_MASK_ ## cm_absent, BD_ ## bd,\

/*!tested*/

1. #ifdef PNG_READ_STRIP_16_TO_8_SUPPORTED
2.    T(STRIP_16,            NONE, X,   X,   16,  R),",Not Useful
/*name*/,"-10.  * 6) PNG_INFO_chunk; a mask of the chunks that must be present for the
-9.  *    transform to fire.  All must be present - the requirement is that
-8.  *    png_get_valid() & mask == mask, so if mask is 0 there is no requirement.
-7.  *
-6.  * The condition refers to the original image state - if multiple transforms are
-5.  * used together it is possible to cause a transform that wouldn't fire on the
-4.  * original image to fire.
-3.  */
-2. static struct transform_info
-1. {
   const char *name;

/*name*/

1.    int         transform;
2.    png_uint_32 valid_chunks;
3. #     define CHUNK_NONE 0
4. #     define CHUNK_sBIT PNG_INFO_sBIT
5. #     define CHUNK_tRNS PNG_INFO_tRNS
6.    png_byte    color_mask_required;
7.    png_byte    color_mask_absent;
8. #     define COLOR_MASK_X   0
9. #     define COLOR_MASK_P   PNG_COLOR_MASK_PALETTE
10. #     define COLOR_MASK_C   PNG_COLOR_MASK_COLOR",Not Useful
/*!tested*/,"-3. #  define T(name,chunk,cm_required,cm_absent,bd,when)\
-2.    {  #name, PNG_TRANSFORM_ ## name, CHUNK_ ## chunk,\
-1.       COLOR_MASK_ ## cm_required, COLOR_MASK_ ## cm_absent, BD_ ## bd,\

/*!tested*/

1. #ifdef PNG_READ_STRIP_16_TO_8_SUPPORTED
2.    T(STRIP_16,            NONE, X,   X,   16,  R),",Not Useful
"/*problem, antidote*/","-2. static int known_bad_combos[][2] =
-1. {

/*problem, antidote*/

 ",Not Useful
/*antidote*/,"-2. static int known_bad_combos[][2] =
-1. {

/*antidote*/

 ",Not Useful
/*combo is ok*/,"-10. is_bad_combo(int transforms)
-9. {
-8.    unsigned int i;
-7.    for (i=0; i<ARRAY_SIZE(known_bad_combos); ++i)
-6.    {
-5.       int combo = known_bad_combos[i][0];
-4.       if ((combo & transforms) == combo &&
-3.          (transforms & known_bad_combos[i][1]) == 0)
-2.          return 1;
-1.    }

/*combo is ok*/

1. }
2. static const char *
3. transform_name(int t)",Not Useful
/*such as out-of-memory in a callback*/,"-6.    LIBPNG_WARNING,
-5.    APP_WARNING,

/*such as out-of-memory in a callback*/

 ",Not Useful
/*such as file-not-found*/,"-8.    LIBPNG_WARNING,
-7.    APP_WARNING,

/*such as file-not-found*/

1.    INTERNAL_ERROR
2. } error_level;",Not Useful
/*See display_log below*/,"-10.  * warnings (--relaxes) or nothing worse than information (--strict)
-9.  */
-8. #define RESULT_STRICT(r)   (((r) & ~((1U<<WARNINGS)-1)) == 0)
-7. #define RESULT_RELAXED(r)  (((r) & ~((1U<<ERRORS)-1)) == 0)
-6. struct display
-5. {

/*See display_log below*/

 ",Not Useful
/*prevents a crash*/,"-5. {
-4.    struct display *dp = (struct display*)png_get_error_ptr(pp);
-3.    if (dp == NULL)
-2.    {
-1.       fprintf(stderr, ""pngimage: internal error (no display)\n"");

/*prevents a crash*/

1.    }
2.    return dp;
3. }",Not Useful
/*NOTREACHED*/,"-10.    struct buffer_list *last = bp->current;
-9.    size_t read_count = bp->read_count;
-8.    while (size > 0)
-7.    {
-6.       size_t avail;
-5.       if (last == NULL ||
-4.          (last == bp->last && read_count >= bp->end_count))
-3.       {
-2.          display_log(dp, USER_ERROR, ""file truncated (%lu bytes)"",
-1.             (unsigned long)size);

/*NOTREACHED*/

1.          break;
2.       }
3.       else if (read_count >= sizeof last->buffer)
4.       {",Not Useful
/*NOTREACHED*/,"-10.    struct buffer_list *last = bp->current;
-9.    size_t read_count = bp->read_count;
-8.    while (size > 0)
-7.    {
-6.       size_t avail;
-5.       if (last == NULL ||
-4.          (last == bp->last && read_count >= bp->end_count))
-3.       {
-2.          display_log(dp, USER_ERROR, ""file truncated (%lu bytes)"",
-1.             (unsigned long)size);

/*NOTREACHED*/

1.          break;
2.       }
3.       else if (read_count >= sizeof last->buffer)
4.       {",Not Useful
/*no transform*/,"-8. #ifdef PNG_READ_PNG_SUPPORTED
-7. /* If a transform is valid on both read and write this implies that if the
-6.  * transform is applied to read it must also be applied on write to produce
-5.  * meaningful data.  This is because these transforms when performed on read
-4.  * produce data with a memory format that does not correspond to a PNG format.
-3.  *
-2.  * Most of these transforms are invertible; after applying the transform on
-1.  * write the result is the original PNG data that would have would have been
 * read if no transform were applied.

/*no transform*/

1.  *
2.  * The exception is _SHIFT, which destroys the low order bits marked as not
3.  * significant in a PNG with the sBIT chunk.
4.  *
5.  * The following table lists, for each transform, the conditions under which it
6.  * is expected to do anything.  Conditions are defined as follows:
7.  *
8.  * 1) Color mask bits required - simply a mask to AND with color_type; one of
9.  *    these must be present for the transform to fire, except that 0 means
10.  *    'always'.",Not Useful
/*rowbytes should be the same*/,"-7.    {
-6.       unsigned long chunks =
-5.          png_get_valid(dp->read_pp, dp->read_ip, 0xffffffff);
-4.       if (chunks != dp->chunks)
-3.          display_log(dp, APP_FAIL, ""PNG chunks changed from 0x%lx to 0x%lx"",
-2.             (unsigned long)dp->chunks, chunks);
-1.    }

/*rowbytes should be the same*/

1.    rowbytes = png_get_rowbytes(dp->read_pp, dp->read_ip);",Not Useful
/*NOTREACHED*/,"-10.    struct buffer_list *last = bp->current;
-9.    size_t read_count = bp->read_count;
-8.    while (size > 0)
-7.    {
-6.       size_t avail;
-5.       if (last == NULL ||
-4.          (last == bp->last && read_count >= bp->end_count))
-3.       {
-2.          display_log(dp, USER_ERROR, ""file truncated (%lu bytes)"",
-1.             (unsigned long)size);

/*NOTREACHED*/

1.          break;
2.       }
3.       else if (read_count >= sizeof last->buffer)
4.       {",Not Useful
"/*allowed, but dumb*/","-3.                for (b=0; b*8 < bpp; ++b)
-2.                   sig_bits[b] = (png_byte)(0xff00 >> sig_bits[b]);
-1.                break;

/*allowed, but dumb*/

 ",Not Useful
/*!sBIT*/,"-1.       }

/*!sBIT*/

1.          display_log(dp, INTERNAL_ERROR,
2.                ""active shift transform but no sBIT support"");",Not Useful
/*!sBIT*/,"-1.       }

/*!sBIT*/

1.          display_log(dp, INTERNAL_ERROR,
2.                ""active shift transform but no sBIT support"");",Not Useful
/*safety*/,"-10.    buffer->end_count = end_count;
-9. }
-8. static void PNGCBAPI
-7. write_function(png_structp pp, png_bytep data, png_size_t size)
-6. {
-5.    buffer_write(get_dp(pp), get_buffer(pp), data, size);
-4. }
-3. static void
-2. write_png(struct display *dp, png_infop ip, int transforms)
-1. {

/*safety*/

1.    buffer_start_write(&dp->written_file);
2.    dp->operation = ""write"";
3.    dp->transforms = transforms;
4.    dp->write_pp = png_create_write_struct(PNG_LIBPNG_VER_STRING, dp,
5.       display_error, display_warning);
6.    if (dp->write_pp == NULL)
7.       display_log(dp, APP_ERROR, ""failed to create write png_struct"");
8.    png_set_write_fn(dp->write_pp, &dp->written_file, write_function,",Not Useful
/*flush*/,"-8.    buffer_start_write(&dp->written_file);
-7.    dp->operation = ""write"";
-6.    dp->transforms = transforms;
-5.    dp->write_pp = png_create_write_struct(PNG_LIBPNG_VER_STRING, dp,
-4.       display_error, display_warning);
-3.    if (dp->write_pp == NULL)
-2.       display_log(dp, APP_ERROR, ""failed to create write png_struct"");
-1.    png_set_write_fn(dp->write_pp, &dp->written_file, write_function,

/*flush*/

1. #  ifdef PNG_SET_USER_LIMITS_SUPPORTED",Not Useful
/*WRITE_PNG*/,"-6. #if PNG_LIBPNG_VER >= 10601 && defined(HAVE_CONFIG_H)
-5. #  define SKIP 77
-4. #else
-3. #  define SKIP 0
-2. #endif
-1. #if PNG_LIBPNG_VER < 10700

/*WRITE_PNG*/

1. #  ifdef PNG_INFO_IMAGE_SUPPORTED
2. #     ifdef PNG_SEQUENTIAL_READ_SUPPORTED
3. #        define PNG_READ_PNG_SUPPORTED",Not Useful
/*skip*/,"-2. #endif
-1. /* 1.6.1 added support for the configure test harness, which uses 77 to indicate
 * a skipped test, in earlier versions we need to succeed on a skipped test, so:

/*skip*/

1.  */
2. #if PNG_LIBPNG_VER >= 10601 && defined(HAVE_CONFIG_H)
3. #  define SKIP 77
4. #else
5. #  define SKIP 0
6. #endif
7. #if PNG_LIBPNG_VER < 10700",Not Useful
/*don't skip*/,"-1.    }

/*don't skip*/

1. }
2. static void
3. test_one_file(struct display *dp, const char *filename)
4. {",Not Useful
/*transforms applied*/,"-5.    if (dp->ignored_transforms != 0)
-4.    {
-3.       read_png(dp, &dp->original_file, ""ignored transforms"",
-2.          dp->ignored_transforms);

/*transforms applied*/

 ",Not Useful
/*transforms*/,"-10.  * Copyright (c) 2015,2016 John Cunningham Bowler
-9.  *
-8.  * Last changed in libpng 1.6.24 [August 4, 2016]
-7.  *
-6.  * This code is released under the libpng license.
-5.  * For conditions of distribution and use, see the disclaimer
-4.  * and license in png.h
-3.  *
-2.  * Test the png_read_png and png_write_png interfaces.  Given a PNG file load it
-1.  * using png_read_png and then write with png_write_png.  Test all possible
 * transforms.

/*transforms*/

1.  */
2. #include <stdarg.h>
3. #include <stdlib.h>
4. #include <string.h>
5. #include <errno.h>
6. #include <stdio.h>
7. #include <assert.h>
8. #if defined(HAVE_CONFIG_H) && !defined(PNG_NO_CONFIG_H)
9. #  include <config.h>
10. #endif",Not Useful
/*transforms*/,"-10.  * Copyright (c) 2015,2016 John Cunningham Bowler
-9.  *
-8.  * Last changed in libpng 1.6.24 [August 4, 2016]
-7.  *
-6.  * This code is released under the libpng license.
-5.  * For conditions of distribution and use, see the disclaimer
-4.  * and license in png.h
-3.  *
-2.  * Test the png_read_png and png_write_png interfaces.  Given a PNG file load it
-1.  * using png_read_png and then write with png_write_png.  Test all possible
 * transforms.

/*transforms*/

1.  */
2. #include <stdarg.h>
3. #include <stdlib.h>
4. #include <string.h>
5. #include <errno.h>
6. #include <stdio.h>
7. #include <assert.h>
8. #if defined(HAVE_CONFIG_H) && !defined(PNG_NO_CONFIG_H)
9. #  include <config.h>
10. #endif",Not Useful
/*transforms applied*/,"-5.    if (dp->ignored_transforms != 0)
-4.    {
-3.       read_png(dp, &dp->original_file, ""ignored transforms"",
-2.          dp->ignored_transforms);

/*transforms applied*/

 ",Not Useful
/*Everything tested*/,"-4.          {
-3.             unsigned int next = current;
-2.             do
-1.             {

/*Everything tested*/

1.                   goto combo;
2.                ++next;",Not Useful
/*shouldn't longjmp on warnings*/,"-7. {
-6.    int ret = setjmp(dp->error_return);
-5.    if (ret == 0)
-4.    {
-3.       test_one_file(dp, file);
-2.       return 0;
-1.    }

/*shouldn't longjmp on warnings*/

1.       display_log(dp, INTERNAL_ERROR, ""unexpected return code %d"", ret);
2.    return ret;
3. }
4. int
5. main(const int argc, const char * const * const argv)
6. {",Not Useful
/*!READ_PNG*/,"-4.       display_destroy(&d);
-3.       return errors != 0;
-2.    }
-1. }

/*!READ_PNG*/

1. int
2. main(void)
3. {
4.    fprintf(stderr, ""pngimage: no support for png_read/write_image\n"");
5.    return SKIP;
6. }
7. #endif",Not Useful
/*WRITE_FLUSH*/,"
#ifdef PNG_WRITE_FLUSH_SUPPORTED



/*WRITE_FLUSH*/

 ",Not Useful
/*MAIN routine*/,"-4. static char *szProgName = PROGNAME;
-3. static char *szAppName = LONGNAME;
-2. static char *szIconName = PROGNAME;
-1. static char szCmdFileName [MAX_PATH];

/*MAIN routine*/

1. int WINAPI WinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance,
2.                     PSTR szCmdLine, int iCmdShow)
3. {
4.     HACCEL   hAccel;
5.     HWND     hwnd;
6.     MSG      msg;
7.     WNDCLASS wndclass;
8.     int ixBorders, iyBorders;
9.     wndclass.style         = CS_HREDRAW | CS_VREDRAW;
10.     wndclass.lpfnWndProc   = WndProc;",Not Useful
/*WvS: don't ask me why?*/,"-6.     ixBorders = 2 * (GetSystemMetrics (SM_CXBORDER) +
-5.                      GetSystemMetrics (SM_CXDLGFRAME));
-4.     iyBorders = 2 * (GetSystemMetrics (SM_CYBORDER) +
-3.                      GetSystemMetrics (SM_CYDLGFRAME)) +
-2.                      GetSystemMetrics (SM_CYCAPTION) +
-1.                      GetSystemMetrics (SM_CYMENUSIZE) +

/*WvS: don't ask me why?*/

1.     hwnd = CreateWindow (szProgName, szAppName,
2.         WS_OVERLAPPEDWINDOW,
3.         CW_USEDEFAULT, CW_USEDEFAULT,
4.         512 + 2 * MARGIN + ixBorders, 384 + 2 * MARGIN + iyBorders,",Not Useful
"/*CW_USEDEFAULT, CW_USEDEFAULT,*/","-2.     hwnd = CreateWindow (szProgName, szAppName,
-1.         WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT, CW_USEDEFAULT,

/*CW_USEDEFAULT, CW_USEDEFAULT,*/

1.         512 + 2 * MARGIN + ixBorders, 384 + 2 * MARGIN + iyBorders,",Not Useful
/*next/previous commands*/,"-4.         if (szCmdFileName[0] != '\0')
-3.         {
-2.             strcpy (szImgPathName, szCmdFileName);

/*next/previous commands*/

1.             BuildPngList (szImgPathName, &pPngFileList, &iPngFileCount,
2.                           &iPngFileIndex);",Not Useful
/*show the File Open dialog box*/,"-10.         if (pbImage)
-9.             EnableMenuItem (hMenu, IDM_FILE_SAVE, MF_ENABLED);
-8.         else
-7.             EnableMenuItem (hMenu, IDM_FILE_SAVE, MF_GRAYED);
-6.         return 0;
-5.     case WM_COMMAND:
-4.         hMenu = GetMenu (hwnd);
-3.         switch (LOWORD (wParam))
-2.         {
-1.         case IDM_FILE_OPEN:

/*show the File Open dialog box*/

1.             if (!PngFileOpenDlg (hwnd, szImgPathName, szTitleName))
2.                 return 0;",Not Useful
/*next/previous commands*/,"-4.         if (szCmdFileName[0] != '\0')
-3.         {
-2.             strcpy (szImgPathName, szCmdFileName);

/*next/previous commands*/

1.             BuildPngList (szImgPathName, &pPngFileList, &iPngFileCount,
2.                           &iPngFileIndex);",Not Useful
/*show the File Save dialog box*/,"-4.             DisplayImage (hwnd, &pDib, &pDiData, cxWinSize, cyWinSize,
-3.                 pbImage, cxImgSize, cyImgSize, cImgChannels, bStretched);
-2.             return 0;
-1.         case IDM_FILE_SAVE:

/*show the File Save dialog box*/

1.             if (!PngFileSaveDlg (hwnd, szImgPathName, szTitleName))
2.                 return 0;",Not Useful
/*save the PNG to a disk file*/,"-2.             if (!PngFileSaveDlg (hwnd, szImgPathName, szTitleName))
-1.                 return 0;

/*save the PNG to a disk file*/

1.             SetCursor (LoadCursor (NULL, IDC_WAIT));
2.             ShowCursor (TRUE);
3.             bOk = PngSaveImage (szImgPathName, pDiData, cxWinSize, cyWinSize,
4.                   bkgColor);
5.             ShowCursor (FALSE);
6.             SetCursor (LoadCursor (NULL, IDC_ARROW));
7.             if (!bOk)
8.                 MessageBox (hwnd, TEXT (""Error in saving the PNG image""),
9.                 szProgName, MB_ICONEXCLAMATION | MB_OK);
10.             return 0;",Not Useful
/*more cleanup needed...*/,"-5.                 DisplayImage (hwnd, &pDib, &pDiData, cxWinSize, cyWinSize,
-4.                     pbImage, cxImgSize, cyImgSize, cImgChannels, bStretched);
-3.             }
-2.             return 0;
-1.         case IDM_FILE_EXIT:

/*more cleanup needed...*/

 ",Not Useful
/*let's go ...*/,"-5.             if (pPngFileList != NULL)
-4.             {
-3.                 free (pPngFileList);
-2.                 pPngFileList = NULL;
-1.             }

/*let's go ...*/

1.             exit (0);
2.             return 0;
3.         case IDM_OPTIONS_STRETCH:
4.             bStretched = !bStretched;
5.             if (bStretched)
6.                 CheckMenuItem (hMenu, IDM_OPTIONS_STRETCH, MF_CHECKED);
7.             else
8.                 CheckMenuItem (hMenu, IDM_OPTIONS_STRETCH, MF_UNCHECKED);",Not Useful
"/*---------------
 *  CenterAbout
 *---------------*/","-1.  *  VisualPng.C -- Shows a PNG image
 *

/*---------------
 *  CenterAbout
 *---------------*/

1.  *
2.  * Copyright 2000,2017 Willem van Schaik.
3.  *
4.  * This code is released under the libpng license.
5.  * For conditions of distribution and use, see the disclaimer
6.  * and license in png.h
7.  */",Not Useful
"/*extract foldername, filename and search-name*/","-5.     if (*ppFileList != NULL)
-4.     {
-3.         free (*ppFileList);
-2.         *ppFileList = NULL;
-1.     }

/*extract foldername, filename and search-name*/

1.     strcpy (szImgPathName, pstrPathName);
2.     strcpy (szImgFileName, strrchr (pstrPathName, '\\') + 1);
3.     strcpy (szImgFindName, szImgPathName);
4.     *(strrchr (szImgFindName, '\\') + 1) = '\0';
5.     strcat (szImgFindName, ""*.png"");",Not Useful
"/*----------------
 *  SearchPngList
 *----------------*/","-1.  *  VisualPng.C -- Shows a PNG image
 *

/*----------------
 *  SearchPngList
 *----------------*/

1.  *
2.  * Copyright 2000,2017 Willem van Schaik.
3.  *
4.  * This code is released under the libpng license.
5.  * For conditions of distribution and use, see the disclaimer
6.  * and license in png.h
7.  */",Not Useful
/*BITMAPFILEHEADER        *pbmfh;*/,"-10.  *  DisplayImage
-9.  *----------------
-8.  */
-7. BOOL DisplayImage (HWND hwnd, BYTE **ppDib,
-6.         BYTE **ppDiData, int cxWinSize, int cyWinSize,
-5.         BYTE *pbImage, int cxImgSize, int cyImgSize, int cImgChannels,
-4.         BOOL bStretched)
-3. {
-2.     BYTE                       *pDib = *ppDib;
-1.     BYTE                       *pDiData = *ppDiData;

/*BITMAPFILEHEADER        *pbmfh;*/

1.     BITMAPINFOHEADER           *pbmih;
2.     WORD                        wDIRowBytes;
3.     png_color                   bkgBlack = {0, 0, 0};
4.     png_color                   bkgGray  = {127, 127, 127};
5.     png_color                   bkgWhite = {255, 255, 255};",Not Useful
"/*--------------
 *  InitBitmap
 *--------------*/","-1.  *  VisualPng.C -- Shows a PNG image
 *

/*--------------
 *  InitBitmap
 *--------------*/

1.  *
2.  * Copyright 2000,2017 Willem van Schaik.
3.  *
4.  * This code is released under the libpng license.
5.  * For conditions of distribution and use, see the disclaimer
6.  * and license in png.h
7.  */",Not Useful
"/*--------------
 *  FillBitmap
 *--------------*/","-1.  *  VisualPng.C -- Shows a PNG image
 *

/*--------------
 *  FillBitmap
 *--------------*/

1.  *
2.  * Copyright 2000,2017 Willem van Schaik.
3.  *
4.  * This code is released under the libpng license.
5.  * For conditions of distribution and use, see the disclaimer
6.  * and license in png.h
7.  */",Not Useful
/*calculate row-bytes*/,"-10.                 *pImg++ = g;
-9.                 *pImg++ = b;
-8.                 if (cImgChannels == 4)
-7.                 {
-6.                     a = *(pbImage + cImgChannels * ((yOld * cxImgSize) + xOld)
-5.                         + 3);
-4.                     *pImg++ = a;
-3.                 }
-2.             }
-1.         }

/*calculate row-bytes*/

1.         wImgRowBytes = cImgChannels * cxNewSize;
2.         wDIRowBytes = (WORD) ((cDIChannels * cxWinSize + 3L) >> 2) << 2;",Not Useful
/*calculate both row-bytes*/,"-4.         if (cxImgPos < MARGIN)
-3.             cxImgPos = MARGIN;
-2.         if (cyImgPos < MARGIN)
-1.             cyImgPos = MARGIN;

/*calculate both row-bytes*/

1.         wImgRowBytes = cImgChannels * cxImgSize;
2.         wDIRowBytes = (WORD) ((cDIChannels * cxWinSize + 3L) >> 2) << 2;",Not Useful
/*known to be > 0*/,"-4. static png_voidp
-3. png_malloc_array_checked(png_const_structrp png_ptr, int nelements,
-2.     size_t element_size)
-1. {

/*known to be > 0*/

1.    if (req <= PNG_SIZE_MAX/element_size)
2.       return png_malloc_base(png_ptr, req * element_size);",Not Useful
/*TEXT || sPLT || STORE_UNKNOWN_CHUNKS*/,"-1. }

/*TEXT || sPLT || STORE_UNKNOWN_CHUNKS*/

 ",Not Useful
/*USER_MEM*/,"-10. PNG_FUNCTION(png_voidp,PNGAPI
-9. png_calloc,(png_const_structrp png_ptr, png_alloc_size_t size),PNG_ALLOCATED)
-8. {
-7.    png_voidp ret;
-6.    ret = png_malloc(png_ptr, size);
-5.    if (ret != NULL)
-4.       memset(ret, 0, size);
-3.    return ret;
-2. }
-1. /* png_malloc_base, an internal function added at libpng 1.6.0, does the work of
 * allocating memory, taking into account limits and PNG_USER_MEM_SUPPORTED.

/*USER_MEM*/

1.  * Checking and error handling must happen outside this routine; it returns NULL
2.  * if the allocation cannot be done (for any reason.)
3.  */",Not Useful
/*USER_MEM*/,"-10. PNG_FUNCTION(png_voidp,PNGAPI
-9. png_calloc,(png_const_structrp png_ptr, png_alloc_size_t size),PNG_ALLOCATED)
-8. {
-7.    png_voidp ret;
-6.    ret = png_malloc(png_ptr, size);
-5.    if (ret != NULL)
-4.       memset(ret, 0, size);
-3.    return ret;
-2. }
-1. /* png_malloc_base, an internal function added at libpng 1.6.0, does the work of
 * allocating memory, taking into account limits and PNG_USER_MEM_SUPPORTED.

/*USER_MEM*/

1.  * Checking and error handling must happen outside this routine; it returns NULL
2.  * if the allocation cannot be done (for any reason.)
3.  */",Not Useful
/*USER_MEM*/,"-10. PNG_FUNCTION(png_voidp,PNGAPI
-9. png_calloc,(png_const_structrp png_ptr, png_alloc_size_t size),PNG_ALLOCATED)
-8. {
-7.    png_voidp ret;
-6.    ret = png_malloc(png_ptr, size);
-5.    if (ret != NULL)
-4.       memset(ret, 0, size);
-3.    return ret;
-2. }
-1. /* png_malloc_base, an internal function added at libpng 1.6.0, does the work of
 * allocating memory, taking into account limits and PNG_USER_MEM_SUPPORTED.

/*USER_MEM*/

1.  * Checking and error handling must happen outside this routine; it returns NULL
2.  * if the allocation cannot be done (for any reason.)
3.  */",Not Useful
/*__cplusplus*/,"
#ifdef __cplusplus



/*__cplusplus*/

1. #  define voidcast(type, value) static_cast<type>(value)
2. #  define aligncastconst(type, value) \
3.       static_cast<type>(static_cast<const void*>(value))
4. #else
5. #  define voidcast(type, value) (value)
6. #  define aligncastconst(type, value) ((const void*)(value))",Not Useful
/*not used*/,"-8. {
-7.    return u8d(255 * sRGB_from_linear(linear));
-6. }
-5. static png_byte
-4. isRGB(int fixed_linear)
-3. {
-2.    return sRGB(fixed_linear / 65535.);
-1. }

/*not used*/

1. static png_byte
2. unpremultiply(int component, int alpha)
3. {
4.    if (alpha <= component)",Not Useful
/*unused*/,"-1. #define ALLOW_UNUSED_GPC 0
   /* If true include unused static GPC functions and declare an external array

/*unused*/

1.     * of them to hide the fact that they are unused.  This is for development
2.     * use while testing the correct function to use to take into account libpng
3.     * misbehavior, such as using a simple power law to correct sRGB to linear.
4.     */",Not Useful
/*by experiment*/,"-5.       e = 1+floor(255 * e);
-4.       return (int)e;
-3.    }
-2.    return 0;
-1. }

/*by experiment*/

1. static int
2. power_law_error16(int value)
3. {
4.    if (value > 0 && value < 65535)
5.    {",Not Useful
/*unused*/,"-1. #define ALLOW_UNUSED_GPC 0
   /* If true include unused static GPC functions and declare an external array

/*unused*/

1.     * of them to hide the fact that they are unused.  This is for development
2.     * use while testing the correct function to use to take into account libpng
3.     * misbehavior, such as using a simple power law to correct sRGB to linear.
4.     */",Not Useful
/*All off*/,"-10. #define FORMAT_SET_COUNT (FORMAT_COUNT / 32)
-9. typedef struct
-8. {
-7.    png_uint_32 bits[FORMAT_SET_COUNT];
-6. }
-5. format_list;
-4. static void format_init(format_list *pf)
-3. {
-2.    int i;
-1.    for (i=0; i<FORMAT_SET_COUNT; ++i)

/*All off*/

1. }",Not Useful
/*currently unused*/,"-1. }

/*currently unused*/

1. static void format_clear(format_list *pf)
2. {
3.    int i;
4.    for (i=0; i<FORMAT_SET_COUNT; ++i)
5.       pf->bits[i] = 0;
6. }
7. #endif
8. static int format_is_initial(format_list *pf)
9. {
10.    int i;",Not Useful
/*currently unused*/,"-1. }

/*currently unused*/

1. static void format_clear(format_list *pf)
2. {
3.    int i;
4.    for (i=0; i<FORMAT_SET_COUNT; ++i)
5.       pf->bits[i] = 0;
6. }
7. #endif
8. static int format_is_initial(format_list *pf)
9. {
10.    int i;",Not Useful
/*8-bit to 8-bit conversions*/,"-10.       out->r = out->g = out->b = 65535;
-9.    else
-8.    {
-7.       out->r = in->r;
-6.       out->g = in->g;
-5.       out->b = in->b;
-4.    }
-3.    out->a = in->a;
-2. }
-1. #endif

/*8-bit to 8-bit conversions*/

 ",Not Useful
/*8-bit to 16-bit conversions*/,"-10.             sRGB_to_d[in->r], sRGB_to_d[in->g], sRGB_to_d[in->b]));
-9.    }
-8.    else
-7.    {
-6.       double a = in->a/255.;
-5.       out->r = out->g = out->b = sRGB(a * YfromRGB(sRGB_to_d[in->r],
-4.          sRGB_to_d[in->g], sRGB_to_d[in->b]) + back->dg * (1-a));
-3.    }
-2.    out->a = 255;
-1. }

/*8-bit to 16-bit conversions*/

 ",Not Useful
/*16-bit to 8-bit conversions*/,"-10. {
-9.    (void)back;
-8.    if (in->r == in->g && in->g == in->b)
-7.       out->r = out->g = out->b = ilineara_g22(in->g, in->a);
-6.    else
-5.       out->r = out->g = out->b = u16d(in->a * 257 *
-4.          YfromRGB(g22_to_d[in->r], g22_to_d[in->g], g22_to_d[in->b]));
-3.    out->a = 65535;
-2. }
-1. #endif

/*16-bit to 8-bit conversions*/

 ",Not Useful
/*16-bit to 16-bit conversions*/,"-10.    {
-9.       double a = in->a / 65535.;
-8.       double a1 = 1-a;
-7.       a /= 65535;
-6.       out->r = sRGB(in->r * a + back->dr * a1);
-5.       out->g = sRGB(in->g * a + back->dg * a1);
-4.       out->b = sRGB(in->b * a + back->db * a1);
-3.    }
-2.    out->a = 255;
-1. }

/*16-bit to 16-bit conversions*/

 ",Not Useful
/*in*/,"-3. /*-
-2.  * pngstest.c
-1.  *
 * Last changed in libpng 1.6.31 [July 27, 2017]

/*in*/

1.  * Copyright (c) 2013-2017 John Cunningham Bowler
2.  *
3.  * This code is released under the libpng license.
4.  * For conditions of distribution and use, see the disclaimer
5.  * and license in png.h
6.  *
7.  * Test for the PNG 'simplified' APIs.
8.  */
9. #define _ISOC90_SOURCE 1",Not Useful
/*in*/,"-3. /*-
-2.  * pngstest.c
-1.  *
 * Last changed in libpng 1.6.31 [July 27, 2017]

/*in*/

1.  * Copyright (c) 2013-2017 John Cunningham Bowler
2.  *
3.  * This code is released under the libpng license.
4.  * For conditions of distribution and use, see the disclaimer
5.  * and license in png.h
6.  *
7.  * Test for the PNG 'simplified' APIs.
8.  */
9. #define _ISOC90_SOURCE 1",Not Useful
/*not used*/,"-8. {
-7.    return u8d(255 * sRGB_from_linear(linear));
-6. }
-5. static png_byte
-4. isRGB(int fixed_linear)
-3. {
-2.    return sRGB(fixed_linear / 65535.);
-1. }

/*not used*/

1. static png_byte
2. unpremultiply(int component, int alpha)
3. {
4.    if (alpha <= component)",Not Useful
/*not used*/,"-8. {
-7.    return u8d(255 * sRGB_from_linear(linear));
-6. }
-5. static png_byte
-4. isRGB(int fixed_linear)
-3. {
-2.    return sRGB(fixed_linear / 65535.);
-1. }

/*not used*/

1. static png_byte
2. unpremultiply(int component, int alpha)
3. {
4.    if (alpha <= component)",Not Useful
/*(128.5 * 255 / 65535)*/,"-10.       /* 16-bit values less than 128.5 get rounded to 8-bit 0 and so the worst
-9.        * case error arises with 16-bit 128.5, work out what sRGB
-8.        * (non-associated) value generates 128.5; any value less than this is
-7.        * going to map to 0, so the worst error is floor(value).
-6.        *
-5.        * Note that errors are considerably higher (more than a factor of 2)
-4.        * because libpng uses a simple power law for sRGB data at present.
-3.        *
-2.        * Add .1 for arithmetic errors inside libpng.
-1.        */
      double v = floor(255*pow(.5/*(128.5 * 255 / 65535)*/ / alpha, 1/2.2)+.1);

/*(128.5 * 255 / 65535)*/

1.       error_via_linear[alpha] = (int)v;
2.    }",Not Useful
/*not used*/,"-8. {
-7.    return u8d(255 * sRGB_from_linear(linear));
-6. }
-5. static png_byte
-4. isRGB(int fixed_linear)
-3. {
-2.    return sRGB(fixed_linear / 65535.);
-1. }

/*not used*/

1. static png_byte
2. unpremultiply(int component, int alpha)
3. {
4.    if (alpha <= component)",Not Useful
/*exact match*/,"-6.    {
-5.       int err_r = abs(pixel_calc.r - pixel_out.r);
-4.       int err_g = abs(pixel_calc.g - pixel_out.g);
-3.       int err_b = abs(pixel_calc.b - pixel_out.b);
-2.       int limit;
-1.       if ((err_r | err_g | err_b) == 0)

/*exact match*/

 ",Not Useful
/*opaque*/,"-8. static int
-7. logerror(Image *image, const char *a1, const char *a2, const char *a3)
-6. {
-5.    fflush(stdout);
-4.    if (image->image.warning_or_error)
-3.       fprintf(stderr, ""%s%s%s: %s\n"", a1, a2, a3, image->image.message);
-2.    else
-1.       fprintf(stderr, ""%s%s%s\n"", a1, a2, a3);
   if (image->image.opaque != NULL)

/*opaque*/

1.    {
2.       fprintf(stderr, ""%s: image opaque pointer non-NULL on error\n"",
3.          image->file_name);
4.       png_image_free(&image->image);
5.    }
6.    return 0;
7. }",Not Useful
/*SAFE*/,"-4.          if (amax >= a->image.colormap_entries)
-3.          {
-2.             char pindex[3+2*BYTE_CHARS];
-1.             sprintf(pindex, ""%d[%u]"", amax,

/*SAFE*/

1.             return logerror(a, a->file_name, "": bad pixel index: "", pindex);
2.          }
3.          else if (bmax >= b->image.colormap_entries)
4.          {
5.             char pindex[3+2*BYTE_CHARS];
6.             sprintf(pindex, ""%d[%u]"", bmax,",Not Useful
/*SAFE*/,"-4.          if (amax >= a->image.colormap_entries)
-3.          {
-2.             char pindex[3+2*BYTE_CHARS];
-1.             sprintf(pindex, ""%d[%u]"", amax,

/*SAFE*/

1.             return logerror(a, a->file_name, "": bad pixel index: "", pindex);
2.          }
3.          else if (bmax >= b->image.colormap_entries)
4.          {
5.             char pindex[3+2*BYTE_CHARS];
6.             sprintf(pindex, ""%d[%u]"", bmax,",Not Useful
/*FALLTHROUGH*/,"-7.             {
-6.                png_const_uint_16p pua = aligncastconst(png_const_uint_16p, psa);
-5.                png_const_uint_16p pub = aligncastconst(png_const_uint_16p, psb);
-4.                switch (bchannels)
-3.                {
-2.                   case 4:
-1.                      if (pua[btoa[3]] != pub[3]) break;

/*FALLTHROUGH*/

1.                   case 3:
2.                      if (pua[btoa[2]] != pub[2]) break;",Not Useful
/*FALLTHROUGH*/,"-7.             {
-6.                png_const_uint_16p pua = aligncastconst(png_const_uint_16p, psa);
-5.                png_const_uint_16p pub = aligncastconst(png_const_uint_16p, psb);
-4.                switch (bchannels)
-3.                {
-2.                   case 4:
-1.                      if (pua[btoa[3]] != pub[3]) break;

/*FALLTHROUGH*/

1.                   case 3:
2.                      if (pua[btoa[2]] != pub[2]) break;",Not Useful
/*FALLTHROUGH*/,"-7.             {
-6.                png_const_uint_16p pua = aligncastconst(png_const_uint_16p, psa);
-5.                png_const_uint_16p pub = aligncastconst(png_const_uint_16p, psb);
-4.                switch (bchannels)
-3.                {
-2.                   case 4:
-1.                      if (pua[btoa[3]] != pub[3]) break;

/*FALLTHROUGH*/

1.                   case 3:
2.                      if (pua[btoa[2]] != pub[2]) break;",Not Useful
/*x loop*/,"-3.                   case 1:
-2.                      if (pua[btoa[0]] != pub[0]) break;
-1.                      if (alpha_added != 4 && pub[alpha_added] != 65535) break;

/*x loop*/

1.                   default:",Not Useful
/*impossible*/,"-10.  *
-9.  * Errors in alpha should only occur when converting from a direct format
-8.  * to a colormapped format, when alpha is effectively smashed (so large
-7.  * errors can occur.)  There should be no error in the '0' and 'opaque'
-6.  * values.  The fourth entry in the array is used for the alpha error (and it
-5.  * should always be zero for the 'via linear' case since this is never color
-4.  * mapped.)
-3.  *
-2.  * Mapping to a colormap smashes the colors, it is necessary to have separate
-1.  * values for these cases because they are much larger; it is very much
 * impossible to obtain a reasonable result, these are held in

/*impossible*/

1.  * gpc_error_to_colormap.
2.  */",Not Useful
/*FALLTHROUGH*/,"-7.             {
-6.                png_const_uint_16p pua = aligncastconst(png_const_uint_16p, psa);
-5.                png_const_uint_16p pub = aligncastconst(png_const_uint_16p, psb);
-4.                switch (bchannels)
-3.                {
-2.                   case 4:
-1.                      if (pua[btoa[3]] != pub[3]) break;

/*FALLTHROUGH*/

1.                   case 3:
2.                      if (pua[btoa[2]] != pub[2]) break;",Not Useful
/*FALLTHROUGH*/,"-7.             {
-6.                png_const_uint_16p pua = aligncastconst(png_const_uint_16p, psa);
-5.                png_const_uint_16p pub = aligncastconst(png_const_uint_16p, psb);
-4.                switch (bchannels)
-3.                {
-2.                   case 4:
-1.                      if (pua[btoa[3]] != pub[3]) break;

/*FALLTHROUGH*/

1.                   case 3:
2.                      if (pua[btoa[2]] != pub[2]) break;",Not Useful
/*FALLTHROUGH*/,"-7.             {
-6.                png_const_uint_16p pua = aligncastconst(png_const_uint_16p, psa);
-5.                png_const_uint_16p pub = aligncastconst(png_const_uint_16p, psb);
-4.                switch (bchannels)
-3.                {
-2.                   case 4:
-1.                      if (pua[btoa[3]] != pub[3]) break;

/*FALLTHROUGH*/

1.                   case 3:
2.                      if (pua[btoa[2]] != pub[2]) break;",Not Useful
/*x loop*/,"-3.                   case 1:
-2.                      if (pua[btoa[0]] != pub[0]) break;
-1.                      if (alpha_added != 4 && pub[alpha_added] != 65535) break;

/*x loop*/

1.                   default:",Not Useful
/*impossible*/,"-10.  *
-9.  * Errors in alpha should only occur when converting from a direct format
-8.  * to a colormapped format, when alpha is effectively smashed (so large
-7.  * errors can occur.)  There should be no error in the '0' and 'opaque'
-6.  * values.  The fourth entry in the array is used for the alpha error (and it
-5.  * should always be zero for the 'via linear' case since this is never color
-4.  * mapped.)
-3.  *
-2.  * Mapping to a colormap smashes the colors, it is necessary to have separate
-1.  * values for these cases because they are much larger; it is very much
 * impossible to obtain a reasonable result, these are held in

/*impossible*/

1.  * gpc_error_to_colormap.
2.  */",Not Useful
/*SIMPLIFIED_WRITE_STDIO*/,"-10.    return read_file(image, FORMAT_NO_CHANGE, NULL);
-9. }
-8. #ifdef PNG_SIMPLIFIED_WRITE_SUPPORTED
-7. static int
-6. write_one_file(Image *output, Image *image, int convert_to_8bit)
-5. {
-4.    if (image->opts & FAST_WRITE)
-3.       image->image.flags |= PNG_IMAGE_FLAG_FAST;
-2.    if (image->opts & USE_STDIO)
-1.    {
#ifdef PNG_SIMPLIFIED_WRITE_STDIO_SUPPORTED

/*SIMPLIFIED_WRITE_STDIO*/

1. #ifndef __COVERITY__
2.       FILE *f = tmpfile();
3. #else
4.       /* Experimental. Coverity says tmpfile() is insecure because it
5.        * generates predictable names.
6.        *
7.        * It is possible to satisfy Coverity by using mkstemp(); however,
8.        * any platform supporting mkstemp() undoubtedly has a secure tmpfile()
9.        * implementation as well, and doesn't need the fix.  Note that
10.        * the fix won't work on platforms that don't support mkstemp().",Not Useful
/*SIMPLIFIED_WRITE_STDIO*/,"-10.    return read_file(image, FORMAT_NO_CHANGE, NULL);
-9. }
-8. #ifdef PNG_SIMPLIFIED_WRITE_SUPPORTED
-7. static int
-6. write_one_file(Image *output, Image *image, int convert_to_8bit)
-5. {
-4.    if (image->opts & FAST_WRITE)
-3.       image->image.flags |= PNG_IMAGE_FLAG_FAST;
-2.    if (image->opts & USE_STDIO)
-1.    {
#ifdef PNG_SIMPLIFIED_WRITE_STDIO_SUPPORTED

/*SIMPLIFIED_WRITE_STDIO*/

1. #ifndef __COVERITY__
2.       FILE *f = tmpfile();
3. #else
4.       /* Experimental. Coverity says tmpfile() is insecure because it
5.        * generates predictable names.
6.        *
7.        * It is possible to satisfy Coverity by using mkstemp(); however,
8.        * any platform supporting mkstemp() undoubtedly has a secure tmpfile()
9.        * implementation as well, and doesn't need the fix.  Note that
10.        * the fix won't work on platforms that don't support mkstemp().",Not Useful
/*SIMPLIFIED_WRITE_STDIO*/,"-10.    return read_file(image, FORMAT_NO_CHANGE, NULL);
-9. }
-8. #ifdef PNG_SIMPLIFIED_WRITE_SUPPORTED
-7. static int
-6. write_one_file(Image *output, Image *image, int convert_to_8bit)
-5. {
-4.    if (image->opts & FAST_WRITE)
-3.       image->image.flags |= PNG_IMAGE_FLAG_FAST;
-2.    if (image->opts & USE_STDIO)
-1.    {
#ifdef PNG_SIMPLIFIED_WRITE_STDIO_SUPPORTED

/*SIMPLIFIED_WRITE_STDIO*/

1. #ifndef __COVERITY__
2.       FILE *f = tmpfile();
3. #else
4.       /* Experimental. Coverity says tmpfile() is insecure because it
5.        * generates predictable names.
6.        *
7.        * It is possible to satisfy Coverity by using mkstemp(); however,
8.        * any platform supporting mkstemp() undoubtedly has a secure tmpfile()
9.        * implementation as well, and doesn't need the fix.  Note that
10.        * the fix won't work on platforms that don't support mkstemp().",Not Useful
/*SIMPLIFIED_WRITE_STDIO*/,"-10.    return read_file(image, FORMAT_NO_CHANGE, NULL);
-9. }
-8. #ifdef PNG_SIMPLIFIED_WRITE_SUPPORTED
-7. static int
-6. write_one_file(Image *output, Image *image, int convert_to_8bit)
-5. {
-4.    if (image->opts & FAST_WRITE)
-3.       image->image.flags |= PNG_IMAGE_FLAG_FAST;
-2.    if (image->opts & USE_STDIO)
-1.    {
#ifdef PNG_SIMPLIFIED_WRITE_STDIO_SUPPORTED

/*SIMPLIFIED_WRITE_STDIO*/

1. #ifndef __COVERITY__
2.       FILE *f = tmpfile();
3. #else
4.       /* Experimental. Coverity says tmpfile() is insecure because it
5.        * generates predictable names.
6.        *
7.        * It is possible to satisfy Coverity by using mkstemp(); however,
8.        * any platform supporting mkstemp() undoubtedly has a secure tmpfile()
9.        * implementation as well, and doesn't need the fix.  Note that
10.        * the fix won't work on platforms that don't support mkstemp().",Not Useful
/*via_linear*/,"-10. }
-9. static int
-8. compare_16bit(int v1, int v2, int error_limit, int multiple_algorithms)
-7. {
-6.    int e = abs(v1-v2);
-5.    int ev1, ev2;
-4.    if (e <= error_limit)
-3.       return 1;
-2.    /* ""multiple_algorithms"" in this case means that a color-map has been
-1.     * involved somewhere, so we can deduce that the values were forced to 8-bit
    * (like the via_linear case for 8-bit.)

/*via_linear*/

1.     */
2.    if (!multiple_algorithms)
3.       return 0;
4.    ev1 = power_law_error16(v1);
5.    if (e <= ev1)
6.       return 1;
7.    ev2 = power_law_error16(v2);
8.    if (e <= ev2)
9.       return 1;
10.    return 0;",Not Useful
/*PNG_SIMPLIFIED_WRITE_SUPPORTED*/,"-10.             else
-9.                return logclose(image, f, image->file_name, "": seek failed: "");
-8.          }
-7.       }
-6.       else
-5.          return logerror(image, image->file_name, "": open failed: "",
-4.             strerror(errno));
-3.    }
-2.    return read_file(image, FORMAT_NO_CHANGE, NULL);
-1. }
#ifdef PNG_SIMPLIFIED_WRITE_SUPPORTED

/*PNG_SIMPLIFIED_WRITE_SUPPORTED*/

1. static int
2. write_one_file(Image *output, Image *image, int convert_to_8bit)
3. {
4.    if (image->opts & FAST_WRITE)
5.       image->image.flags |= PNG_IMAGE_FLAG_FAST;
6.    if (image->opts & USE_STDIO)
7.    {
8. #ifdef PNG_SIMPLIFIED_WRITE_STDIO_SUPPORTED
9. #ifndef __COVERITY__
10.       FILE *f = tmpfile();",Not Useful
/*skipped: no support*/,"-10.          log_pass = 1;
-9.       else if (strcmp(arg, ""--fresh"") == 0)
-8.       {
-7.          memset(gpc_error, 0, sizeof gpc_error);
-6.          memset(gpc_error_via_linear, 0, sizeof gpc_error_via_linear);
-5.       }
-4.       else if (strcmp(arg, ""--file"") == 0)
-3. #        ifdef PNG_STDIO_SUPPORTED
-2.             opts |= USE_FILE;
-1. #        else

/*skipped: no support*/

1. #        endif
2.       else if (strcmp(arg, ""--memory"") == 0)
3.          opts &= ~USE_FILE;
4.       else if (strcmp(arg, ""--stdio"") == 0)
5. #        ifdef PNG_STDIO_SUPPORTED
6.             opts |= USE_STDIO;
7. #        else",Not Useful
/*skipped: no support*/,"-10.          log_pass = 1;
-9.       else if (strcmp(arg, ""--fresh"") == 0)
-8.       {
-7.          memset(gpc_error, 0, sizeof gpc_error);
-6.          memset(gpc_error_via_linear, 0, sizeof gpc_error_via_linear);
-5.       }
-4.       else if (strcmp(arg, ""--file"") == 0)
-3. #        ifdef PNG_STDIO_SUPPORTED
-2.             opts |= USE_FILE;
-1. #        else

/*skipped: no support*/

1. #        endif
2.       else if (strcmp(arg, ""--memory"") == 0)
3.          opts &= ~USE_FILE;
4.       else if (strcmp(arg, ""--stdio"") == 0)
5. #        ifdef PNG_STDIO_SUPPORTED
6.             opts |= USE_STDIO;
7. #        else",Not Useful
/*in*/,"-3. /*-
-2.  * pngstest.c
-1.  *
 * Last changed in libpng 1.6.31 [July 27, 2017]

/*in*/

1.  * Copyright (c) 2013-2017 John Cunningham Bowler
2.  *
3.  * This code is released under the libpng license.
4.  * For conditions of distribution and use, see the disclaimer
5.  * and license in png.h
6.  *
7.  * Test for the PNG 'simplified' APIs.
8.  */
9. #define _ISOC90_SOURCE 1",Not Useful
/*a*/,"-3. /*-
-2.  * pngstest.c
-1.  *
 * Last changed in libpng 1.6.31 [July 27, 2017]

/*a*/

1.  * Copyright (c) 2013-2017 John Cunningham Bowler
2.  *
3.  * This code is released under the libpng license.
4.  * For conditions of distribution and use, see the disclaimer
5.  * and license in png.h
6.  *
7.  * Test for the PNG 'simplified' APIs.
8.  */
9. #define _ISOC90_SOURCE 1",Not Useful
/*i*/,"-3. /*-
-2.  * pngstest.c
-1.  *
 * Last changed in libpng 1.6.31 [July 27, 2017]

/*i*/

1.  * Copyright (c) 2013-2017 John Cunningham Bowler
2.  *
3.  * This code is released under the libpng license.
4.  * For conditions of distribution and use, see the disclaimer
5.  * and license in png.h
6.  *
7.  * Test for the PNG 'simplified' APIs.
8.  */
9. #define _ISOC90_SOURCE 1",Not Useful
/*o*/,"-4. /*-
-3.  * pngstest.c
-2.  *
-1.  * Last changed in libpng 1.6.31 [July 27, 2017]
 * Copyright (c) 2013-2017 John Cunningham Bowler

/*o*/

1.  *
2.  * This code is released under the libpng license.
3.  * For conditions of distribution and use, see the disclaimer
4.  * and license in png.h
5.  *
6.  * Test for the PNG 'simplified' APIs.
7.  */
8. #define _ISOC90_SOURCE 1",Not Useful
/*!PNG_SIMPLIFIED_READ_SUPPORTED*/,"-10.       }
-9.       else
-8.       {
-7.          fflush(stdout);
-6.          fprintf(stderr, ""%s: open failed\n"", touch);
-5.          exit(99);
-4.       }
-3.    }
-2.    return retval;
-1. }

/*!PNG_SIMPLIFIED_READ_SUPPORTED*/

1. int main(void)
2. {
3.    fprintf(stderr, ""pngstest: no read support in libpng, test skipped\n"");",Not Useful
/*So the test is skipped:*/,"-3. int main(void)
-2. {
-1.    fprintf(stderr, ""pngstest: no read support in libpng, test skipped\n"");

/*So the test is skipped:*/

1.    return SKIP;
2. }",Not Useful
/*PNG_SIMPLIFIED_READ_SUPPORTED*/,"-5. #if PNG_LIBPNG_VER >= 10601 && defined(HAVE_CONFIG_H)
-4. #  define SKIP 77
-3. #else
-2. #  define SKIP 0
-1. #endif

/*PNG_SIMPLIFIED_READ_SUPPORTED*/

1. #include ""../tools/sRGB.h""",Not Useful
/*deprecated*/,"-2. #define png_gAMA PNG_U32(103,  65,  77,  65)
-1. #define png_gIFg PNG_U32(103,  73,  70, 103)

/*deprecated*/

1. #define png_gIFx PNG_U32(103,  73,  70, 120)
2. #define png_hIST PNG_U32(104,  73,  83,  84)
3. #define png_iCCP PNG_U32(105,  67,  67,  80)
4. #define png_iTXt PNG_U32(105,  84,  88, 116)
5. #define png_oFFs PNG_U32( ,  70,  70, 115)
6. #define png_pCAL PNG_U32(112,  67,  65,  76)
7. #define png_pHYs PNG_U32(112,  72,  89, 115)
8. #define png_sBIT PNG_U32(115,  66,  73,  84)
9. #define png_sCAL PNG_U32(115,  67,  65,  76)
10. #define png_sPLT PNG_U32(115,  80,  76,  84)",Not Useful
/*__cplusplus*/,"
#ifdef __cplusplus



/*__cplusplus*/

1. #  define this not_the_cpp_this
2. #  define new not_the_cpp_new
3. #  define voidcast(type, value) static_cast<type>(value)
4. #else
5. #  define voidcast(type, value) (value)",Not Useful
/*Chunk information*/,"-1. #define png_vpAg PNG_U32(118, 112, 65, 103)

/*Chunk information*/

1. #define PNG_INFO_tEXt 0x10000000U
2. #define PNG_INFO_iTXt 0x20000000U
3. #define PNG_INFO_zTXt 0x40000000U
4. #define PNG_INFO_sTER 0x01000000U
5. #define PNG_INFO_vpAg 0x02000000U
6. #define ABSENT  0
7. #define START   1
8. #define END     2
9. static struct
10. {",Not Useful
/*must be [0]*/,"-2. } chunk_info[] = {

/*must be [0]*/

1.    { ""PLTE"", PNG_INFO_PLTE, png_PLTE, 0, 0, ABSENT, 0 },",Not Useful
/*READ_USER_CHUNKS_SUPPORTED*/,"
#if defined(PNG_READ_USER_CHUNKS_SUPPORTED) ||\



/*READ_USER_CHUNKS_SUPPORTED*/

1.    defined(PNG_SAVE_UNKNOWN_CHUNKS_SUPPORTED)
2. #if PNG_LIBPNG_VER < 10500",Not Useful
/*impossible*/,"-2.          if (chunk < 0) switch (d->keep)
-1.          {

/*impossible*/

1.             case PNG_HANDLE_CHUNK_AS_DEFAULT:
2.             case PNG_HANDLE_CHUNK_NEVER:
3.                fprintf(stderr, ""%s(%s): %s: %s: unknown chunk saved\n"",
4.                   d->file, d->test, d->keep ? ""discard"" : ""default"",
5.                   unknown[num_unknown].name);
6.                ++(d->error_count);
7.                break;
8.             case PNG_HANDLE_CHUNK_IF_SAFE:
9.                if (!ancillaryb(unknown[num_unknown].name))
10.                {",Not Useful
/*FALLTHROUGH*/,"-10.                break;
-9.             case PNG_HANDLE_CHUNK_IF_SAFE:
-8.                if (!ancillaryb(unknown[num_unknown].name))
-7.                {
-6.                   fprintf(stderr,
-5.                      ""%s(%s): if-safe: %s: unknown critical chunk saved\n"",
-4.                      d->file, d->test, unknown[num_unknown].name);
-3.                   ++(d->error_count);
-2.                   break;
-1.                }

/*FALLTHROUGH*/

1.             case PNG_HANDLE_CHUNK_ALWAYS:
2.                break;
3.          }
4.          else
5.             flags |= chunk_info[chunk].flag;
6.       }
7.    }
8.    return flags;
9. }",Not Useful
/*(safe)*/,"-10.                break;
-9.             case PNG_HANDLE_CHUNK_IF_SAFE:
-8.                if (!ancillaryb(unknown[num_unknown].name))
-7.                {
-6.                   fprintf(stderr,
-5.                      ""%s(%s): if-safe: %s: unknown critical chunk saved\n"",
-4.                      d->file, d->test, unknown[num_unknown].name);
-3.                   ++(d->error_count);
-2.                   break;
-1.                }

/*(safe)*/

1.             case PNG_HANDLE_CHUNK_ALWAYS:
2.                break;
3.          }
4.          else
5.             flags |= chunk_info[chunk].flag;
6.       }
7.    }
8.    return flags;
9. }",Not Useful
/*SAVE_UNKNOWN_CHUNKS*/,"-1. #if defined(PNG_READ_USER_CHUNKS_SUPPORTED) ||\
   defined(PNG_SAVE_UNKNOWN_CHUNKS_SUPPORTED)

/*SAVE_UNKNOWN_CHUNKS*/

1. #if PNG_LIBPNG_VER < 10500",Not Useful
/*READ_USER_CHUNKS*/,"
#if defined(PNG_READ_USER_CHUNKS_SUPPORTED) ||\



/*READ_USER_CHUNKS*/

1.    defined(PNG_SAVE_UNKNOWN_CHUNKS_SUPPORTED)
2. #if PNG_LIBPNG_VER < 10500",Not Useful
/*SAVE_UNKNOWN_CHUNKS*/,"-1. #if defined(PNG_READ_USER_CHUNKS_SUPPORTED) ||\
   defined(PNG_SAVE_UNKNOWN_CHUNKS_SUPPORTED)

/*SAVE_UNKNOWN_CHUNKS*/

1. #if PNG_LIBPNG_VER < 10500",Not Useful
/*chunk name*/,"-10.          else if (strcmp(equals+1, ""save"") == 0)
-9.             option = PNG_HANDLE_CHUNK_ALWAYS;
-8.          else
-7.          {
-6.             fprintf(stderr, ""%s(%s): %s: unrecognized chunk option\n"", d->file,
-5.                d->test, argv[i]);
-4.             display_exit(d);
-3.          }
-2.          switch (equals - argv[i])
-1.          {

/*chunk name*/

1.                chunk = find(argv[i]);
2.                if (chunk >= 0)
3.                {",Not Useful
/*1.7+ SAVE_UNKNOWN_CHUNKS*/,"-3. #                 if PNG_LIBPNG_VER >= 10700 &&\
-2.                      !defined(PNG_SAVE_UNKNOWN_CHUNKS_SUPPORTED)
-1.                      if (option < PNG_HANDLE_CHUNK_IF_SAFE)

/*1.7+ SAVE_UNKNOWN_CHUNKS*/

1.                   {
2.                      png_byte name[5];
3.                      memcpy(name, chunk_info[chunk].name, 5);
4.                      png_set_keep_unknown_chunks(d->png_ptr, option, name, 1);
5.                      chunk_info[chunk].keep = option;
6.                   }
7.                   continue;
8.                }
9.                break;",Not Useful
/*1.7+ SAVE_UNKNOWN_CHUNKS*/,"-3. #                 if PNG_LIBPNG_VER >= 10700 &&\
-2.                      !defined(PNG_SAVE_UNKNOWN_CHUNKS_SUPPORTED)
-1.                      if (option < PNG_HANDLE_CHUNK_IF_SAFE)

/*1.7+ SAVE_UNKNOWN_CHUNKS*/

1.                   {
2.                      png_byte name[5];
3.                      memcpy(name, chunk_info[chunk].name, 5);
4.                      png_set_keep_unknown_chunks(d->png_ptr, option, name, 1);
5.                      chunk_info[chunk].keep = option;
6.                   }
7.                   continue;
8.                }
9.                break;",Not Useful
/*all*/,"-10.  * Last changed in libpng 1.6.32 [August 24, 2017]
-9.  * Copyright (c) 2015,2017 Glenn Randers-Pehrson
-8.  * Written by John Cunningham Bowler
-7.  *
-6.  * This code is released under the libpng license.
-5.  * For conditions of distribution and use, see the disclaimer
-4.  * and license in png.h
-3.  *
-2.  * NOTES:
-1.  *   This is a C program that is intended to be linked against libpng.  It
 *   allows the libpng unknown handling code to be tested by interpreting

/*all*/

1.  *   arguments to save or discard combinations of chunks.  The program is
2.  *   currently just a minimal validation for the built-in libpng facilities.
3.  */
4. #include <stdlib.h>
5. #include <string.h>
6. #include <stdio.h>
7. #include <setjmp.h>",Not Useful
/*1.7+ SAVE_UNKNOWN_CHUNKS*/,"-3. #                 if PNG_LIBPNG_VER >= 10700 &&\
-2.                      !defined(PNG_SAVE_UNKNOWN_CHUNKS_SUPPORTED)
-1.                      if (option < PNG_HANDLE_CHUNK_IF_SAFE)

/*1.7+ SAVE_UNKNOWN_CHUNKS*/

1.                   {
2.                      png_byte name[5];
3.                      memcpy(name, chunk_info[chunk].name, 5);
4.                      png_set_keep_unknown_chunks(d->png_ptr, option, name, 1);
5.                      chunk_info[chunk].keep = option;
6.                   }
7.                   continue;
8.                }
9.                break;",Not Useful
/*unknown chunk*/,"
/* pngunknown.c - test the read side unknown chunk handling



/*unknown chunk*/

1.  *
2.  * Last changed in libpng 1.6.32 [August 24, 2017]
3.  * Copyright (c) 2015,2017 Glenn Randers-Pehrson
4.  * Written by John Cunningham Bowler
5.  *
6.  * This code is released under the libpng license.
7.  * For conditions of distribution and use, see the disclaimer
8.  * and license in png.h
9.  *
10.  * NOTES:",Not Useful
/*known chunk*/,"
/* pngunknown.c - test the read side unknown chunk handling



/*known chunk*/

1.  *
2.  * Last changed in libpng 1.6.32 [August 24, 2017]
3.  * Copyright (c) 2015,2017 Glenn Randers-Pehrson
4.  * Written by John Cunningham Bowler
5.  *
6.  * This code is released under the libpng license.
7.  * For conditions of distribution and use, see the disclaimer
8.  * and license in png.h
9.  *
10.  * NOTES:",Not Useful
/*allow use of d->error_return*/,"-10.       ""before IDAT"", set_callback);
-9.    check_handling(d, def, flags[0][2] | flags[0][3], flags[1][2], flags[1][3],
-8.       ""after IDAT"", set_callback);
-7. }
-6. static void
-5. perform_one_test_safe(FILE *fp, int argc, const char **argv,
-4.    png_uint_32 *default_flags, display *d, const char *test)
-3. {
-2.    if (setjmp(d->error_return) == 0)
-1.    {

/*allow use of d->error_return*/

1. #     ifdef PNG_SAVE_UNKNOWN_CHUNKS_SUPPORTED
2.          perform_one_test(fp, argc, argv, default_flags, d, 0);
3. #     endif
4. #     ifdef PNG_READ_USER_CHUNKS_SUPPORTED
5.          perform_one_test(fp, argc, argv, default_flags, d, 1);
6. #     endif",Not Useful
/*prevent use of d->error_return*/,"-6. #     ifdef PNG_SAVE_UNKNOWN_CHUNKS_SUPPORTED
-5.          perform_one_test(fp, argc, argv, default_flags, d, 0);
-4. #     endif
-3. #     ifdef PNG_READ_USER_CHUNKS_SUPPORTED
-2.          perform_one_test(fp, argc, argv, default_flags, d, 1);
-1. #     endif

/*prevent use of d->error_return*/

1.    }
2. }
3. static const char *standard_tests[] =
4. {
5.  ""discard"", ""default=discard"", 0,
6.  ""save"", ""default=save"", 0,
7.  ""if-safe"", ""default=if-safe"", 0,
8.  ""vpAg"", ""vpAg=if-safe"", 0,
9.  ""sTER"", ""sTER=if-safe"", 0,
10.  ""IDAT"", ""default=discard"", ""IDAT=save"", 0,",Not Useful
"/*valid,unknown{before,after}*/","-10. {
-9.    fprintf(stderr, ""pngunknown: %s: usage:\n %s [--strict] ""
-8.       ""--default|{(CHNK|default|all)=(default|discard|if-safe|save)} ""
-7.       ""testfile.png\n"", reason, program);
-6.    exit(99);
-5. }
-4. int
-3. main(int argc, const char **argv)
-2. {
-1.    FILE *fp;

/*valid,unknown{before,after}*/

1.    int strict = 0, default_tests = 0;
2.    const char *count_argv = ""default=save"";
3.    const char *touch_file = NULL;
4.    display d;
5.    init_display(&d, argv[0]);
6.    while (++argv, --argc > 0)
7.    {
8.       if (strcmp(*argv, ""--strict"") == 0)
9.          strict = 1;
10.       else if (strcmp(*argv, ""--default"") == 0)",Not Useful
/*Now find what the various supplied options cause to change:*/,"-10. #     ifdef PNG_SAVE_UNKNOWN_CHUNKS_SUPPORTED
-9.          0
-8. #     else
-7.          1
-6. #     endif
-5.       ) != PNG_HANDLE_CHUNK_ALWAYS)
-4.    {
-3.       fprintf(stderr, ""%s: %s: internal error\n"", d.program, d.file);
-2.       exit(99);
-1.    }

/*Now find what the various supplied options cause to change:*/

1.    if (!default_tests)
2.    {",Not Useful
/*!(READ_USER_CHUNKS || SAVE_UNKNOWN_CHUNKS)*/,"-10.          else
-9.          {
-8.             fprintf(stderr, ""%s: open failed\n"", touch_file);
-7.             exit(99);
-6.          }
-5.       }
-4.       return 0;
-3.    }
-2.    return 1;
-1. }

/*!(READ_USER_CHUNKS || SAVE_UNKNOWN_CHUNKS)*/

1. int
2. main(void)
3. {
4.    fprintf(stderr,
5.       "" test ignored: no support to find out about unknown chunks\n"");",Not Useful
/*So the test is skipped:*/,"-5. int
-4. main(void)
-3. {
-2.    fprintf(stderr,
-1.       "" test ignored: no support to find out about unknown chunks\n"");

/*So the test is skipped:*/

1.    return SKIP;
2. }",Not Useful
/*READ_USER_CHUNKS || SAVE_UNKNOWN_CHUNKS*/,"-10.          else
-9.          {
-8.             fprintf(stderr, ""%s: open failed\n"", touch_file);
-7.             exit(99);
-6.          }
-5.       }
-4.       return 0;
-3.    }
-2.    return 1;
-1. }

/*READ_USER_CHUNKS || SAVE_UNKNOWN_CHUNKS*/

1. int
2. main(void)
3. {
4.    fprintf(stderr,
5.       "" test ignored: no support to find out about unknown chunks\n"");",Not Useful
/*So the test is skipped:*/,"-5. int
-4. main(void)
-3. {
-2.    fprintf(stderr,
-1.       "" test ignored: no support to find out about unknown chunks\n"");

/*So the test is skipped:*/

1.    return SKIP;
2. }",Not Useful
/*USER_MEM*/,"-4. PNG_FUNCTION(png_structp,PNGAPI
-3. png_create_read_struct,(png_const_charp user_png_ver, png_voidp error_ptr,
-2.     png_error_ptr error_fn, png_error_ptr warn_fn),PNG_ALLOCATED)
-1. {
#ifndef PNG_USER_MEM_SUPPORTED

/*USER_MEM*/

1.    png_structp png_ptr = png_create_png_struct(user_png_ver, error_ptr,
2.         error_fn, warn_fn, NULL, NULL, NULL);
3. #else
4.    return png_create_read_struct_2(user_png_ver, error_ptr, error_fn,
5.         warn_fn, NULL, NULL, NULL);
6. }",Not Useful
/*It has been consumed*/,"-10.       else if (chunk_name == png_IEND)
-9.          png_handle_IEND(png_ptr, info_ptr, length);
-8. #ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED
-7.       else if ((keep = png_chunk_unknown_handling(png_ptr, chunk_name)) != 0)
-6.       {
-5.          png_handle_unknown(png_ptr, info_ptr, length, keep);
-4.          if (chunk_name == png_PLTE)
-3.             png_ptr->mode |= PNG_HAVE_PLTE;
-2.          else if (chunk_name == png_IDAT)
-1.          {

/*It has been consumed*/

1.             break;
2.          }
3.       }
4. #endif
5.       else if (chunk_name == png_PLTE)
6.          png_handle_PLTE(png_ptr, info_ptr, length);
7.       else if (chunk_name == png_IDAT)
8.       {
9.          png_ptr->idat_size = length;
10.          break;",Not Useful
/*SEQUENTIAL_READ*/,"
#     ifdef PNG_SEQUENTIAL_READ_SUPPORTED



/*SEQUENTIAL_READ*/

1.          png_ptr->IDAT_read_size = PNG_IDAT_READ_SIZE;
2. #     endif
3. #     ifdef PNG_BENIGN_READ_ERRORS_SUPPORTED
4.          png_ptr->flags |= PNG_FLAG_BENIGN_ERRORS_WARN;",Not Useful
/*SEQUENTIAL_READ*/,"
#     ifdef PNG_SEQUENTIAL_READ_SUPPORTED



/*SEQUENTIAL_READ*/

1.          png_ptr->IDAT_read_size = PNG_IDAT_READ_SIZE;
2. #     endif
3. #     ifdef PNG_BENIGN_READ_ERRORS_SUPPORTED
4.          png_ptr->flags |= PNG_FLAG_BENIGN_ERRORS_WARN;",Not Useful
/*MNG_FEATURES*/,"-1. #ifdef PNG_SEQUENTIAL_READ_SUPPORTED
#ifdef PNG_MNG_FEATURES_SUPPORTED

/*MNG_FEATURES*/

 ",Not Useful
/*WARNINGS*/,"-1. #        if PNG_RELEASE_BUILD
            png_ptr->flags |= PNG_FLAG_APP_WARNINGS_WARN;

/*WARNINGS*/

1. #        endif
2. #     endif",Not Useful
/*row*/,"-8. void PNGAPI
-7. png_read_update_info(png_structrp png_ptr, png_inforp info_ptr)
-6. {
-5.    png_debug(1, ""in png_read_update_info"");
-4.    if (png_ptr != NULL)
-3.    {
-2.       if ((png_ptr->flags & PNG_FLAG_ROW_INIT) == 0)
-1.       {
         png_read_start_row(png_ptr);

/*row*/

1. #        ifdef PNG_READ_TRANSFORMS_SUPPORTED
2.             png_read_transform_info(png_ptr, info_ptr);
3. #        else
4.             PNG_UNUSED(info_ptr)
5. #        endif
6.       }",Not Useful
/*SEQUENTIAL_READ*/,"
#     ifdef PNG_SEQUENTIAL_READ_SUPPORTED



/*SEQUENTIAL_READ*/

1.          png_ptr->IDAT_read_size = PNG_IDAT_READ_SIZE;
2. #     endif
3. #     ifdef PNG_BENIGN_READ_ERRORS_SUPPORTED
4.          png_ptr->flags |= PNG_FLAG_BENIGN_ERRORS_WARN;",Not Useful
/*SEQUENTIAL_READ*/,"
#     ifdef PNG_SEQUENTIAL_READ_SUPPORTED



/*SEQUENTIAL_READ*/

1.          png_ptr->IDAT_read_size = PNG_IDAT_READ_SIZE;
2. #     endif
3. #     ifdef PNG_BENIGN_READ_ERRORS_SUPPORTED
4.          png_ptr->flags |= PNG_FLAG_BENIGN_ERRORS_WARN;",Not Useful
/*SEQUENTIAL_READ*/,"
#     ifdef PNG_SEQUENTIAL_READ_SUPPORTED



/*SEQUENTIAL_READ*/

1.          png_ptr->IDAT_read_size = PNG_IDAT_READ_SIZE;
2. #     endif
3. #     ifdef PNG_BENIGN_READ_ERRORS_SUPPORTED
4.          png_ptr->flags |= PNG_FLAG_BENIGN_ERRORS_WARN;",Not Useful
/*SEQUENTIAL_READ*/,"
#     ifdef PNG_SEQUENTIAL_READ_SUPPORTED



/*SEQUENTIAL_READ*/

1.          png_ptr->IDAT_read_size = PNG_IDAT_READ_SIZE;
2. #     endif
3. #     ifdef PNG_BENIGN_READ_ERRORS_SUPPORTED
4.          png_ptr->flags |= PNG_FLAG_BENIGN_ERRORS_WARN;",Not Useful
/*SEQUENTIAL_READ*/,"
#     ifdef PNG_SEQUENTIAL_READ_SUPPORTED



/*SEQUENTIAL_READ*/

1.          png_ptr->IDAT_read_size = PNG_IDAT_READ_SIZE;
2. #     endif
3. #     ifdef PNG_BENIGN_READ_ERRORS_SUPPORTED
4.          png_ptr->flags |= PNG_FLAG_BENIGN_ERRORS_WARN;",Not Useful
/*Local variables:*/,"-5.    png_imagep image;
-4.    png_voidp  buffer;
-3.    png_int_32 row_stride;
-2.    png_voidp  colormap;
-1.    png_const_colorp background;

/*Local variables:*/

1.    png_voidp       local_row;
2.    png_voidp       first_row;",Not Useful
/*warn*/,"-2. PNG_FUNCTION(png_structp,PNGAPI
-1. png_create_read_struct,(png_const_charp user_png_ver, png_voidp error_ptr,
    png_error_ptr error_fn, png_error_ptr warn_fn),PNG_ALLOCATED)

/*warn*/

1. {
2. #ifndef PNG_USER_MEM_SUPPORTED
3.    png_structp png_ptr = png_create_png_struct(user_png_ver, error_ptr,
4.         error_fn, warn_fn, NULL, NULL, NULL);
5. #else
6.    return png_create_read_struct_2(user_png_ver, error_ptr, error_fn,
7.         warn_fn, NULL, NULL, NULL);
8. }
9. /* Alternate create PNG structure for reading, and allocate any memory
10.  * needed.",Not Useful
/*Clean up: just the opened file.*/,"-10.       {
-9.          FILE *fp = fopen(file_name, ""rb"");
-8.          if (fp != NULL)
-7.          {
-6.             if (png_image_read_init(image) != 0)
-5.             {
-4.                image->opaque->png_ptr->io_ptr = fp;
-3.                image->opaque->owned_file = 1;
-2.                return png_safe_execute(image, png_image_read_header, image);
-1.             }

/*Clean up: just the opened file.*/

1.             (void)fclose(fp);
2.          }
3.          else
4.             return png_image_error(image, strerror(errno));
5.       }
6.       else
7.          return png_image_error(image,
8.              ""png_image_begin_read_from_file: invalid argument"");
9.    }
10.    else if (image != NULL)",Not Useful
/*STDIO*/,"-10.  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
-9.  *
-8.  * This code is released under the libpng license.
-7.  * For conditions of distribution and use, see the disclaimer
-6.  * and license in png.h
-5.  *
-4.  * This file contains routines that an application calls directly to
-3.  * read a PNG file or stream.
-2.  */
-1. #include ""pngpriv.h""
#if defined(PNG_SIMPLIFIED_READ_SUPPORTED) && defined(PNG_STDIO_SUPPORTED)

/*STDIO*/

1. #  include <errno.h>
2. #endif
3. #ifdef PNG_READ_SUPPORTED",Not Useful
/*bKGD*/,"-10.          }
-9.       }
-8. #endif
-7.       else if (chunk_name == png_PLTE)
-6.          png_handle_PLTE(png_ptr, info_ptr, length);
-5.       else if (chunk_name == png_IDAT)
-4.       {
-3.          png_ptr->idat_size = length;
-2.          break;
-1.       }
#ifdef PNG_READ_bKGD_SUPPORTED

/*bKGD*/

1.       else if (chunk_name == png_bKGD)
2.          png_handle_bKGD(png_ptr, info_ptr, length);
3. #endif
4. #ifdef PNG_READ_cHRM_SUPPORTED
5.       else if (chunk_name == png_cHRM)
6.          png_handle_cHRM(png_ptr, info_ptr, length);
7. #endif
8. #ifdef PNG_READ_eXIf_SUPPORTED
9.       else if (chunk_name == png_eXIf)
10.          png_handle_eXIf(png_ptr, info_ptr, length);",Not Useful
/*cHRM*/,"-10.          png_handle_PLTE(png_ptr, info_ptr, length);
-9.       else if (chunk_name == png_IDAT)
-8.       {
-7.          png_ptr->idat_size = length;
-6.          break;
-5.       }
-4. #ifdef PNG_READ_bKGD_SUPPORTED
-3.       else if (chunk_name == png_bKGD)
-2.          png_handle_bKGD(png_ptr, info_ptr, length);
-1. #endif
#ifdef PNG_READ_cHRM_SUPPORTED

/*cHRM*/

1.       else if (chunk_name == png_cHRM)
2.          png_handle_cHRM(png_ptr, info_ptr, length);
3. #endif
4. #ifdef PNG_READ_eXIf_SUPPORTED
5.       else if (chunk_name == png_eXIf)
6.          png_handle_eXIf(png_ptr, info_ptr, length);
7. #endif
8. #ifdef PNG_READ_gAMA_SUPPORTED
9.       else if (chunk_name == png_gAMA)
10.          png_handle_gAMA(png_ptr, info_ptr, length);",Not Useful
/*gAMA*/,"-10.          png_handle_bKGD(png_ptr, info_ptr, length);
-9. #endif
-8. #ifdef PNG_READ_cHRM_SUPPORTED
-7.       else if (chunk_name == png_cHRM)
-6.          png_handle_cHRM(png_ptr, info_ptr, length);
-5. #endif
-4. #ifdef PNG_READ_eXIf_SUPPORTED
-3.       else if (chunk_name == png_eXIf)
-2.          png_handle_eXIf(png_ptr, info_ptr, length);
-1. #endif
#ifdef PNG_READ_gAMA_SUPPORTED

/*gAMA*/

1.       else if (chunk_name == png_gAMA)
2.          png_handle_gAMA(png_ptr, info_ptr, length);
3. #endif
4. #ifdef PNG_READ_hIST_SUPPORTED
5.       else if (chunk_name == png_hIST)
6.          png_handle_hIST(png_ptr, info_ptr, length);
7. #endif
8. #ifdef PNG_READ_oFFs_SUPPORTED
9.       else if (chunk_name == png_oFFs)
10.          png_handle_oFFs(png_ptr, info_ptr, length);",Not Useful
/*iCCP*/,"-10.          png_handle_pHYs(png_ptr, info_ptr, length);
-9. #endif
-8. #ifdef PNG_READ_sBIT_SUPPORTED
-7.       else if (chunk_name == png_sBIT)
-6.          png_handle_sBIT(png_ptr, info_ptr, length);
-5. #endif
-4. #ifdef PNG_READ_sRGB_SUPPORTED
-3.       else if (chunk_name == png_sRGB)
-2.          png_handle_sRGB(png_ptr, info_ptr, length);
-1. #endif
#ifdef PNG_READ_iCCP_SUPPORTED

/*iCCP*/

1.       else if (chunk_name == png_iCCP)
2.          png_handle_iCCP(png_ptr, info_ptr, length);
3. #endif
4. #ifdef PNG_READ_sPLT_SUPPORTED
5.       else if (chunk_name == png_sPLT)
6.          png_handle_sPLT(png_ptr, info_ptr, length);
7. #endif
8. #ifdef PNG_READ_tEXt_SUPPORTED
9.       else if (chunk_name == png_tEXt)
10.          png_handle_tEXt(png_ptr, info_ptr, length);",Not Useful
/*sBIT*/,"-10.          png_handle_pCAL(png_ptr, info_ptr, length);
-9. #endif
-8. #ifdef PNG_READ_sCAL_SUPPORTED
-7.       else if (chunk_name == png_sCAL)
-6.          png_handle_sCAL(png_ptr, info_ptr, length);
-5. #endif
-4. #ifdef PNG_READ_pHYs_SUPPORTED
-3.       else if (chunk_name == png_pHYs)
-2.          png_handle_pHYs(png_ptr, info_ptr, length);
-1. #endif
#ifdef PNG_READ_sBIT_SUPPORTED

/*sBIT*/

1.       else if (chunk_name == png_sBIT)
2.          png_handle_sBIT(png_ptr, info_ptr, length);
3. #endif
4. #ifdef PNG_READ_sRGB_SUPPORTED
5.       else if (chunk_name == png_sRGB)
6.          png_handle_sRGB(png_ptr, info_ptr, length);
7. #endif
8. #ifdef PNG_READ_iCCP_SUPPORTED
9.       else if (chunk_name == png_iCCP)
10.          png_handle_iCCP(png_ptr, info_ptr, length);",Not Useful
/*SAFE*/,"-1.        png_set_keep_unknown_chunks(png_ptr, PNG_HANDLE_CHUNK_AS_DEFAULT,

/*SAFE*/

1.    }
2. }
3. #  define PNG_SKIP_CHUNKS(p) png_image_skip_unused_chunks(p)
4. #else
5. #  define PNG_SKIP_CHUNKS(p) ((void)0)",Not Useful
/*HANDLE_AS_UNKNOWN*/,"-10.  * changed in v0.90 to allow reading a file that already has the magic
-9.  * bytes read from the stream.  You can tell libpng how many bytes have
-8.  * been read from the beginning of the stream (up to the maximum of 8)
-7.  * via png_set_sig_bytes(), and we will only check the remaining bytes
-6.  * here.  The application can then have access to the signature bytes we
-5.  * read if it is determined that this isn't a valid PNG file.
-4.  */
-3. void PNGAPI
-2. png_read_info(png_structrp png_ptr, png_inforp info_ptr)
-1. {
#ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED

/*HANDLE_AS_UNKNOWN*/

1.    int keep;
2. #endif
3.    png_debug(1, ""in png_read_info"");
4.    if (png_ptr == NULL || info_ptr == NULL)
5.       return;",Not Useful
/*FALLTHROUGH*/,"-4.          switch (PNG_IMAGE_SAMPLE_CHANNELS(image->format))
-3.          {
-2.             case 4:
-1.                entry[afirst ? 0 : 3] = (png_uint_16)alpha;

/*FALLTHROUGH*/

1.             case 3:
2.                if (alpha < 65535)
3.                {
4.                   if (alpha > 0)
5.                   {
6.                      blue = (blue * alpha + 32767U)/65535U;
7.                      green = (green * alpha + 32767U)/65535U;
8.                      red = (red * alpha + 32767U)/65535U;
9.                   }
10.                   else",Not Useful
/*FALLTHROUGH*/,"-4.          switch (PNG_IMAGE_SAMPLE_CHANNELS(image->format))
-3.          {
-2.             case 4:
-1.                entry[afirst ? 0 : 3] = (png_uint_16)alpha;

/*FALLTHROUGH*/

1.             case 3:
2.                if (alpha < 65535)
3.                {
4.                   if (alpha > 0)
5.                   {
6.                      blue = (blue * alpha + 32767U)/65535U;
7.                      green = (green * alpha + 32767U)/65535U;
8.                      red = (red * alpha + 32767U)/65535U;
9.                   }
10.                   else",Not Useful
/*FALLTHROUGH*/,"-4.          switch (PNG_IMAGE_SAMPLE_CHANNELS(image->format))
-3.          {
-2.             case 4:
-1.                entry[afirst ? 0 : 3] = (png_uint_16)alpha;

/*FALLTHROUGH*/

1.             case 3:
2.                if (alpha < 65535)
3.                {
4.                   if (alpha > 0)
5.                   {
6.                      blue = (blue * alpha + 32767U)/65535U;
7.                      green = (green * alpha + 32767U)/65535U;
8.                      red = (red * alpha + 32767U)/65535U;
9.                   }
10.                   else",Not Useful
/*FALLTHROUGH*/,"-4.          switch (PNG_IMAGE_SAMPLE_CHANNELS(image->format))
-3.          {
-2.             case 4:
-1.                entry[afirst ? 0 : 3] = (png_uint_16)alpha;

/*FALLTHROUGH*/

1.             case 3:
2.                if (alpha < 65535)
3.                {
4.                   if (alpha > 0)
5.                   {
6.                      blue = (blue * alpha + 32767U)/65535U;
7.                      green = (green * alpha + 32767U)/65535U;
8.                      red = (red * alpha + 32767U)/65535U;
9.                   }
10.                   else",Not Useful
/*unused*/,"-2. #ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED
-1. static void
png_image_skip_unused_chunks(png_structrp png_ptr)

/*unused*/

1. {
2.    /* Prepare the reader to ignore all recognized chunks whose data will not
3.     * be used, i.e., all chunks recognized by libpng except for those
4.     * involved in basic image reading:
5.     *
6.     *    IHDR, PLTE, IDAT, IEND
7.     *
8.     * Or image data handling:
9.     *
10.     *    tRNS, bKGD, gAMA, cHRM, sRGB, [iCCP] and sBIT.",Not Useful
/*need_expand*/,"-1.                      png_set_background_fixed(png_ptr, &c,

/*need_expand*/

 ",Not Useful
/*unused*/,"-2. #ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED
-1. static void
png_image_skip_unused_chunks(png_structrp png_ptr)

/*unused*/

1. {
2.    /* Prepare the reader to ignore all recognized chunks whose data will not
3.     * be used, i.e., all chunks recognized by libpng except for those
4.     * involved in basic image reading:
5.     *
6.     *    IHDR, PLTE, IDAT, IEND
7.     *
8.     * Or image data handling:
9.     *
10.     *    tRNS, bKGD, gAMA, cHRM, sRGB, [iCCP] and sBIT.",Not Useful
/*need_expand*/,"-1.                      png_set_background_fixed(png_ptr, &c,

/*need_expand*/

 ",Not Useful
/*now P_FILE*/,"-1.                      gray = PNG_DIV257(png_gamma_16bit_correct(gray,

/*now P_FILE*/

 ",Not Useful
/*unused*/,"-2. #ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED
-1. static void
png_image_skip_unused_chunks(png_structrp png_ptr)

/*unused*/

1. {
2.    /* Prepare the reader to ignore all recognized chunks whose data will not
3.     * be used, i.e., all chunks recognized by libpng except for those
4.     * involved in basic image reading:
5.     *
6.     *    IHDR, PLTE, IDAT, IEND
7.     *
8.     * Or image data handling:
9.     *
10.     *    tRNS, bKGD, gAMA, cHRM, sRGB, [iCCP] and sBIT.",Not Useful
/*unused*/,"-2. #ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED
-1. static void
png_image_skip_unused_chunks(png_structrp png_ptr)

/*unused*/

1. {
2.    /* Prepare the reader to ignore all recognized chunks whose data will not
3.     * be used, i.e., all chunks recognized by libpng except for those
4.     * involved in basic image reading:
5.     *
6.     *    IHDR, PLTE, IDAT, IEND
7.     *
8.     * Or image data handling:
9.     *
10.     *    tRNS, bKGD, gAMA, cHRM, sRGB, [iCCP] and sBIT.",Not Useful
/*unused*/,"-2. #ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED
-1. static void
png_image_skip_unused_chunks(png_structrp png_ptr)

/*unused*/

1. {
2.    /* Prepare the reader to ignore all recognized chunks whose data will not
3.     * be used, i.e., all chunks recognized by libpng except for those
4.     * involved in basic image reading:
5.     *
6.     *    IHDR, PLTE, IDAT, IEND
7.     *
8.     * Or image data handling:
9.     *
10.     *    tRNS, bKGD, gAMA, cHRM, sRGB, [iCCP] and sBIT.",Not Useful
/*need_expand*/,"-1.                      png_set_background_fixed(png_ptr, &c,

/*need_expand*/

 ",Not Useful
/*unused*/,"-2. #ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED
-1. static void
png_image_skip_unused_chunks(png_structrp png_ptr)

/*unused*/

1. {
2.    /* Prepare the reader to ignore all recognized chunks whose data will not
3.     * be used, i.e., all chunks recognized by libpng except for those
4.     * involved in basic image reading:
5.     *
6.     *    IHDR, PLTE, IDAT, IEND
7.     *
8.     * Or image data handling:
9.     *
10.     *    tRNS, bKGD, gAMA, cHRM, sRGB, [iCCP] and sBIT.",Not Useful
/*unused*/,"-2. #ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED
-1. static void
png_image_skip_unused_chunks(png_structrp png_ptr)

/*unused*/

1. {
2.    /* Prepare the reader to ignore all recognized chunks whose data will not
3.     * be used, i.e., all chunks recognized by libpng except for those
4.     * involved in basic image reading:
5.     *
6.     *    IHDR, PLTE, IDAT, IEND
7.     *
8.     * Or image data handling:
9.     *
10.     *    tRNS, bKGD, gAMA, cHRM, sRGB, [iCCP] and sBIT.",Not Useful
/*unused*/,"-2. #ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED
-1. static void
png_image_skip_unused_chunks(png_structrp png_ptr)

/*unused*/

1. {
2.    /* Prepare the reader to ignore all recognized chunks whose data will not
3.     * be used, i.e., all chunks recognized by libpng except for those
4.     * involved in basic image reading:
5.     *
6.     *    IHDR, PLTE, IDAT, IEND
7.     *
8.     * Or image data handling:
9.     *
10.     *    tRNS, bKGD, gAMA, cHRM, sRGB, [iCCP] and sBIT.",Not Useful
/*need_expand*/,"-1.                      png_set_background_fixed(png_ptr, &c,

/*need_expand*/

 ",Not Useful
/*8-bit*/,"-9. #ifdef PNG_SIMPLIFIED_READ_SUPPORTED

/*8-bit*/

 ",Not Useful
/*FALLTHROUGH*/,"-4.          switch (PNG_IMAGE_SAMPLE_CHANNELS(image->format))
-3.          {
-2.             case 4:
-1.                entry[afirst ? 0 : 3] = (png_uint_16)alpha;

/*FALLTHROUGH*/

1.             case 3:
2.                if (alpha < 65535)
3.                {
4.                   if (alpha > 0)
5.                   {
6.                      blue = (blue * alpha + 32767U)/65535U;
7.                      green = (green * alpha + 32767U)/65535U;
8.                      red = (red * alpha + 32767U)/65535U;
9.                   }
10.                   else",Not Useful
/*ok*/,"-10. #ifdef PNG_READ_GAMMA_SUPPORTED
-9.    png_destroy_gamma_table(png_ptr);
-8. #endif
-7.    png_free(png_ptr, png_ptr->big_row_buf);
-6.    png_ptr->big_row_buf = NULL;
-5.    png_free(png_ptr, png_ptr->big_prev_row);
-4.    png_ptr->big_prev_row = NULL;
-3.    png_free(png_ptr, png_ptr->read_buffer);
-2.    png_ptr->read_buffer = NULL;
-1. #ifdef PNG_READ_QUANTIZE_SUPPORTED
   png_free(png_ptr, png_ptr->palette_lookup);

/*ok*/

1.    png_ptr->palette_lookup = NULL;
2.    png_free(png_ptr, png_ptr->quantize_index);
3.    png_ptr->quantize_index = NULL;
4. #endif
5.    if ((png_ptr->free_me & PNG_FREE_PLTE) != 0)
6.    {
7.       png_zfree(png_ptr, png_ptr->palette);
8.       png_ptr->palette = NULL;
9.    }
10.    png_ptr->free_me &= ~PNG_FREE_PLTE;",Not Useful
/*opaque*/,"-3. static int
-2. png_image_read_init(png_imagep image)
-1. {
   if (image->opaque == NULL)

/*opaque*/

1.    {
2.       png_structp png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING, image,
3.           png_safe_error, png_safe_warning);",Not Useful
/*As a flag*/,"-10. }
-9. static int
-8. png_image_read_colormapped(png_voidp argument)
-7. {
-6.    png_image_read_control *display = png_voidcast(png_image_read_control*,
-5.        argument);
-4.    png_imagep image = display->image;
-3.    png_controlp control = image->opaque;
-2.    png_structrp png_ptr = control->png_ptr;
-1.    png_inforp info_ptr = control->info_ptr;

/*As a flag*/

1.    PNG_SKIP_CHUNKS(png_ptr);",Not Useful
/*216 + 1 + 27*/,"-3.          if (info_ptr->color_type == PNG_COLOR_TYPE_RGB_ALPHA &&
-2.             info_ptr->bit_depth == 8 &&
-1.             png_ptr->screen_gamma == PNG_GAMMA_sRGB &&

/*216 + 1 + 27*/

1.             break;
2.          goto bad_output;
3.       default:
4.       bad_output:
5.          png_error(png_ptr, ""bad color-map processing (internal error)"");
6.    }",Not Useful
/*maybe*/,"-9.                      }
-8.                      row += display->row_bytes;
-7.                   }
-6.                }
-5.             }
-4.          }
-3.          break;
-2.       case 16:
-1.          /* 16-bit linear with pre-multiplied alpha; the pre-multiplication must
          * still be done and, maybe, the alpha channel removed.  This code also

/*maybe*/

1.           * handles the alpha-first option.
2.           */
3.          {
4.             png_uint_16p first_row = png_voidcast(png_uint_16p,
5.                 display->first_row);",Not Useful
/*unused*/,"-2. #ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED
-1. static void
png_image_skip_unused_chunks(png_structrp png_ptr)

/*unused*/

1. {
2.    /* Prepare the reader to ignore all recognized chunks whose data will not
3.     * be used, i.e., all chunks recognized by libpng except for those
4.     * involved in basic image reading:
5.     *
6.     *    IHDR, PLTE, IDAT, IEND
7.     *
8.     * Or image data handling:
9.     *
10.     *    tRNS, bKGD, gAMA, cHRM, sRGB, [iCCP] and sBIT.",Not Useful
/*need_expand*/,"-1.                      png_set_background_fixed(png_ptr, &c,

/*need_expand*/

 ",Not Useful
/*opaque filler*/,"-6.          {

/*opaque filler*/

1.             int where;
2.             if (linear != 0)
3.                filler = 65535;
4.             else
5.                filler = 255;
6. #ifdef PNG_FORMAT_AFIRST_SUPPORTED
7.             if ((format & PNG_FORMAT_FLAG_AFIRST) != 0)
8.             {
9.                where = PNG_FILLER_BEFORE;
10.                change &= ~PNG_FORMAT_FLAG_AFIRST;",Not Useful
/*SAFE*/,"-1.        png_set_keep_unknown_chunks(png_ptr, PNG_HANDLE_CHUNK_AS_DEFAULT,

/*SAFE*/

1.    }
2. }
3. #  define PNG_SKIP_CHUNKS(p) png_image_skip_unused_chunks(p)
4. #else
5. #  define PNG_SKIP_CHUNKS(p) ((void)0)",Not Useful
/*SIMPLIFIED_READ*/,"-10.  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
-9.  *
-8.  * This code is released under the libpng license.
-7.  * For conditions of distribution and use, see the disclaimer
-6.  * and license in png.h
-5.  *
-4.  * This file contains routines that an application calls directly to
-3.  * read a PNG file or stream.
-2.  */
-1. #include ""pngpriv.h""
#if defined(PNG_SIMPLIFIED_READ_SUPPORTED) && defined(PNG_STDIO_SUPPORTED)

/*SIMPLIFIED_READ*/

1. #  include <errno.h>
2. #endif
3. #ifdef PNG_READ_SUPPORTED",Not Useful
/*PRIVATE*/,"-10.  * This file provides a location for all error handling.  Users who
-9.  * need special error handling are expected to write replacement functions
-8.  * and use png_set_error_fn() to use those functions.  See the instructions
-7.  * at each function.
-6.  */
-5. #include ""pngpriv.h""
-4. #if defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED)
-3. static PNG_FUNCTION(void, png_default_error,PNGARG((png_const_structrp png_ptr,
-2.     png_const_charp error_message)),PNG_NORETURN);
-1. #ifdef PNG_WARNINGS_SUPPORTED

/*PRIVATE*/

1. png_default_warning PNGARG((png_const_structrp png_ptr,
2.     png_const_charp warning_message));",Not Useful
/*WARNINGS*/,"-10.  *
-9.  * This file provides a location for all error handling.  Users who
-8.  * need special error handling are expected to write replacement functions
-7.  * and use png_set_error_fn() to use those functions.  See the instructions
-6.  * at each function.
-5.  */
-4. #include ""pngpriv.h""
-3. #if defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED)
-2. static PNG_FUNCTION(void, png_default_error,PNGARG((png_const_structrp png_ptr,
-1.     png_const_charp error_message)),PNG_NORETURN);
#ifdef PNG_WARNINGS_SUPPORTED

/*WARNINGS*/

 ",Not Useful
/*ERROR_TEXT*/,"
#ifdef PNG_ERROR_TEXT_SUPPORTED



/*ERROR_TEXT*/

1. PNG_FUNCTION(void,PNGAPI
2. png_error,(png_const_structrp png_ptr, png_const_charp error_message),
3.     PNG_NORETURN)
4. {
5. #ifdef PNG_ERROR_NUMBERS_SUPPORTED
6.    char msg[16];
7.    if (png_ptr != NULL)
8.    {
9.       if ((png_ptr->flags &
10.          (PNG_FLAG_STRIP_ERROR_NUMBERS|PNG_FLAG_STRIP_ERROR_TEXT)) != 0)",Not Useful
/*digit output (for the fixed point format)*/,"-6. png_charp
-5. png_format_number(png_const_charp start, png_charp end, int format,
-4.     png_alloc_size_t number)
-3. {

/*digit output (for the fixed point format)*/

1.    *--end = '\0';",Not Useful
/*Expects at least 2 digits.*/,"-9.             mincount = 5;
-8.             if (output != 0 || number % 10 != 0)
-7.             {
-6.                *--end = digits[number % 10];
-5.                output = 1;
-4.             }
-3.             number /= 10;
-2.             break;
-1.          case PNG_NUMBER_FORMAT_02u:

/*Expects at least 2 digits.*/

1.             mincount = 2;",Not Useful
/*FALLTHROUGH*/,"-1.             mincount = 2;

/*FALLTHROUGH*/

1.          case PNG_NUMBER_FORMAT_u:
2.             *--end = digits[number % 10];
3.             number /= 10;
4.             break;
5.          case PNG_NUMBER_FORMAT_02x:",Not Useful
/*FALLTHROUGH*/,"-1.             mincount = 2;

/*FALLTHROUGH*/

1.          case PNG_NUMBER_FORMAT_u:
2.             *--end = digits[number % 10];
3.             number /= 10;
4.             break;
5.          case PNG_NUMBER_FORMAT_02x:",Not Useful
/*Float a fixed number here:*/,"-1.       ++count;

/*Float a fixed number here:*/

1.       if ((format == PNG_NUMBER_FORMAT_fixed) && (count == 5) && (end > start))
2.       {",Not Useful
/*Consume the '@'*/,"-2.       if (p != NULL && *message == '@' && message[1] != '\0')
-1.       {

/*Consume the '@'*/

1.          static const char valid_parameters[] = ""123456789"";
2.          int parameter = 0;",Not Useful
/*WARNINGS*/,"-10.  *
-9.  * This file provides a location for all error handling.  Users who
-8.  * need special error handling are expected to write replacement functions
-7.  * and use png_set_error_fn() to use those functions.  See the instructions
-6.  * at each function.
-5.  */
-4. #include ""pngpriv.h""
-3. #if defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED)
-2. static PNG_FUNCTION(void, png_default_error,PNGARG((png_const_structrp png_ptr,
-1.     png_const_charp error_message)),PNG_NORETURN);
#ifdef PNG_WARNINGS_SUPPORTED

/*WARNINGS*/

 ",Not Useful
/*PRIVATE*/,"-10.  * This file provides a location for all error handling.  Users who
-9.  * need special error handling are expected to write replacement functions
-8.  * and use png_set_error_fn() to use those functions.  See the instructions
-7.  * at each function.
-6.  */
-5. #include ""pngpriv.h""
-4. #if defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED)
-3. static PNG_FUNCTION(void, png_default_error,PNGARG((png_const_structrp png_ptr,
-2.     png_const_charp error_message)),PNG_NORETURN);
-1. #ifdef PNG_WARNINGS_SUPPORTED

/*PRIVATE*/

1. png_default_warning PNGARG((png_const_structrp png_ptr,
2.     png_const_charp warning_message));",Not Useful
/*PRIVATE*/,"-10.  * This file provides a location for all error handling.  Users who
-9.  * need special error handling are expected to write replacement functions
-8.  * and use png_set_error_fn() to use those functions.  See the instructions
-7.  * at each function.
-6.  */
-5. #include ""pngpriv.h""
-4. #if defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED)
-3. static PNG_FUNCTION(void, png_default_error,PNGARG((png_const_structrp png_ptr,
-2.     png_const_charp error_message)),PNG_NORETURN);
-1. #ifdef PNG_WARNINGS_SUPPORTED

/*PRIVATE*/

1. png_default_warning PNGARG((png_const_structrp png_ptr,
2.     png_const_charp warning_message));",Not Useful
/*BENIGN_ERRORS*/,"
#ifdef PNG_BENIGN_ERRORS_SUPPORTED



/*BENIGN_ERRORS*/

1. void PNGAPI
2. png_benign_error(png_const_structrp png_ptr, png_const_charp error_message)
3. {
4.    if ((png_ptr->flags & PNG_FLAG_BENIGN_ERRORS_WARN) != 0)
5.    {
6. #     ifdef PNG_READ_SUPPORTED
7.          if ((png_ptr->mode & PNG_IS_READ_STRUCT) != 0 &&
8.             png_ptr->chunk_name != 0)
9.             png_chunk_warning(png_ptr, error_message);
10.          else",Not Useful
/*Currently limited by profile_error in png.c*/,"-10. {
-9.    if ((png_ptr->flags & PNG_FLAG_APP_ERRORS_WARN) != 0)
-8.       png_warning(png_ptr, error_message);
-7.    else
-6.       png_error(png_ptr, error_message);
-5. #  ifndef PNG_ERROR_TEXT_SUPPORTED
-4.       PNG_UNUSED(error_message)
-3. #  endif
-2. }

/*Currently limited by profile_error in png.c*/

1. #if defined(PNG_WARNINGS_SUPPORTED) || \
2.    (defined(PNG_READ_SUPPORTED) && defined(PNG_ERROR_TEXT_SUPPORTED))",Not Useful
/*PRIVATE*/,"-10.  * This file provides a location for all error handling.  Users who
-9.  * need special error handling are expected to write replacement functions
-8.  * and use png_set_error_fn() to use those functions.  See the instructions
-7.  * at each function.
-6.  */
-5. #include ""pngpriv.h""
-4. #if defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED)
-3. static PNG_FUNCTION(void, png_default_error,PNGARG((png_const_structrp png_ptr,
-2.     png_const_charp error_message)),PNG_NORETURN);
-1. #ifdef PNG_WARNINGS_SUPPORTED

/*PRIVATE*/

1. png_default_warning PNGARG((png_const_structrp png_ptr,
2.     png_const_charp warning_message));",Not Useful
"/*iin < PNG_MAX_ERROR_TEXT, so the following is safe:*/","-10.    }
-9.    if (error_message == NULL)
-8.       buffer[iout] = '\0';
-7.    else
-6.    {
-5.       int iin = 0;
-4.       buffer[iout++] = ':';
-3.       buffer[iout++] = ' ';
-2.       while (iin < PNG_MAX_ERROR_TEXT-1 && error_message[iin] != '\0')
-1.          buffer[iout++] = error_message[iin++];

/*iin < PNG_MAX_ERROR_TEXT, so the following is safe:*/

1.       buffer[iout] = '\0';
2.    }
3. }",Not Useful
/*WARNINGS || ERROR_TEXT*/,"-3.       buffer[iout] = '\0';
-2.    }
-1. }

/*WARNINGS || ERROR_TEXT*/

1. #if defined(PNG_READ_SUPPORTED) && defined(PNG_ERROR_TEXT_SUPPORTED)
2. PNG_FUNCTION(void,PNGAPI
3. png_chunk_error,(png_const_structrp png_ptr, png_const_charp error_message),
4.     PNG_NORETURN)
5. {
6.    char msg[18+PNG_MAX_ERROR_TEXT];
7.    if (png_ptr == NULL)
8.       png_error(png_ptr, error_message);
9.    else
10.    {",Not Useful
/*READ && ERROR_TEXT*/,"-10. {
-9.    char msg[18+PNG_MAX_ERROR_TEXT];
-8.    if (png_ptr == NULL)
-7.       png_error(png_ptr, error_message);
-6.    else
-5.    {
-4.       png_format_buffer(png_ptr, msg, error_message);
-3.       png_error(png_ptr, msg);
-2.    }
-1. }

/*READ && ERROR_TEXT*/

1. #ifdef PNG_WARNINGS_SUPPORTED
2. void PNGAPI
3. png_chunk_warning(png_const_structrp png_ptr, png_const_charp warning_message)
4. {
5.    char msg[18+PNG_MAX_ERROR_TEXT];
6.    if (png_ptr == NULL)
7.       png_warning(png_ptr, warning_message);
8.    else
9.    {
10.       png_format_buffer(png_ptr, msg, warning_message);",Not Useful
/*WARNINGS*/,"-10.  *
-9.  * This file provides a location for all error handling.  Users who
-8.  * need special error handling are expected to write replacement functions
-7.  * and use png_set_error_fn() to use those functions.  See the instructions
-6.  * at each function.
-5.  */
-4. #include ""pngpriv.h""
-3. #if defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED)
-2. static PNG_FUNCTION(void, png_default_error,PNGARG((png_const_structrp png_ptr,
-1.     png_const_charp error_message)),PNG_NORETURN);
#ifdef PNG_WARNINGS_SUPPORTED

/*WARNINGS*/

 ",Not Useful
/*PRIVATE*/,"-10.  * This file provides a location for all error handling.  Users who
-9.  * need special error handling are expected to write replacement functions
-8.  * and use png_set_error_fn() to use those functions.  See the instructions
-7.  * at each function.
-6.  */
-5. #include ""pngpriv.h""
-4. #if defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED)
-3. static PNG_FUNCTION(void, png_default_error,PNGARG((png_const_structrp png_ptr,
-2.     png_const_charp error_message)),PNG_NORETURN);
-1. #ifdef PNG_WARNINGS_SUPPORTED

/*PRIVATE*/

1. png_default_warning PNGARG((png_const_structrp png_ptr,
2.     png_const_charp warning_message));",Not Useful
/*png_ptr->jmp_buf_ptr = &png_ptr->jmp_buf_local;*/,"-1.       if (jmp_buf_size <= (sizeof png_ptr->jmp_buf_local))
         png_ptr->jmp_buf_ptr = &png_ptr->jmp_buf_local;

/*png_ptr->jmp_buf_ptr = &png_ptr->jmp_buf_local;*/

1.       else
2.       {
3.          png_ptr->jmp_buf_ptr = png_voidcast(jmp_buf *,
4.              png_malloc_warn(png_ptr, jmp_buf_size));
5.          if (png_ptr->jmp_buf_ptr == NULL)",Not Useful
/*PRIVATE*/,"-10.  * This file provides a location for all error handling.  Users who
-9.  * need special error handling are expected to write replacement functions
-8.  * and use png_set_error_fn() to use those functions.  See the instructions
-7.  * at each function.
-6.  */
-5. #include ""pngpriv.h""
-4. #if defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED)
-3. static PNG_FUNCTION(void, png_default_error,PNGARG((png_const_structrp png_ptr,
-2.     png_const_charp error_message)),PNG_NORETURN);
-1. #ifdef PNG_WARNINGS_SUPPORTED

/*PRIVATE*/

1. png_default_warning PNGARG((png_const_structrp png_ptr,
2.     png_const_charp warning_message));",Not Useful
/*PRIVATE*/,"-10.  * This file provides a location for all error handling.  Users who
-9.  * need special error handling are expected to write replacement functions
-8.  * and use png_set_error_fn() to use those functions.  See the instructions
-7.  * at each function.
-6.  */
-5. #include ""pngpriv.h""
-4. #if defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED)
-3. static PNG_FUNCTION(void, png_default_error,PNGARG((png_const_structrp png_ptr,
-2.     png_const_charp error_message)),PNG_NORETURN);
-1. #ifdef PNG_WARNINGS_SUPPORTED

/*PRIVATE*/

1. png_default_warning PNGARG((png_const_structrp png_ptr,
2.     png_const_charp warning_message));",Not Useful
/*PRIVATE*/,"-10.  * This file provides a location for all error handling.  Users who
-9.  * need special error handling are expected to write replacement functions
-8.  * and use png_set_error_fn() to use those functions.  See the instructions
-7.  * at each function.
-6.  */
-5. #include ""pngpriv.h""
-4. #if defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED)
-3. static PNG_FUNCTION(void, png_default_error,PNGARG((png_const_structrp png_ptr,
-2.     png_const_charp error_message)),PNG_NORETURN);
-1. #ifdef PNG_WARNINGS_SUPPORTED

/*PRIVATE*/

1. png_default_warning PNGARG((png_const_structrp png_ptr,
2.     png_const_charp warning_message));",Not Useful
/*WARNINGS*/,"-10.  *
-9.  * This file provides a location for all error handling.  Users who
-8.  * need special error handling are expected to write replacement functions
-7.  * and use png_set_error_fn() to use those functions.  See the instructions
-6.  * at each function.
-5.  */
-4. #include ""pngpriv.h""
-3. #if defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED)
-2. static PNG_FUNCTION(void, png_default_error,PNGARG((png_const_structrp png_ptr,
-1.     png_const_charp error_message)),PNG_NORETURN);
#ifdef PNG_WARNINGS_SUPPORTED

/*WARNINGS*/

 ",Not Useful
/*PRIVATE*/,"-10.  * This file provides a location for all error handling.  Users who
-9.  * need special error handling are expected to write replacement functions
-8.  * and use png_set_error_fn() to use those functions.  See the instructions
-7.  * at each function.
-6.  */
-5. #include ""pngpriv.h""
-4. #if defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED)
-3. static PNG_FUNCTION(void, png_default_error,PNGARG((png_const_structrp png_ptr,
-2.     png_const_charp error_message)),PNG_NORETURN);
-1. #ifdef PNG_WARNINGS_SUPPORTED

/*PRIVATE*/

1. png_default_warning PNGARG((png_const_structrp png_ptr,
2.     png_const_charp warning_message));",Not Useful
/*PRIVATE*/,"-10.  * This file provides a location for all error handling.  Users who
-9.  * need special error handling are expected to write replacement functions
-8.  * and use png_set_error_fn() to use those functions.  See the instructions
-7.  * at each function.
-6.  */
-5. #include ""pngpriv.h""
-4. #if defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED)
-3. static PNG_FUNCTION(void, png_default_error,PNGARG((png_const_structrp png_ptr,
-2.     png_const_charp error_message)),PNG_NORETURN);
-1. #ifdef PNG_WARNINGS_SUPPORTED

/*PRIVATE*/

1. png_default_warning PNGARG((png_const_structrp png_ptr,
2.     png_const_charp warning_message));",Not Useful
/*PRIVATE*/,"-10.  * This file provides a location for all error handling.  Users who
-9.  * need special error handling are expected to write replacement functions
-8.  * and use png_set_error_fn() to use those functions.  See the instructions
-7.  * at each function.
-6.  */
-5. #include ""pngpriv.h""
-4. #if defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED)
-3. static PNG_FUNCTION(void, png_default_error,PNGARG((png_const_structrp png_ptr,
-2.     png_const_charp error_message)),PNG_NORETURN);
-1. #ifdef PNG_WARNINGS_SUPPORTED

/*PRIVATE*/

1. png_default_warning PNGARG((png_const_structrp png_ptr,
2.     png_const_charp warning_message));",Not Useful
/*SIMPLIFIED READ || SIMPLIFIED_WRITE*/,"-4.    if (result == 0)
-3.       png_image_free(image);
-2.    return result;
-1. }

/*SIMPLIFIED READ || SIMPLIFIED_WRITE*/

 ",Not Useful
/*#define STDERR stderr*/,"-10.  * If a filename is given on the command-line, then this file is used
-9.  * for the input, rather than the default ""pngtest.png"".  This allows
-8.  * testing a wide variety of files easily.  You can also test a number
-7.  * of files at once by typing ""pngtest -m file1.png file2.png ...""
-6.  */
-5. #define _POSIX_SOURCE 1
-4. #include <stdio.h>
-3. #include <stdlib.h>
-2. #include <string.h>

/*#define STDERR stderr*/

 ",Not Useful
/*count calls to png_error*/,"-6. #endif
-5. static int verbose = 0;
-4. static int strict = 0;
-3. static int relaxed = 0;
-2. static int xfail = 0;

/*count calls to png_error*/

 ",Not Useful
/*count calls to png_warning*/,"-7. #endif
-6. static int verbose = 0;
-5. static int strict = 0;
-4. static int relaxed = 0;
-3. static int xfail = 0;

/*count calls to png_warning*/

 ",Not Useful
/*Define png_jmpbuf() in case we are using a pre-1.0.6 version of libpng*/,"-8. #endif
-7. static int verbose = 0;
-6. static int strict = 0;
-5. static int relaxed = 0;
-4. static int xfail = 0;

/*Define png_jmpbuf() in case we are using a pre-1.0.6 version of libpng*/

1. #ifndef png_jmpbuf
2. #  define png_jmpbuf(png_ptr) png_ptr->jmpbuf
3. #endif",Not Useful
/*WRITE_USER_TRANSFORM*/,"-8. static void PNGCBAPI
-7. read_user_callback(png_structp png_ptr, png_row_infop row_info, png_bytep data)
-6. {
-5.    PNG_UNUSED(png_ptr)
-4.    PNG_UNUSED(row_info)
-3.    PNG_UNUSED(data)
-2. }
-1. #endif
#ifdef PNG_WRITE_USER_TRANSFORM_SUPPORTED

/*WRITE_USER_TRANSFORM*/

 ",Not Useful
/*!STDIO*/,"-10.    png_size_t check;
-9.    check = fwrite(data, 1, length, (png_FILE_p)png_get_io_ptr(png_ptr));
-8.    if (check != length)
-7.    {
-6.       png_error(png_ptr, ""Write Error"");
-5.    }
-4. #ifdef PNG_IO_STATE_SUPPORTED
-3.    pngtest_check_io_state(png_ptr, length, PNG_IO_WRITING);
-2. #endif
-1. }

/*!STDIO*/

 ",Not Useful
/*already have one of these*/,"-10. init_callback_info(png_const_infop info_ptr)
-9. {
-8.    MEMZERO(user_chunk_data);
-7.    user_chunk_data.info_ptr = info_ptr;
-6. }
-5. static int
-4. set_location(png_structp png_ptr, struct user_chunk_data *data, int what)
-3. {
-2.    int location;
-1.    if ((data->location[0] & what) != 0 || (data->location[1] & what) != 0)

/*already have one of these*/

 ",Not Useful
/*s  T*/,"-10.     *    return (0);  did not recognize
-9.     *    return (n);  success
-8.     *
-7.     * The unknown chunk structure contains the chunk data:
-6.     * png_byte name[5];
-5.     * png_byte *data;
-4.     * png_size_t size;
-3.     *
-2.     * Note that libpng has already taken care of the CRC handling.
-1.     */

/*s  T*/

 ",Not Useful
/*E  R*/,"-10.     *    return (n);  success
-9.     *
-8.     * The unknown chunk structure contains the chunk data:
-7.     * png_byte name[5];
-6.     * png_byte *data;
-5.     * png_size_t size;
-4.     *
-3.     * Note that libpng has already taken care of the CRC handling.
-2.     */

/*E  R*/

1.       {",Not Useful
/*Found sTER chunk*/,"-1.       {

/*Found sTER chunk*/

1.          if (chunk->size != 1)",Not Useful
/*v  p*/,"-1.       }

/*v  p*/

 ",Not Useful
/*A  g*/,"-2.       }

/*A  g*/

 ",Not Useful
/*Did not recognize*/,"-3.       }

/*Did not recognize*/

 ",Not Useful
/*duplicate vpAg*/,"-1.    if (set_location(png_ptr, my_user_chunk_data, have_vpAg) == 0)

/*duplicate vpAg*/

1.    my_user_chunk_data->vpAg_width = png_get_uint_31(png_ptr, chunk->data);
2.    my_user_chunk_data->vpAg_height = png_get_uint_31(png_ptr, chunk->data + 4);
3.    my_user_chunk_data->vpAg_units = chunk->data[8];
4.    return (1);
5. }
6. #ifdef PNG_WRITE_SUPPORTED
7. static void
8. write_sTER_chunk(png_structp write_ptr)
9. {
10.    png_byte sTER[5] = {115,  84,  69,  82, '\0'};",Not Useful
/*!READ_USER_CHUNKS*/,"-10.     */
-9.    for (i=0; i<2; ++i)
-8.    {
-7.       if (user_chunk_data.location[i] == (location | have_sTER))
-6.          write_sTER_chunk(write_ptr);
-5.       else if (user_chunk_data.location[i] == (location | have_vpAg))
-4.          write_vpAg_chunk(write_ptr);
-3.    }
-2. }

/*!READ_USER_CHUNKS*/

1. #  define write_chunks(pp,loc) ((void)0)
2. #endif",Not Useful
/*Test one file*/,"-7.             png_error(png_ptr, ""invalid text chunk compression field"");
-6.             break;
-5.       }
-4.    }
-3. }
-2. #endif

/*Test one file*/

1. static int
2. test_one_file(PNG_CONST char *inname, PNG_CONST char *outname)
3. {
4.    static png_FILE_p fpin;",Not Useful
/*WRITE_FILTER*/,"-7.    pngtest_error_parameters error_parameters;
-6.    png_structp read_ptr;
-5.    png_infop read_info_ptr, end_info_ptr;
-4. #ifdef PNG_WRITE_SUPPORTED
-3.    png_structp write_ptr;
-2.    png_infop write_info_ptr;
-1.    png_infop write_end_info_ptr;
#ifdef PNG_WRITE_FILTER_SUPPORTED

/*WRITE_FILTER*/

1.    int interlace_preserved = 1;",Not Useful
/*BENIGN_ERRORS*/,"-10.       if (verbose != 0)
-9.         fprintf(STDERR, ""   destroying write structs\n"");
-8.       png_destroy_info_struct(write_ptr, &write_end_info_ptr);
-7.       png_destroy_write_struct(&write_ptr, &write_info_ptr);
-6.       FCLOSE(fpin);
-5.       FCLOSE(fpout);
-4.       return (1);
-3.    }
-2. #endif
-1. #endif
#ifdef PNG_BENIGN_ERRORS_SUPPORTED

/*BENIGN_ERRORS*/

1.    if (strict != 0)
2.    {",Not Useful
/*Use floating point versions*/,"-10.       }
-9.    }
-8. #endif
-7. #ifdef PNG_gAMA_SUPPORTED
-6.    {
-5.       png_fixed_point gamma;
-4.       if (png_get_gAMA_fixed(read_ptr, read_info_ptr, &gamma) != 0)
-3.          png_set_gAMA_fixed(write_ptr, write_info_ptr, gamma);
-2.    }
-1. #endif

/*Use floating point versions*/

1. #ifdef PNG_FLOATING_POINT_SUPPORTED
2. #ifdef PNG_cHRM_SUPPORTED
3.    {
4.       double white_x, white_y, red_x, red_y, green_x, green_y, blue_x,
5.           blue_y;
6.       if (png_get_cHRM(read_ptr, read_info_ptr, &white_x, &white_y, &red_x,
7.           &red_y, &green_x, &green_y, &blue_x, &blue_y) != 0)
8.       {
9.          png_set_cHRM(write_ptr, write_info_ptr, white_x, white_y, red_x,
10.              red_y, green_x, green_y, blue_x, blue_y);",Not Useful
/*Floating point*/,"-10.       }
-9.    }
-8. #endif
-7. #ifdef PNG_gAMA_SUPPORTED
-6.    {
-5.       double gamma;
-4.       if (png_get_gAMA(read_ptr, read_info_ptr, &gamma) != 0)
-3.          png_set_gAMA(write_ptr, write_info_ptr, gamma);
-2.    }
-1. #endif

/*Floating point*/

 ",Not Useful
/*Fixed point*/,"-10.    }
-9. #endif
-8. #ifdef PNG_gAMA_SUPPORTED
-7.    {
-6.       double gamma;
-5.       if (png_get_gAMA(read_ptr, read_info_ptr, &gamma) != 0)
-4.          png_set_gAMA(write_ptr, write_info_ptr, gamma);
-3.    }
-2. #endif

/*Fixed point*/

1. #ifdef PNG_iCCP_SUPPORTED
2.    {
3.       png_charp name;
4.       png_bytep profile;
5.       png_uint_32 proflen;
6.       int compression_type;
7.       if (png_get_iCCP(read_ptr, read_info_ptr, &name, &compression_type,
8.           &profile, &proflen) != 0)
9.       {
10.          png_set_iCCP(write_ptr, write_info_ptr, name, compression_type,",Not Useful
/*TIME_RFC1123*/,"-7. #ifndef PNG_FLOATING_POINT_SUPPORTED
-6. #undef PNGTEST_TIMING
-5. #endif
-4. #ifdef PNGTEST_TIMING
-3. static float t_start, t_stop, t_decode, t_encode, t_misc;
-2. #include <time.h>
-1. #endif
#ifdef PNG_TIME_RFC1123_SUPPORTED

/*TIME_RFC1123*/

1. #define PNG_tIME_STRING_LENGTH 29
2. static int tIME_chunk_present = 0;
3. static char tIME_string[PNG_tIME_STRING_LENGTH] = ""tIME chunk is not present"";
4. #if PNG_LIBPNG_VER < 10619
5. #define png_convert_to_rfc1123_buffer(ts, t) tIME_to_str(read_ptr, ts, t)
6. static int
7. tIME_to_str(png_structp png_ptr, png_charp ts, png_const_timep t)
8. {
9.    png_const_charp str = png_convert_to_rfc1123(png_ptr, t);
10.    if (str == NULL)",Not Useful
/*before PLTE*/,"-1.    png_write_info_before_PLTE(write_ptr, write_info_ptr);

/*before PLTE*/

1.    png_write_info(write_ptr, write_info_ptr);",Not Useful
/*after PLTE*/,"-1.    png_write_info(write_ptr, write_info_ptr);

/*after PLTE*/

1.    png_write_info(write_ptr, write_end_info_ptr);",Not Useful
/*SINGLE_ROWBUF_ALLOC*/,"-10. #if PNG_DEBUG > 1
-9. #  define pngtest_debug(m)        ((void)fprintf(stderr, m ""\n""))
-8. #  define pngtest_debug1(m,p1)    ((void)fprintf(stderr, m ""\n"", p1))
-7. #  define pngtest_debug2(m,p1,p2) ((void)fprintf(stderr, m ""\n"", p1, p2))
-6. #else
-5. #  define pngtest_debug(m)        ((void)0)
-4. #  define pngtest_debug1(m,p1)    ((void)0)
-3. #  define pngtest_debug2(m,p1,p2) ((void)0)
-2. #endif
-1. #if !PNG_DEBUG

/*SINGLE_ROWBUF_ALLOC*/

1. #endif
2. #ifndef PNG_UNUSED
3. #  define PNG_UNUSED(param) (void)param;
4. #endif",Not Useful
/*!SINGLE_ROWBUF_ALLOC*/,"-10. #     endif
-9.       pngtest_debug1(""Writing row data for pass %d"", pass);
-8.       for (y = 0; y < pass_height; y++)
-7.       {
-6. #ifndef SINGLE_ROWBUF_ALLOC
-5.          pngtest_debug2(""Allocating row buffer (pass %d, y = %u)..."", pass, y);
-4.          row_buf = (png_bytep)png_malloc(read_ptr,
-3.              png_get_rowbytes(read_ptr, read_info_ptr));
-2.          pngtest_debug2(""\t0x%08lx (%lu bytes)"", (unsigned long)row_buf,
-1.              (unsigned long)png_get_rowbytes(read_ptr, read_info_ptr));

/*!SINGLE_ROWBUF_ALLOC*/

1.          png_read_rows(read_ptr, (png_bytepp)&row_buf, NULL, 1);
2. #ifdef PNG_WRITE_SUPPORTED
3. #ifdef PNGTEST_TIMING
4.          t_stop = (float)clock();
5.          t_decode += (t_stop - t_start);
6.          t_start = t_stop;
7. #endif
8.          png_write_rows(write_ptr, (png_bytepp)&row_buf, 1);
9. #ifdef PNGTEST_TIMING
10.          t_stop = (float)clock();",Not Useful
/*!SINGLE_ROWBUF_ALLOC*/,"-10. #     endif
-9.       pngtest_debug1(""Writing row data for pass %d"", pass);
-8.       for (y = 0; y < pass_height; y++)
-7.       {
-6. #ifndef SINGLE_ROWBUF_ALLOC
-5.          pngtest_debug2(""Allocating row buffer (pass %d, y = %u)..."", pass, y);
-4.          row_buf = (png_bytep)png_malloc(read_ptr,
-3.              png_get_rowbytes(read_ptr, read_info_ptr));
-2.          pngtest_debug2(""\t0x%08lx (%lu bytes)"", (unsigned long)row_buf,
-1.              (unsigned long)png_get_rowbytes(read_ptr, read_info_ptr));

/*!SINGLE_ROWBUF_ALLOC*/

1.          png_read_rows(read_ptr, (png_bytepp)&row_buf, NULL, 1);
2. #ifdef PNG_WRITE_SUPPORTED
3. #ifdef PNGTEST_TIMING
4.          t_stop = (float)clock();
5.          t_decode += (t_stop - t_start);
6.          t_start = t_stop;
7. #endif
8.          png_write_rows(write_ptr, (png_bytepp)&row_buf, 1);
9. #ifdef PNGTEST_TIMING
10.          t_stop = (float)clock();",Not Useful
/*TIME_RFC1123*/,"-7. #ifndef PNG_FLOATING_POINT_SUPPORTED
-6. #undef PNGTEST_TIMING
-5. #endif
-4. #ifdef PNGTEST_TIMING
-3. static float t_start, t_stop, t_decode, t_encode, t_misc;
-2. #include <time.h>
-1. #endif
#ifdef PNG_TIME_RFC1123_SUPPORTED

/*TIME_RFC1123*/

1. #define PNG_tIME_STRING_LENGTH 29
2. static int tIME_chunk_present = 0;
3. static char tIME_string[PNG_tIME_STRING_LENGTH] = ""tIME chunk is not present"";
4. #if PNG_LIBPNG_VER < 10619
5. #define png_convert_to_rfc1123_buffer(ts, t) tIME_to_str(read_ptr, ts, t)
6. static int
7. tIME_to_str(png_structp png_ptr, png_charp ts, png_const_timep t)
8. {
9.    png_const_charp str = png_convert_to_rfc1123(png_ptr, t);
10.    if (str == NULL)",Not Useful
/*SINGLE_ROWBUF_ALLOC*/,"-10. #if PNG_DEBUG > 1
-9. #  define pngtest_debug(m)        ((void)fprintf(stderr, m ""\n""))
-8. #  define pngtest_debug1(m,p1)    ((void)fprintf(stderr, m ""\n"", p1))
-7. #  define pngtest_debug2(m,p1,p2) ((void)fprintf(stderr, m ""\n"", p1, p2))
-6. #else
-5. #  define pngtest_debug(m)        ((void)0)
-4. #  define pngtest_debug1(m,p1)    ((void)0)
-3. #  define pngtest_debug2(m,p1,p2) ((void)0)
-2. #endif
-1. #if !PNG_DEBUG

/*SINGLE_ROWBUF_ALLOC*/

1. #endif
2. #ifndef PNG_UNUSED
3. #  define PNG_UNUSED(param) (void)param;
4. #endif",Not Useful
/*WRITE && WRITE_FILTER*/,"-10.              * mode being changed (to NONE) yet, in the test case, the result
-9.              * can be exactly the same size!
-8.              */
-7.             if (strict != 0 && unsupported_chunks == 0)
-6.               return (1);
-5.             else
-4.               return (0);
-3.          }
-2.       }
-1.    }

/*WRITE && WRITE_FILTER*/

1.    FCLOSE(fpin);
2.    FCLOSE(fpout);
3.    return (0);
4. }",Not Useful
/*TIME_RFC1123*/,"-7. #ifndef PNG_FLOATING_POINT_SUPPORTED
-6. #undef PNGTEST_TIMING
-5. #endif
-4. #ifdef PNGTEST_TIMING
-3. static float t_start, t_stop, t_decode, t_encode, t_misc;
-2. #include <time.h>
-1. #endif
#ifdef PNG_TIME_RFC1123_SUPPORTED

/*TIME_RFC1123*/

1. #define PNG_tIME_STRING_LENGTH 29
2. static int tIME_chunk_present = 0;
3. static char tIME_string[PNG_tIME_STRING_LENGTH] = ""tIME chunk is not present"";
4. #if PNG_LIBPNG_VER < 10619
5. #define png_convert_to_rfc1123_buffer(ts, t) tIME_to_str(read_ptr, ts, t)
6. static int
7. tIME_to_str(png_structp png_ptr, png_charp ts, png_const_timep t)
8. {
9.    png_const_charp str = png_convert_to_rfc1123(png_ptr, t);
10.    if (str == NULL)",Not Useful
/*TIME_RFC1123*/,"-7. #ifndef PNG_FLOATING_POINT_SUPPORTED
-6. #undef PNGTEST_TIMING
-5. #endif
-4. #ifdef PNGTEST_TIMING
-3. static float t_start, t_stop, t_decode, t_encode, t_misc;
-2. #include <time.h>
-1. #endif
#ifdef PNG_TIME_RFC1123_SUPPORTED

/*TIME_RFC1123*/

1. #define PNG_tIME_STRING_LENGTH 29
2. static int tIME_chunk_present = 0;
3. static char tIME_string[PNG_tIME_STRING_LENGTH] = ""tIME chunk is not present"";
4. #if PNG_LIBPNG_VER < 10619
5. #define png_convert_to_rfc1123_buffer(ts, t) tIME_to_str(read_ptr, ts, t)
6. static int
7. tIME_to_str(png_structp png_ptr, png_charp ts, png_const_timep t)
8. {
9.    png_const_charp str = png_convert_to_rfc1123(png_ptr, t);
10.    if (str == NULL)",Not Useful
/*And skip this test*/,"-10.           (unsigned long) png_get_chunk_malloc_max(dummy_ptr));
-9.    png_destroy_read_struct(&dummy_ptr, NULL, NULL);
-8.    return (int)(ierror != 0);
-7. }
-6. #else
-5. int
-4. main(void)
-3. {
-2.    fprintf(STDERR,
-1.        "" test ignored because libpng was not built with read support\n"");

/*And skip this test*/

1.    return PNG_LIBPNG_VER < 10600 ? 0 : 77;
2. }
3. #endif",Not Useful
/*GNU 7.1.x*/,"-10.  * the optimizer in such a way that the results of the comparison will change
-9.  * if signed integer overflow occurs.  Such comparisons are not permitted in
-8.  * ANSI C90, however GCC isn't clever enough to work out that that do not occur
-7.  * below in png_ascii_from_fp and png_muldiv, so it produces a warning with
-6.  * -Wextra.  Unfortunately this is highly dependent on the optimizer and the
-5.  * machine architecture so the warning comes and goes unpredictably and is
-4.  * impossible to ""fix"", even were that a good idea.
-3.  */
-2. #if __GNUC__ == 7 && __GNUC_MINOR__ == 1
-1. #define GCC_STRICT_OVERFLOW 1

/*GNU 7.1.x*/

 ",Not Useful
/*GNU*/,"-1. typedef png_libpng_version_1_6_34 Your_png_h_is_not_version_1_6_34;
#ifdef __GNUC__

/*GNU*/

1. /* The version tests may need to be added to, but the problem warning has
2.  * consistently been fixed in GCC versions which obtain wide-spread release.
3.  * The problem is that many versions of GCC rearrange comparison expressions in
4.  * the optimizer in such a way that the results of the comparison will change
5.  * if signed integer overflow occurs.  Such comparisons are not permitted in
6.  * ANSI C90, however GCC isn't clever enough to work out that that do not occur
7.  * below in png_ascii_from_fp and png_muldiv, so it produces a warning with
8.  * -Wextra.  Unfortunately this is highly dependent on the optimizer and the
9.  * machine architecture so the warning comes and goes unpredictably and is
10.  * impossible to ""fix"", even were that a good idea.",Not Useful
/*critical*/,"-9. png_calculate_crc(png_structrp png_ptr, png_const_bytep ptr, png_size_t length)
-8. {
-7.    int need_crc = 1;
-6.    if (PNG_CHUNK_ANCILLARY(png_ptr->chunk_name) != 0)
-5.    {
-4.       if ((png_ptr->flags & PNG_FLAG_CRC_ANCILLARY_MASK) ==
-3.           (PNG_FLAG_CRC_ANCILLARY_USE | PNG_FLAG_CRC_ANCILLARY_NOWARN))
-2.          need_crc = 0;
-1.    }

/*critical*/

1.    {
2.       if ((png_ptr->flags & PNG_FLAG_CRC_CRITICAL_IGNORE) != 0)
3.          need_crc = 0;
4.    }",Not Useful
/*Should never issue a warning*/,"-2.    if (need_crc != 0 && length > 0)
-1.    {

/*Should never issue a warning*/

1.       do
2.       {
3.          uInt safe_length = (uInt)length;
4. #ifndef __COVERITY__
5.          if (safe_length == 0)",Not Useful
"/*evil, but safe*/","-5.       do
-4.       {
-3.          uInt safe_length = (uInt)length;
-2. #ifndef __COVERITY__
-1.          if (safe_length == 0)

/*evil, but safe*/

1. #endif
2.          crc = crc32(crc, ptr, safe_length);",Not Useful
"/*png_ptr->zstream holds a back-pointer to the png_struct, so
                * this can only be done now:*/","-6.          if (png_user_version_check(&create_struct, user_png_ver) != 0)
-5.          {
-4.             png_structrp png_ptr = png_voidcast(png_structrp,
-3.                 png_malloc_warn(&create_struct, (sizeof *png_ptr)));
-2.             if (png_ptr != NULL)
-1.             {
               /* png_ptr->zstream holds a back-pointer to the png_struct, so
                * this can only be done now:

/*png_ptr->zstream holds a back-pointer to the png_struct, so
                * this can only be done now:*/

1.                 */
2.                create_struct.zstream.zalloc = png_zalloc;
3.                create_struct.zstream.zfree = png_zfree;
4.                create_struct.zstream.opaque = png_ptr;
5. #              ifdef PNG_SETJMP_SUPPORTED",Not Useful
/*The following line is why this API should not be used:*/,"-10. png_info_init_3,(png_infopp ptr_ptr, png_size_t png_info_struct_size),
-9.     PNG_DEPRECATED)
-8. {
-7.    png_inforp info_ptr = *ptr_ptr;
-6.    png_debug(1, ""in png_info_init_3"");
-5.    if (info_ptr == NULL)
-4.       return;
-3.    if ((sizeof (png_info)) > png_info_struct_size)
-2.    {
-1.       *ptr_ptr = NULL;

/*The following line is why this API should not be used:*/

1.       free(info_ptr);
2.       info_ptr = png_voidcast(png_inforp, png_malloc_base(NULL,
3.           (sizeof *info_ptr)));
4.       if (info_ptr == NULL)
5.          return;
6.       *ptr_ptr = info_ptr;
7.    }",Not Useful
/*Free any tRNS entry*/,"-10.          for (i = 0; i < info_ptr->num_text; i++)
-9.             png_free(png_ptr, info_ptr->text[i].key);
-8.          png_free(png_ptr, info_ptr->text);
-7.          info_ptr->text = NULL;
-6.          info_ptr->num_text = 0;
-5.          info_ptr->max_text = 0;
-4.       }
-3.    }
-2. #endif
-1. #ifdef PNG_tRNS_SUPPORTED

/*Free any tRNS entry*/

1.    if (((mask & PNG_FREE_TRNS) & info_ptr->free_me) != 0)
2.    {
3.       info_ptr->valid &= ~PNG_INFO_tRNS;
4.       png_free(png_ptr, info_ptr->trans_alpha);
5.       info_ptr->trans_alpha = NULL;
6.       info_ptr->num_trans = 0;
7.    }
8. #endif
9. #ifdef PNG_sCAL_SUPPORTED",Not Useful
/*Free any sCAL entry*/,"-9.    if (((mask & PNG_FREE_TRNS) & info_ptr->free_me) != 0)
-8.    {
-7.       info_ptr->valid &= ~PNG_INFO_tRNS;
-6.       png_free(png_ptr, info_ptr->trans_alpha);
-5.       info_ptr->trans_alpha = NULL;
-4.       info_ptr->num_trans = 0;
-3.    }
-2. #endif
-1. #ifdef PNG_sCAL_SUPPORTED

/*Free any sCAL entry*/

1.    if (((mask & PNG_FREE_SCAL) & info_ptr->free_me) != 0)
2.    {
3.       png_free(png_ptr, info_ptr->scal_s_width);
4.       png_free(png_ptr, info_ptr->scal_s_height);
5.       info_ptr->scal_s_width = NULL;
6.       info_ptr->scal_s_height = NULL;
7.       info_ptr->valid &= ~PNG_INFO_sCAL;
8.    }
9. #endif
10. #ifdef PNG_pCAL_SUPPORTED",Not Useful
/*Free any pCAL entry*/,"-10.    if (((mask & PNG_FREE_SCAL) & info_ptr->free_me) != 0)
-9.    {
-8.       png_free(png_ptr, info_ptr->scal_s_width);
-7.       png_free(png_ptr, info_ptr->scal_s_height);
-6.       info_ptr->scal_s_width = NULL;
-5.       info_ptr->scal_s_height = NULL;
-4.       info_ptr->valid &= ~PNG_INFO_sCAL;
-3.    }
-2. #endif
-1. #ifdef PNG_pCAL_SUPPORTED

/*Free any pCAL entry*/

1.    if (((mask & PNG_FREE_PCAL) & info_ptr->free_me) != 0)
2.    {
3.       png_free(png_ptr, info_ptr->pcal_purpose);
4.       png_free(png_ptr, info_ptr->pcal_units);
5.       info_ptr->pcal_purpose = NULL;
6.       info_ptr->pcal_units = NULL;
7.       if (info_ptr->pcal_params != NULL)
8.          {
9.             int i;
10.             for (i = 0; i < info_ptr->pcal_nparams; i++)",Not Useful
/*Free any profile entry*/,"-10.             int i;
-9.             for (i = 0; i < info_ptr->pcal_nparams; i++)
-8.                png_free(png_ptr, info_ptr->pcal_params[i]);
-7.             png_free(png_ptr, info_ptr->pcal_params);
-6.             info_ptr->pcal_params = NULL;
-5.          }
-4.       info_ptr->valid &= ~PNG_INFO_pCAL;
-3.    }
-2. #endif
-1. #ifdef PNG_iCCP_SUPPORTED

/*Free any profile entry*/

1.    if (((mask & PNG_FREE_ICCP) & info_ptr->free_me) != 0)
2.    {
3.       png_free(png_ptr, info_ptr->iccp_name);
4.       png_free(png_ptr, info_ptr->iccp_profile);
5.       info_ptr->iccp_name = NULL;
6.       info_ptr->iccp_profile = NULL;
7.       info_ptr->valid &= ~PNG_INFO_iCCP;
8.    }
9. #endif
10. #ifdef PNG_sPLT_SUPPORTED",Not Useful
"/*Free a given sPLT entry, or (if num == -1) all sPLT entries*/","-10.    if (((mask & PNG_FREE_ICCP) & info_ptr->free_me) != 0)
-9.    {
-8.       png_free(png_ptr, info_ptr->iccp_name);
-7.       png_free(png_ptr, info_ptr->iccp_profile);
-6.       info_ptr->iccp_name = NULL;
-5.       info_ptr->iccp_profile = NULL;
-4.       info_ptr->valid &= ~PNG_INFO_iCCP;
-3.    }
-2. #endif
-1. #ifdef PNG_sPLT_SUPPORTED

/*Free a given sPLT entry, or (if num == -1) all sPLT entries*/

1.    if (info_ptr->splt_palettes != NULL &&
2.        ((mask & PNG_FREE_SPLT) & info_ptr->free_me) != 0)
3.    {
4.       if (num != -1)
5.       {
6.          png_free(png_ptr, info_ptr->splt_palettes[num].name);
7.          png_free(png_ptr, info_ptr->splt_palettes[num].entries);
8.          info_ptr->splt_palettes[num].name = NULL;
9.          info_ptr->splt_palettes[num].entries = NULL;
10.       }",Not Useful
/*Free any eXIf entry*/,"-10.          int i;
-9.          for (i = 0; i < info_ptr->unknown_chunks_num; i++)
-8.             png_free(png_ptr, info_ptr->unknown_chunks[i].data);
-7.          png_free(png_ptr, info_ptr->unknown_chunks);
-6.          info_ptr->unknown_chunks = NULL;
-5.          info_ptr->unknown_chunks_num = 0;
-4.       }
-3.    }
-2. #endif
-1. #ifdef PNG_eXIf_SUPPORTED

/*Free any eXIf entry*/

1.    if (((mask & PNG_FREE_EXIF) & info_ptr->free_me) != 0)
2.    {
3. # ifdef PNG_READ_eXIf_SUPPORTED
4.       if (info_ptr->eXIf_buf)
5.       {
6.          png_free(png_ptr, info_ptr->eXIf_buf);
7.          info_ptr->eXIf_buf = NULL;
8.       }
9. # endif
10.       if (info_ptr->exif)",Not Useful
/*Free any hIST entry*/,"-10. # endif
-9.       if (info_ptr->exif)
-8.       {
-7.          png_free(png_ptr, info_ptr->exif);
-6.          info_ptr->exif = NULL;
-5.       }
-4.       info_ptr->valid &= ~PNG_INFO_eXIf;
-3.    }
-2. #endif
-1. #ifdef PNG_hIST_SUPPORTED

/*Free any hIST entry*/

1.    if (((mask & PNG_FREE_HIST) & info_ptr->free_me) != 0)
2.    {
3.       png_free(png_ptr, info_ptr->hist);
4.       info_ptr->hist = NULL;
5.       info_ptr->valid &= ~PNG_INFO_hIST;
6.    }
7. #endif",Not Useful
/*Free any PLTE entry that was internally allocated*/,"-7.    if (((mask & PNG_FREE_HIST) & info_ptr->free_me) != 0)
-6.    {
-5.       png_free(png_ptr, info_ptr->hist);
-4.       info_ptr->hist = NULL;
-3.       info_ptr->valid &= ~PNG_INFO_hIST;
-2.    }
-1. #endif

/*Free any PLTE entry that was internally allocated*/

1.    if (((mask & PNG_FREE_PLTE) & info_ptr->free_me) != 0)
2.    {
3.       png_free(png_ptr, info_ptr->palette);
4.       info_ptr->palette = NULL;
5.       info_ptr->valid &= ~PNG_INFO_PLTE;
6.       info_ptr->num_palette = 0;
7.    }
8. #ifdef PNG_INFO_IMAGE_SUPPORTED",Not Useful
/*RFC1123 limitation*/,"-10.  * a ""Creation Time"" or other text-based time string.
-9.  */
-8. int PNGAPI
-7. png_convert_to_rfc1123_buffer(char out[29], png_const_timep ptime)
-6. {
-5.    static PNG_CONST char short_months[12][4] =
-4.         {""Jan"", ""Feb"", ""Mar"", ""Apr"", ""May"", ""Jun"",
-3.          ""Jul"", ""Aug"", ""Sep"", ""Oct"", ""Nov"", ""Dec""};
-2.    if (out == NULL)
-1.       return 0;

/*RFC1123 limitation*/

1.        ptime->month == 0    ||  ptime->month > 12  ||
2.        ptime->day   == 0    ||  ptime->day   > 31  ||
3.        ptime->hour  > 23    ||  ptime->minute > 59 ||
4.        ptime->second > 60)
5.       return 0;
6.    {
7.       size_t pos = 0;",Not Useful
/*TIME_RFC1123*/,"-10.  * Where UNSIGNED_MAX is the appropriate maximum unsigned value, so when the
-9.  * negative integral value is added the result will be an unsigned value
-8.  * correspnding to the 2's complement representation.
-7.  */
-6. void PNGAPI
-5. png_save_int_32(png_bytep buf, png_int_32 i)
-4. {
-3.    png_save_uint_32(buf, (png_uint_32)i);
-2. }
-1. #  endif
#  ifdef PNG_TIME_RFC1123_SUPPORTED

/*TIME_RFC1123*/

 ",Not Useful
"/*num_chunk_list > 0, so at least one*/","-9.    png_const_bytep p, p_end;
-8.    if (png_ptr == NULL || chunk_name == NULL || png_ptr->num_chunk_list == 0)
-7.       return PNG_HANDLE_CHUNK_AS_DEFAULT;
-6.    p_end = png_ptr->chunk_list;

/*num_chunk_list > 0, so at least one*/

1.    {
2.       p -= 5;
3.       if (memcmp(chunk_name, p, 4) == 0)
4.          return p[4];
5.    }
6.    while (p > p_end);
7.    /* This means that known chunks should be processed and unknown chunks should
8.     * be handled according to the value of png_ptr->unknown_default; this can be
9.     * confusing because, as a result, there are two levels of defaulting for
10.     * unknown chunks.",Not Useful
/*READ_UNKNOWN_CHUNKS || HANDLE_AS_UNKNOWN*/,"-6. png_chunk_unknown_handling(png_const_structrp png_ptr, png_uint_32 chunk_name)
-5. {
-4.    png_byte chunk_string[5];
-3.    PNG_CSTRING_FROM_CHUNK(chunk_string, chunk_name);
-2.    return png_handle_as_unknown(png_ptr, chunk_string);
-1. }

/*READ_UNKNOWN_CHUNKS || HANDLE_AS_UNKNOWN*/

 ",Not Useful
/*SET_UNKNOWN_CHUNKS*/,"-10.          break;
-9.    }
-8.    for (i = 0, v = 0; i < num_palette; i++, v += color_inc)
-7.    {
-6.       palette[i].red = (png_byte)(v & 0xff);
-5.       palette[i].green = (png_byte)(v & 0xff);
-4.       palette[i].blue = (png_byte)(v & 0xff);
-3.    }
-2. }
-1. #endif
#ifdef PNG_SET_UNKNOWN_CHUNKS_SUPPORTED

/*SET_UNKNOWN_CHUNKS*/

1. int PNGAPI
2. png_handle_as_unknown(png_const_structrp png_ptr, png_const_bytep chunk_name)
3. {",Not Useful
/*from gAMA*/,"-5.    else if ((colorspace->flags & PNG_COLORSPACE_INVALID) != 0)
-4.       return;
-3.    else
-2.    {
-1.       if (png_colorspace_check_gamma(png_ptr, colorspace, gAMA,

/*from gAMA*/

1.       {",Not Useful
/*not used*/,"-10.    return PNG_HEADER_VERSION_STRING
-9. #  ifndef PNG_READ_SUPPORTED
-8.       "" (NO READ SUPPORT)""
-7. #  endif
-6.       PNG_STRING_NEWLINE;
-5. #else
-4.    return PNG_HEADER_VERSION_STRING;
-3. #endif
-2. }
-1. #ifdef PNG_BUILD_GRAYSCALE_PALETTE_SUPPORTED

/*not used*/

 ",Not Useful
/*And fill in the png_XYZ:*/,"-4.    blue_scale = png_reciprocal(xy->whitey) - png_reciprocal(red_inverse) -
-3.        png_reciprocal(green_inverse);
-2.    if (blue_scale <= 0)
-1.       return 1;

/*And fill in the png_XYZ:*/

1.    if (png_muldiv(&XYZ->red_X, xy->redx, PNG_FP_1, red_inverse) == 0)
2.       return 1;
3.    if (png_muldiv(&XYZ->red_Y, xy->redy, PNG_FP_1, red_inverse) == 0)
4.       return 1;
5.    if (png_muldiv(&XYZ->red_Z, PNG_FP_1 - xy->redx - xy->redy, PNG_FP_1,
6.        red_inverse) == 0)
7.       return 1;
8.    if (png_muldiv(&XYZ->green_X, xy->greenx, PNG_FP_1, green_inverse) == 0)
9.       return 1;
10.    if (png_muldiv(&XYZ->green_Y, xy->greeny, PNG_FP_1, green_inverse) == 0)",Not Useful
"/*actually, the math is pretty accurate*/","-7.    result = png_XYZ_from_xy(XYZ, xy);
-6.    if (result != 0)
-5.       return result;
-4.    result = png_xy_from_XYZ(&xy_test, XYZ);
-3.    if (result != 0)
-2.       return result;
-1.    if (png_colorspace_endpoints_match(xy, &xy_test,

/*actually, the math is pretty accurate*/

1.       return 0;",Not Useful
/*Too much slip*/,"-1.       return 0;

/*Too much slip*/

1.    return 1;
2. }",Not Useful
/*From ITU-R BT.709-3*/,"-10.    result = png_XYZ_normalize(XYZ);
-9.    if (result != 0)
-8.       return result;
-7.    result = png_xy_from_XYZ(xy, XYZ);
-6.    if (result != 0)
-5.       return result;
-4.    XYZtemp = *XYZ;
-3.    return png_colorspace_check_xy(&XYZtemp, xy);
-2. }

/*From ITU-R BT.709-3*/

1. {",Not Useful
/*white*/,"-9. png_colorspace_set_gamma(png_const_structrp png_ptr,
-8.     png_colorspacerp colorspace, png_fixed_point gAMA)
-7. {
-6.    /* Changed in libpng-1.5.4 to limit the values to ensure overflow can't
-5.     * occur.  Since the fixed point representation is asymetrical it is
-4.     * possible for 1/gamma to overflow the limit of 21474 and this means the
-3.     * gamma value must be at least 5/100000 and hence at most 20000.0.  For
-2.     * safety the limits here are a little narrower.  The values are 0.00016 to
-1.     * 6250.0, which are truly ridiculous gamma values (and will produce
    * displays that are all black or all white.)

/*white*/

1.     *
2.     * In 1.6.0 this test replaces the ones in pngrutil.c, in the gAMA chunk
3.     * handling code, which only required the value to be >0.
4.     */
5.    png_const_charp errmsg;
6.    if (gAMA < 16 || gAMA > 625000000)
7.       errmsg = ""gamma value out of range"";
8. #  ifdef PNG_READ_gAMA_SUPPORTED",Not Useful
/*+2 = 90*/,"-4.    if (colorspace != NULL)
-3.       colorspace->flags |= PNG_COLORSPACE_INVALID;

/*+2 = 90*/

1.    if (is_ICC_signature(value) != 0)
2.    {",Not Useful
/*+24 = 114*/,"-6.       message[pos++] = ':';
-5.       message[pos++] = ' ';
-4.    }
-3. #  ifdef PNG_WARNINGS_SUPPORTED
-2.    else
-1.       {

/*+24 = 114*/

1.          pos = png_safecat(message, (sizeof message), pos,
2.              png_format_number(number, number+(sizeof number),
3.              PNG_NUMBER_FORMAT_x, value));",Not Useful
/*+2 = 116*/,"-3.          pos = png_safecat(message, (sizeof message), pos,
-2.              png_format_number(number, number+(sizeof number),
-1.              PNG_NUMBER_FORMAT_x, value));

/*+2 = 116*/

1.       }
2. #  endif",Not Useful
/*endpoints*/,"-10.       if (png_muldiv(&XYZ->blue_X, XYZ->blue_X, PNG_FP_1, Y) == 0)
-9.          return 1;
-8.       if (png_muldiv(&XYZ->blue_Y, XYZ->blue_Y, PNG_FP_1, Y) == 0)
-7.          return 1;
-6.       if (png_muldiv(&XYZ->blue_Z, XYZ->blue_Z, PNG_FP_1, Y) == 0)
-5.          return 1;
-4.    }
-3.    return 0;
-2. }
-1. static int
png_colorspace_endpoints_match(const png_xy *xy1, const png_xy *xy2, int delta)

/*endpoints*/

1. {",Not Useful
/*bool*/,"-2. static const png_byte D50_nCIEXYZ[12] =
-1.    { 0x00, 0x00, 0xf6, 0xd6, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0xd3, 0x2d };

/*bool*/

1. icc_check_length(png_const_structrp png_ptr, png_colorspacerp colorspace,
2.     png_const_charp name, png_uint_32 profile_length)
3. {
4.    if (profile_length < 132)
5.       return png_icc_profile_error(png_ptr, colorspace, name, profile_length,
6.           ""too short"");
7.    return 1;
8. }
9. #ifdef PNG_READ_iCCP_SUPPORTED",Not Useful
/*!SET_USER_LIMITS*/,"-10.     */
-9. #  ifdef PNG_SET_USER_LIMITS_SUPPORTED
-8.       else if (png_ptr->user_chunk_malloc_max > 0 &&
-7.                png_ptr->user_chunk_malloc_max < profile_length)
-6.          return png_icc_profile_error(png_ptr, colorspace, name, profile_length,
-5.              ""exceeds application limits"");
-4. #  elif PNG_USER_CHUNK_MALLOC_MAX > 0
-3.       else if (PNG_USER_CHUNK_MALLOC_MAX < profile_length)
-2.          return png_icc_profile_error(png_ptr, colorspace, name, profile_length,
-1.              ""exceeds libpng limits"");

/*!SET_USER_LIMITS*/

 ",Not Useful
/*!SET_USER_LIMITS*/,"-10.     */
-9. #  ifdef PNG_SET_USER_LIMITS_SUPPORTED
-8.       else if (png_ptr->user_chunk_malloc_max > 0 &&
-7.                png_ptr->user_chunk_malloc_max < profile_length)
-6.          return png_icc_profile_error(png_ptr, colorspace, name, profile_length,
-5.              ""exceeds application limits"");
-4. #  elif PNG_USER_CHUNK_MALLOC_MAX > 0
-3.       else if (PNG_USER_CHUNK_MALLOC_MAX < profile_length)
-2.          return png_icc_profile_error(png_ptr, colorspace, name, profile_length,
-1.              ""exceeds libpng limits"");

/*!SET_USER_LIMITS*/

 ",Not Useful
/*READ_iCCP*/,"-8. icc_check_length(png_const_structrp png_ptr, png_colorspacerp colorspace,
-7.     png_const_charp name, png_uint_32 profile_length)
-6. {
-5.    if (profile_length < 132)
-4.       return png_icc_profile_error(png_ptr, colorspace, name, profile_length,
-3.           ""too short"");
-2.    return 1;
-1. }
#ifdef PNG_READ_iCCP_SUPPORTED

/*READ_iCCP*/

 ",Not Useful
/*The ICC limit*/,"-1.    temp = png_get_uint_32(profile+64);

/*The ICC limit*/

1.       return png_icc_profile_error(png_ptr, colorspace, name, temp,
2.           ""invalid rendering intent"");",Not Useful
/*signature 'ascp'*/,"-10.     * been loaded; however, various header fields can be checked.  These checks
-9.     * are for values permitted by the PNG spec in an ICC profile; the PNG spec
-8.     * restricts the profiles that can be passed in an iCCP chunk (they must be
-7.     * appropriate to processing PNG data!)
-6.     */

/*signature 'ascp'*/

1.    if (temp != 0x61637370)
2.       return png_icc_profile_error(png_ptr, colorspace, name, temp,
3.           ""invalid signature"");",Not Useful
/*scnr'*/,"-10.          if ((color_type & PNG_COLOR_MASK_COLOR) != 0)
-9.             return png_icc_profile_error(png_ptr, colorspace, name, temp,
-8.                 ""Gray color space not permitted on RGB PNG"");
-7.          break;
-6.       default:
-5.          return png_icc_profile_error(png_ptr, colorspace, name, temp,
-4.              ""invalid ICC profile color space"");
-3.    }
-2.    /* It is up to the application to check that the profile class matches the
-1.     * application requirements; the spec provides no guidance, but it's pretty
    * weird if the profile is not scanner ('scnr'), monitor ('mntr'), printer

/*scnr'*/

1.     * ('prtr') or 'spac' (for generic color spaces).  Issue a warning in these
2.     * cases.  Issue an error for device link or abstract profiles - these don't
3.     * contain the records necessary to transform the color-space to anything
4.     * other than the target device (and not even that for an abstract profile).
5.     * Profiles of these classes may not be embedded in images.
6.     */",Not Useful
/*mntr'*/,"-10.          if ((color_type & PNG_COLOR_MASK_COLOR) != 0)
-9.             return png_icc_profile_error(png_ptr, colorspace, name, temp,
-8.                 ""Gray color space not permitted on RGB PNG"");
-7.          break;
-6.       default:
-5.          return png_icc_profile_error(png_ptr, colorspace, name, temp,
-4.              ""invalid ICC profile color space"");
-3.    }
-2.    /* It is up to the application to check that the profile class matches the
-1.     * application requirements; the spec provides no guidance, but it's pretty
    * weird if the profile is not scanner ('scnr'), monitor ('mntr'), printer

/*mntr'*/

1.     * ('prtr') or 'spac' (for generic color spaces).  Issue a warning in these
2.     * cases.  Issue an error for device link or abstract profiles - these don't
3.     * contain the records necessary to transform the color-space to anything
4.     * other than the target device (and not even that for an abstract profile).
5.     * Profiles of these classes may not be embedded in images.
6.     */",Not Useful
/*prtr'*/,"-10.             return png_icc_profile_error(png_ptr, colorspace, name, temp,
-9.                 ""Gray color space not permitted on RGB PNG"");
-8.          break;
-7.       default:
-6.          return png_icc_profile_error(png_ptr, colorspace, name, temp,
-5.              ""invalid ICC profile color space"");
-4.    }
-3.    /* It is up to the application to check that the profile class matches the
-2.     * application requirements; the spec provides no guidance, but it's pretty
-1.     * weird if the profile is not scanner ('scnr'), monitor ('mntr'), printer
    * ('prtr') or 'spac' (for generic color spaces).  Issue a warning in these

/*prtr'*/

1.     * cases.  Issue an error for device link or abstract profiles - these don't
2.     * contain the records necessary to transform the color-space to anything
3.     * other than the target device (and not even that for an abstract profile).
4.     * Profiles of these classes may not be embedded in images.
5.     */",Not Useful
/*All supported*/,"-6.    switch (temp)
-5.    {

/*All supported*/

1.          break;",Not Useful
/*abst'*/,"-1.          break;

/*abst'*/

 ",Not Useful
/*nmcl'*/,"-2.          return png_icc_profile_error(png_ptr, colorspace, name, temp,
-1.              ""unexpected DeviceLink ICC profile class"");

/*nmcl'*/

 ",Not Useful
/*XYZ '*/,"-3.    temp = png_get_uint_32(profile+20);
-2.    switch (temp)
-1.    {

/*XYZ '*/

 ",Not Useful
/*Lab '*/,"-4.    temp = png_get_uint_32(profile+20);
-3.    switch (temp)
-2.    {

/*Lab '*/

1.          break;
2.       default:
3.          return png_icc_profile_error(png_ptr, colorspace, name, temp,
4.              ""unexpected ICC PCS encoding"");
5.    }
6.    return 1;
7. }",Not Useful
/*broken*/,"-4.          colorspace->flags |= PNG_COLORSPACE_INVALID;
-3.          png_benign_error(png_ptr, ""invalid chromaticities"");
-2.          break;
-1.       default:
         /* libpng is broken; this should be a warning but if it happens we

/*broken*/

1.           * want error reports so for the moment it is an error.
2.           */
3.          colorspace->flags |= PNG_COLORSPACE_INVALID;
4.          png_error(png_ptr, ""internal error checking chromaticities"");
5.    }",Not Useful
/*broken*/,"-4.          colorspace->flags |= PNG_COLORSPACE_INVALID;
-3.          png_benign_error(png_ptr, ""invalid chromaticities"");
-2.          break;
-1.       default:
         /* libpng is broken; this should be a warning but if it happens we

/*broken*/

1.           * want error reports so for the moment it is an error.
2.           */
3.          colorspace->flags |= PNG_COLORSPACE_INVALID;
4.          png_error(png_ptr, ""internal error checking chromaticities"");
5.    }",Not Useful
/*no match*/,"-10.                      png_chunk_report(png_ptr,
-9.                          ""out-of-date sRGB profile with no signature"",
-8.                          PNG_CHUNK_WARNING);
-7.                   }
-6.                   return 1+png_sRGB_checks[i].is_broken;
-5.                }
-4.             }
-3. # if PNG_sRGB_PROFILE_CHECKS > 0
-2.          /* The signature matched, but the profile had been changed in some
-1.           * way.  This probably indicates a data error or uninformed hacking.
          * Fall through to ""no match"".

/*no match*/

1.           */
2.          png_chunk_report(png_ptr,
3.              ""Not recognizing known sRGB profile that has been edited"",
4.              PNG_CHUNK_WARNING);
5.          break;
6. # endif
7.          }
8.       }
9.    }",Not Useful
/*PNG_sRGB_PROFILE_CHECKS >= 0*/,"-2. }
-1. #ifdef PNG_sRGB_SUPPORTED
#if PNG_sRGB_PROFILE_CHECKS >= 0

/*PNG_sRGB_PROFILE_CHECKS >= 0*/

 ",Not Useful
/*sRGB*/,"-10. static int
-9. png_colorspace_check_gamma(png_const_structrp png_ptr,
-8.     png_colorspacerp colorspace, png_fixed_point gAMA, int from)
-7.    /* This is called to check a new gamma value against an existing one.  The
-6.     * routine returns false if the new gamma value should not be written.
-5.     *
-4.     * 'from' says where the new gamma value comes from:
-3.     *
-2.     *    0: the new gamma value is the libpng estimate for an ICC profile
-1.     *    1: the new gamma value comes from a gAMA chunk
    *    2: the new gamma value comes from an sRGB chunk

/*sRGB*/

1.     */
2. {
3.    png_fixed_point gtest;
4.    if ((colorspace->flags & PNG_COLORSPACE_HAVE_GAMMA) != 0 &&
5.        (png_muldiv(&gtest, colorspace->gamma, PNG_FP_1, gAMA) == 0  ||
6.       png_gamma_significant(gtest) != 0))
7.    {
8.       /* Either this is an sRGB image, in which case the calculated gamma
9.        * approximation should match, or this is an image with a profile and the
10.        * value libpng calculates for the gamma of the profile does not match the",Not Useful
/*iCCP*/,"-10.          {
-9.             int i;
-8.             for (i = 0; i < info_ptr->pcal_nparams; i++)
-7.                png_free(png_ptr, info_ptr->pcal_params[i]);
-6.             png_free(png_ptr, info_ptr->pcal_params);
-5.             info_ptr->pcal_params = NULL;
-4.          }
-3.       info_ptr->valid &= ~PNG_INFO_pCAL;
-2.    }
-1. #endif
#ifdef PNG_iCCP_SUPPORTED

/*iCCP*/

 ",Not Useful
/*big_row_buf hack*/,"-10.       png_warning(png_ptr, ""Image width is zero in IHDR"");
-9.       error = 1;
-8.    }
-7.    if (width > PNG_UINT_31_MAX)
-6.    {
-5.       png_warning(png_ptr, ""Invalid image width in IHDR"");
-4.       error = 1;
-3.    }
-2.    if (png_gt(((width + 7) & (~7U)),
-1.        ((PNG_SIZE_MAX

/*big_row_buf hack*/

 ",Not Useful
/*two dots*/,"-4.          png_fp_add(state, type);
-3.          break;
-2.       case PNG_FP_INTEGER + PNG_FP_SAW_DOT:

/*two dots*/

1.             goto PNG_FP_End;",Not Useful
/*trailing dot?*/,"-1.             goto PNG_FP_End;

/*trailing dot?*/

1.             png_fp_add(state, type);
2.          else
3.             png_fp_set(state, PNG_FP_FRACTION | type);
4.          break;
5.       case PNG_FP_INTEGER + PNG_FP_SAW_DIGIT:",Not Useful
"/*This is correct because the trailing '.' on an
          * integer is handled above - so we can only get here
          * with the sequence "".E"" (with no preceding digits).*/","-4.       case PNG_FP_FRACTION + PNG_FP_SAW_DIGIT:
-3.          png_fp_add(state, type | PNG_FP_WAS_VALID);
-2.          break;
-1.       case PNG_FP_FRACTION + PNG_FP_SAW_E:
         /* This is correct because the trailing '.' on an
          * integer is handled above - so we can only get here
          * with the sequence "".E"" (with no preceding digits).

/*This is correct because the trailing '.' on an
          * integer is handled above - so we can only get here
          * with the sequence "".E"" (with no preceding digits).*/

1.           */
2.          if ((state & PNG_FP_SAW_DIGIT) == 0)
3.             goto PNG_FP_End;
4.          png_fp_set(state, PNG_FP_EXPONENT);
5.          break;
6.       case PNG_FP_EXPONENT + PNG_FP_SAW_SIGN:
7.          if ((state & PNG_FP_SAW_ANY) != 0)",Not Useful
/*must be non-zero - see above*/,"-7. int
-6. png_check_fp_string(png_const_charp string, png_size_t size)
-5. {
-4.    int        state=0;
-3.    png_size_t char_index=0;
-2.    if (png_check_fp_number(string, size, &state, &char_index) != 0 &&
-1.       (char_index == size || string[char_index] == 0))

/*must be non-zero - see above*/

 ",Not Useful
/*pCAL || sCAL*/,"-1. }

/*pCAL || sCAL*/

1. #ifdef PNG_sCAL_SUPPORTED
2. #  ifdef PNG_FLOATING_POINT_SUPPORTED",Not Useful
"/*Function to format a floating point value in ASCII with a given
 * precision.*/","-2.    return d;
-1. }
/* Function to format a floating point value in ASCII with a given
 * precision.

/*Function to format a floating point value in ASCII with a given
 * precision.*/

1.  */
2. #if GCC_STRICT_OVERFLOW
3. #pragma GCC diagnostic push",Not Useful
/*See the requirements below.*/,"-3.    if (precision > DBL_DIG+1)
-2.       precision = DBL_DIG+1;

/*See the requirements below.*/

1.    {
2.       if (fp < 0)
3.       {
4.          fp = -fp;",Not Useful
/*10^exp_b10*/,"-5.          --size;
-4.       }
-3.       if (fp >= DBL_MIN && fp <= DBL_MAX)
-2.       {

/*10^exp_b10*/

 ",Not Useful
/*Avoid underflow here.*/,"-10.           * the calculation below rounds down when converting
-9.           * from base 2 to base 10 (multiply by log10(2) -
-8.           * 0.3010, but 77/256 is 0.3008, so exp_b10 needs to
-7.           * be increased.  Note that the arithmetic shift
-6.           * performs a floor() unlike C arithmetic - using a
-5.           * C multiply would break the following for negative
-4.           * exponents.
-3.           */

/*Avoid underflow here.*/

 ",Not Useful
/*May underflow*/,"-10.           * from base 2 to base 10 (multiply by log10(2) -
-9.           * 0.3010, but 77/256 is 0.3008, so exp_b10 needs to
-8.           * be increased.  Note that the arithmetic shift
-7.           * performs a floor() unlike C arithmetic - using a
-6.           * C multiply would break the following for negative
-5.           * exponents.
-4.           */

/*May underflow*/

1.          while (base < DBL_MIN || base < fp)
2.          {",Not Useful
/*I.e. 1+(ch-48)*/,"-3.                               exp_b10 = 1;
-2.                            }
-1.                            --cdigits;

/*I.e. 1+(ch-48)*/

1.                         }",Not Useful
/*cdigits == 0*/,"-3.                      if (czero > 0)
-2.                      {
-1.                         --czero; d = 1;
                        if (cdigits == 0) --clead;

/*cdigits == 0*/

1.                      }
2.                      else
3.                      {
4.                         while (cdigits > 0 && d > 9)
5.                         {
6.                            int ch = *--ascii;
7.                            if (exp_b10 != (-1))
8.                               ++exp_b10;
9.                            else if (ch == 46)
10.                            {",Not Useful
/*0'*/,"-10.             if (size > cdigits)
-9.             {
-8.                while (cdigits > 0) *ascii++ = exponent[--cdigits];
-7.                *ascii = 0;
-6.                return;
-5.             }
-4.          }
-3.       }
-2.       else if (!(fp >= DBL_MIN))
-1.       {

/*0'*/

1.          *ascii = 0;
2.          return;
3.       }
4.       else
5.       {",Not Useful
/*i'*/,"-5.          *ascii = 0;
-4.          return;
-3.       }
-2.       else
-1.       {

/*i'*/

 ",Not Useful
/*n'*/,"-6.          *ascii = 0;
-5.          return;
-4.       }
-3.       else
-2.       {

/*n'*/

 ",Not Useful
/*f'*/,"-7.          *ascii = 0;
-6.          return;
-5.       }
-4.       else
-3.       {

/*f'*/

1.          *ascii = 0;
2.          return;
3.       }
4.    }",Not Useful
/*FLOATING_POINT*/,"-1. #ifdef PNG_sCAL_SUPPORTED
#  ifdef PNG_FLOATING_POINT_SUPPORTED

/*FLOATING_POINT*/

 ",Not Useful
/*Avoid overflow here on the minimum integer.*/,"-3.    if (size > 12)
-2.    {
-1.       png_uint_32 num;

/*Avoid overflow here on the minimum integer.*/

1.       if (fp < 0)
2.       {
3.          *ascii++ = 45; num = (png_uint_32)(-fp);
4.       }
5.       else
6.          num = (png_uint_32)fp;",Not Useful
/*FIXED_POINT*/,"
#  ifdef PNG_FIXED_POINT_SUPPORTED



/*FIXED_POINT*/

 ",Not Useful
/*SCAL*/,"if (((mask & PNG_FREE_SCAL) & info_ptr->free_me) != 0)

/*SCAL*/

1.    {
2.       png_free(png_ptr, info_ptr->scal_s_width);
3.       png_free(png_ptr, info_ptr->scal_s_height);
4.       info_ptr->scal_s_width = NULL;
5.       info_ptr->scal_s_height = NULL;
6.       info_ptr->valid &= ~PNG_INFO_sCAL;
7.    }
8. #endif
9. #ifdef PNG_pCAL_SUPPORTED",Not Useful
/*from above*/,"-10. }
-9. #endif
-8. #if defined(PNG_GAMMA_SUPPORTED) || defined(PNG_COLORSPACE_SUPPORTED) ||\
-7.     defined(PNG_INCH_CONVERSIONS_SUPPORTED) || defined(PNG_READ_pHYs_SUPPORTED)

/*from above*/

 ",Not Useful
/*READ_GAMMA || INCH_CONVERSIONS*/,"-10.             }
-9.          }
-8. #endif
-7.       }
-6.    }
-5.    return 0;
-4. }
-3. #if GCC_STRICT_OVERFLOW
-2. #pragma GCC diagnostic pop

/*READ_GAMMA || INCH_CONVERSIONS*/

1. #if defined(PNG_READ_GAMMA_SUPPORTED) || defined(PNG_INCH_CONVERSIONS_SUPPORTED)",Not Useful
/*error/overflow*/,"-10. {
-9. #ifdef PNG_FLOATING_ARITHMETIC_SUPPORTED
-8.    double r = floor(1E10/a+.5);
-7.    if (r <= 2147483647. && r >= -2147483648.)
-6.       return (png_fixed_point)r;
-5. #else
-4.    png_fixed_point res;
-3.    if (png_muldiv(&res, 100000, 100000, a) != 0)
-2.       return res;
-1. #endif

/*error/overflow*/

1. }",Not Useful
/*A local convenience routine.*/,"-8. png_gamma_significant(png_fixed_point gamma_val)
-7. {
-6.    return gamma_val < PNG_FP_1 - PNG_GAMMA_THRESHOLD_FIXED ||
-5.        gamma_val > PNG_FP_1 + PNG_GAMMA_THRESHOLD_FIXED;
-4. }
-3. #endif
-2. #ifdef PNG_READ_GAMMA_SUPPORTED
-1. #ifdef PNG_16BIT_SUPPORTED

/*A local convenience routine.*/

1. static png_fixed_point
2. png_product2(png_fixed_point a, png_fixed_point b)
3. {",Not Useful
/*16BIT*/,"-7. png_gamma_significant(png_fixed_point gamma_val)
-6. {
-5.    return gamma_val < PNG_FP_1 - PNG_GAMMA_THRESHOLD_FIXED ||
-4.        gamma_val > PNG_FP_1 + PNG_GAMMA_THRESHOLD_FIXED;
-3. }
-2. #endif
-1. #ifdef PNG_READ_GAMMA_SUPPORTED
#ifdef PNG_16BIT_SUPPORTED

/*16BIT*/

 ",Not Useful
/*<= '257'*/,"-1.    x -= 1U << 24;

/*<= '257'*/

1.       lg2 += ((23591U * (65536U-x)) + (1U << (16+6-12-1))) >> (16+6-12);
2.    else
3.       lg2 -= ((23499U * (x-65536U)) + (1U << (16+6-12-1))) >> (16+6-12);",Not Useful
/*16BIT*/,"-7. png_gamma_significant(png_fixed_point gamma_val)
-6. {
-5.    return gamma_val < PNG_FP_1 - PNG_GAMMA_THRESHOLD_FIXED ||
-4.        gamma_val > PNG_FP_1 + PNG_GAMMA_THRESHOLD_FIXED;
-3. }
-2. #endif
-1. #ifdef PNG_READ_GAMMA_SUPPORTED
#ifdef PNG_16BIT_SUPPORTED

/*16BIT*/

 ",Not Useful
/*16BIT*/,"-7. png_gamma_significant(png_fixed_point gamma_val)
-6. {
-5.    return gamma_val < PNG_FP_1 - PNG_GAMMA_THRESHOLD_FIXED ||
-4.        gamma_val > PNG_FP_1 + PNG_GAMMA_THRESHOLD_FIXED;
-3. }
-2. #endif
-1. #ifdef PNG_READ_GAMMA_SUPPORTED
#ifdef PNG_16BIT_SUPPORTED

/*16BIT*/

 ",Not Useful
/*FLOATING_ARITHMETIC*/,"-6. #if defined(PNG_FLOATING_POINT_SUPPORTED) && \
-5.    !defined(PNG_FIXED_POINT_MACRO_SUPPORTED) && \
-4.    (defined(PNG_gAMA_SUPPORTED) || defined(PNG_cHRM_SUPPORTED) || \
-3.    defined(PNG_sCAL_SUPPORTED) || defined(PNG_READ_BACKGROUND_SUPPORTED) || \
-2.    defined(PNG_READ_RGB_TO_GRAY_SUPPORTED)) || \
-1.    (defined(PNG_sCAL_SUPPORTED) && \
   defined(PNG_FLOATING_ARITHMETIC_SUPPORTED))

/*FLOATING_ARITHMETIC*/

1. png_fixed_point
2. png_fixed(png_const_structrp png_ptr, double fp, png_const_charp text)
3. {
4.    double r = floor(100000 * fp + .5);
5.    if (r > 2147483647. || r < -2147483648.)
6.       png_fixed_error(png_ptr, text);
7. #  ifndef PNG_ERROR_TEXT_SUPPORTED
8.    PNG_UNUSED(text)
9. #  endif
10.    return (png_fixed_point)r;",Not Useful
/*SAFE*/,"-10.           * We can be reasonably sure that an unsigned to float conversion
-9.           * won't be faster than an int to float one.  Therefore this code
-8.           * assumes responsibility for the undefined behavior, which it knows
-7.           * can't happen because of the check above.
-6.           *
-5.           * Note the argument to this routine is an (unsigned int) because, on
-4.           * 16-bit platforms, it is assigned a value which might be out of
-3.           * range for an (int); that would result in undefined behavior in the
-2.           * caller if the *argument* ('value') were to be declared (int).
-1.           */

/*SAFE*/

1.          return (png_byte)r;
2. #     else
3.          png_int_32 lg2 = png_log8bit(value);
4.          png_fixed_point res;
5.          if (png_muldiv(&res, gamma_val, lg2, PNG_FP_1) != 0)
6.             return png_exp8bit(res);",Not Useful
"/*The same (unsigned int)->(double) constraints apply here as above,
       * however in this case the (unsigned int) to (int) conversion can
       * overflow on an ANSI-C90 compliant system so the cast needs to ensure
       * that this is not possible.*/","-10.    }
-9.    return (png_byte)(value & 0xff);
-8. }
-7. #ifdef PNG_16BIT_SUPPORTED
-6. png_uint_16
-5. png_gamma_16bit_correct(unsigned int value, png_fixed_point gamma_val)
-4. {
-3.    if (value > 0 && value < 65535)
-2.    {
-1. # ifdef PNG_FLOATING_ARITHMETIC_SUPPORTED
      /* The same (unsigned int)->(double) constraints apply here as above,
       * however in this case the (unsigned int) to (int) conversion can
       * overflow on an ANSI-C90 compliant system so the cast needs to ensure
       * that this is not possible.

/*The same (unsigned int)->(double) constraints apply here as above,
       * however in this case the (unsigned int) to (int) conversion can
       * overflow on an ANSI-C90 compliant system so the cast needs to ensure
       * that this is not possible.*/

1.        */
2.       double r = floor(65535*pow((png_int_32)value/65535.,
3.           gamma_val*.00001)+.5);
4.       return (png_uint_16)r;
5. # else
6.       png_int_32 lg2 = png_log16bit(value);
7.       png_fixed_point res;
8.       if (png_muldiv(&res, gamma_val, lg2, PNG_FP_1) != 0)
9.          return png_exp16bit(res);",Not Useful
/*16BIT*/,"-7. png_gamma_significant(png_fixed_point gamma_val)
-6. {
-5.    return gamma_val < PNG_FP_1 - PNG_GAMMA_THRESHOLD_FIXED ||
-4.        gamma_val > PNG_FP_1 + PNG_GAMMA_THRESHOLD_FIXED;
-3. }
-2. #endif
-1. #ifdef PNG_READ_GAMMA_SUPPORTED
#ifdef PNG_16BIT_SUPPORTED

/*16BIT*/

 ",Not Useful
/*should not reach this*/,"-9. png_gamma_correct(png_structrp png_ptr, unsigned int value,
-8.     png_fixed_point gamma_val)
-7. {
-6.    if (png_ptr->bit_depth == 8)
-5.       return png_gamma_8bit_correct(value, gamma_val);
-4. #ifdef PNG_16BIT_SUPPORTED
-3.    else
-2.       return png_gamma_16bit_correct(value, gamma_val);
-1. #else

/*should not reach this*/

1.       return 0;",Not Useful
/*16BIT*/,"-7. png_gamma_significant(png_fixed_point gamma_val)
-6. {
-5.    return gamma_val < PNG_FP_1 - PNG_GAMMA_THRESHOLD_FIXED ||
-4.        gamma_val > PNG_FP_1 + PNG_GAMMA_THRESHOLD_FIXED;
-3. }
-2. #endif
-1. #ifdef PNG_READ_GAMMA_SUPPORTED
#ifdef PNG_16BIT_SUPPORTED

/*16BIT*/

 ",Not Useful
/*16BIT*/,"-7. png_gamma_significant(png_fixed_point gamma_val)
-6. {
-5.    return gamma_val < PNG_FP_1 - PNG_GAMMA_THRESHOLD_FIXED ||
-4.        gamma_val > PNG_FP_1 + PNG_GAMMA_THRESHOLD_FIXED;
-3. }
-2. #endif
-1. #ifdef PNG_READ_GAMMA_SUPPORTED
#ifdef PNG_16BIT_SUPPORTED

/*16BIT*/

 ",Not Useful
/*16BIT*/,"-7. png_gamma_significant(png_fixed_point gamma_val)
-6. {
-5.    return gamma_val < PNG_FP_1 - PNG_GAMMA_THRESHOLD_FIXED ||
-4.        gamma_val > PNG_FP_1 + PNG_GAMMA_THRESHOLD_FIXED;
-3. }
-2. #endif
-1. #ifdef PNG_READ_GAMMA_SUPPORTED
#ifdef PNG_16BIT_SUPPORTED

/*16BIT*/

 ",Not Useful
/*16BIT*/,"-7. png_gamma_significant(png_fixed_point gamma_val)
-6. {
-5.    return gamma_val < PNG_FP_1 - PNG_GAMMA_THRESHOLD_FIXED ||
-4.        gamma_val > PNG_FP_1 + PNG_GAMMA_THRESHOLD_FIXED;
-3. }
-2. #endif
-1. #ifdef PNG_READ_GAMMA_SUPPORTED
#ifdef PNG_16BIT_SUPPORTED

/*16BIT*/

 ",Not Useful
/*Guarantees at least one table!*/,"-4.          if (shift < (16U - PNG_MAX_GAMMA_8))
-3.             shift = (16U - PNG_MAX_GAMMA_8);
-2.       }
-1.       if (shift > 8U)

/*Guarantees at least one table!*/

1.       png_ptr->gamma_shift = shift;",Not Useful
/*16BIT*/,"-7. png_gamma_significant(png_fixed_point gamma_val)
-6. {
-5.    return gamma_val < PNG_FP_1 - PNG_GAMMA_THRESHOLD_FIXED ||
-4.        gamma_val > PNG_FP_1 + PNG_GAMMA_THRESHOLD_FIXED;
-3. }
-2. #endif
-1. #ifdef PNG_READ_GAMMA_SUPPORTED
#ifdef PNG_16BIT_SUPPORTED

/*16BIT*/

 ",Not Useful
/*SIMPLIFIED_READ*/,"
#if defined(PNG_SIMPLIFIED_READ_SUPPORTED) ||\



/*SIMPLIFIED_READ*/

1.    defined(PNG_SIMPLIFIED_WRITE_SUPPORTED)
2. /* sRGB conversion tables; these are machine generated with the code in
3.  * contrib/tools/makesRGB.c.  The actual sRGB transfer curve defined in the",Not Useful
/*SIMPLIFIED READ/WRITE SUPPORT*/,"-10.    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
-9.    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
-8.    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
-7.    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
-6.    8,8,8,8,8,8,8,8,8,7,7,7,7,7,7,7,
-5.    7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
-4.    7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
-3.    7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7
-2. };

/*SIMPLIFIED READ/WRITE SUPPORT*/

1. #if defined(PNG_SIMPLIFIED_READ_SUPPORTED) ||\
2.    defined(PNG_SIMPLIFIED_WRITE_SUPPORTED)
3. static int
4. png_image_free_function(png_voidp argument)
5. {
6.    png_imagep image = png_voidcast(png_imagep, argument);
7.    png_controlp cp = image->opaque;
8.    png_control c;
9.    /* Double check that we have a png_ptr - it should be impossible to get here
10.     * without one.",Not Useful
/*SIMPLIFIED READ/WRITE*/,"-10.    9,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
-9.    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
-8.    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
-7.    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
-6.    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
-5.    8,8,8,8,8,8,8,8,8,7,7,7,7,7,7,7,
-4.    7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
-3.    7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
-2.    7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7
-1. };

/*SIMPLIFIED READ/WRITE*/

 ",Not Useful
/*FALLTHROUGH*/,"-2.          png_warning(png_ptr,
-1.              ""Can't discard critical data on CRC error"");

/*FALLTHROUGH*/

 ",Not Useful
/*Error/quit*/,"-3.          png_warning(png_ptr,
-2.              ""Can't discard critical data on CRC error"");

/*Error/quit*/

1.       case PNG_CRC_DEFAULT:
2.       default:
3.          png_ptr->flags &= ~PNG_FLAG_CRC_CRITICAL_MASK;
4.          break;
5.    }",Not Useful
/*Error/quit*/,"-3.          png_warning(png_ptr,
-2.              ""Can't discard critical data on CRC error"");

/*Error/quit*/

1.       case PNG_CRC_DEFAULT:
2.       default:
3.          png_ptr->flags &= ~PNG_FLAG_CRC_CRITICAL_MASK;
4.          break;
5.    }",Not Useful
/*Ok*/,"-1.          png_ptr->flags |= PNG_FLAG_DETECT_UNINITIALIZED;

/*Ok*/

1.       }
2.    }",Not Useful
/*no png_error possible!*/,"-2.       }
-1.    }

/*no png_error possible!*/

1. }
2. #endif
3. #ifdef PNG_READ_BACKGROUND_SUPPORTED",Not Useful
/*FLOATING_POINT*/,"-10.    png_ptr->transformations &= ~PNG_ENCODE_ALPHA;
-9.    png_ptr->flags &= ~PNG_FLAG_OPTIMIZE_ALPHA;
-8.    png_ptr->background = *background_color;
-7.    png_ptr->background_gamma = background_gamma;
-6.    png_ptr->background_gamma_type = (png_byte)(background_gamma_code);
-5.    if (need_expand != 0)
-4.       png_ptr->transformations |= PNG_BACKGROUND_EXPAND;
-3.    else
-2.       png_ptr->transformations &= ~PNG_BACKGROUND_EXPAND;
-1. }
#  ifdef PNG_FLOATING_POINT_SUPPORTED

/*FLOATING_POINT*/

1. void PNGAPI
2. png_set_background(png_structrp png_ptr,
3.     png_const_color_16p background_color, int background_gamma_code,
4.     int need_expand, double background_gamma)
5. {
6.    png_set_background_fixed(png_ptr, background_color, background_gamma_code,
7.       need_expand, png_fixed(png_ptr, background_gamma, ""png_set_background""));
8. }",Not Useful
/*Chop 16-bit depth files to 8-bit depth*/,"-10. void PNGAPI
-9. png_set_scale_16(png_structrp png_ptr)
-8. {
-7.    png_debug(1, ""in png_set_scale_16"");
-6.    if (png_rtran_ok(png_ptr, 0) == 0)
-5.       return;
-4.    png_ptr->transformations |= PNG_SCALE_16_TO_8;
-3. }
-2. #endif
-1. #ifdef PNG_READ_STRIP_16_TO_8_SUPPORTED

/*Chop 16-bit depth files to 8-bit depth*/

1. void PNGAPI
2. png_set_strip_16(png_structrp png_ptr)
3. {
4.    png_debug(1, ""in png_set_strip_16"");
5.    if (png_rtran_ok(png_ptr, 0) == 0)
6.       return;
7.    png_ptr->transformations |= PNG_16_TO_8;
8. }
9. #endif
10. #ifdef PNG_READ_STRIP_ALPHA_SUPPORTED",Not Useful
/*This preserves -1 and -2 exactly:*/,"-2.    if (output_gamma > 0 && output_gamma < 128)
-1.       output_gamma *= PNG_FP_1;

/*This preserves -1 and -2 exactly:*/

1.    output_gamma = floor(output_gamma + .5);
2.    if (output_gamma > PNG_FP_MAX || output_gamma < PNG_FP_MIN)
3.       png_fixed_error(png_ptr, ""gamma value"");
4.    return (png_fixed_point)output_gamma;
5. }
6. #  endif",Not Useful
/*Initialize the quantize_sort array*/,"-2.          png_ptr->quantize_sort = (png_bytep)png_malloc(png_ptr,
-1.              (png_alloc_size_t)((png_uint_32)num_palette * (sizeof (png_byte))));

/*Initialize the quantize_sort array*/

1.          for (i = 0; i < num_palette; i++)
2.             png_ptr->quantize_sort[i] = (png_byte)i;",Not Useful
/*int dr = abs(ir - r);*/,"-10.           (sizeof (png_byte))));
-9.       memset(distance, 0xff, num_entries * (sizeof (png_byte)));
-8.       for (i = 0; i < num_palette; i++)
-7.       {
-6.          int ir, ig, ib;
-5.          int r = (palette[i].red >> (8 - PNG_QUANTIZE_RED_BITS));
-4.          int g = (palette[i].green >> (8 - PNG_QUANTIZE_GREEN_BITS));
-3.          int b = (palette[i].blue >> (8 - PNG_QUANTIZE_BLUE_BITS));
-2.          for (ir = 0; ir < num_red; ir++)
-1.          {

/*int dr = abs(ir - r);*/

1.             int dr = ((ir > r) ? ir - r : r - ir);
2.             int index_r = (ir << (PNG_QUANTIZE_BLUE_BITS +
3.                 PNG_QUANTIZE_GREEN_BITS));
4.             for (ig = 0; ig < num_green; ig++)
5.             {",Not Useful
/*int dg = abs(ig - g);*/,"-5.             int dr = ((ir > r) ? ir - r : r - ir);
-4.             int index_r = (ir << (PNG_QUANTIZE_BLUE_BITS +
-3.                 PNG_QUANTIZE_GREEN_BITS));
-2.             for (ig = 0; ig < num_green; ig++)
-1.             {

/*int dg = abs(ig - g);*/

1.                int dg = ((ig > g) ? ig - g : g - ig);
2.                int dt = dr + dg;
3.                int dm = ((dr > dg) ? dr : dg);
4.                int index_g = index_r | (ig << PNG_QUANTIZE_BLUE_BITS);
5.                for (ib = 0; ib < num_blue; ib++)
6.                {
7.                   int d_index = index_g | ib;",Not Useful
/*int db = abs(ib - b);*/,"-7.                int dg = ((ig > g) ? ig - g : g - ig);
-6.                int dt = dr + dg;
-5.                int dm = ((dr > dg) ? dr : dg);
-4.                int index_g = index_r | (ig << PNG_QUANTIZE_BLUE_BITS);
-3.                for (ib = 0; ib < num_blue; ib++)
-2.                {
-1.                   int d_index = index_g | ib;

/*int db = abs(ib - b);*/

1.                   int db = ((ib > b) ? ib - b : b - ib);
2.                   int dmax = ((dm > db) ? dm : db);
3.                   int d = dmax + dt + db;
4.                   if (d < (int)distance[d_index])
5.                   {
6.                      distance[d_index] = (png_byte)d;
7.                      png_ptr->palette_lookup[d_index] = (png_byte)i;
8.                   }
9.                }
10.             }",Not Useful
/*READ_QUANTIZE*/,"-10. }
-9. #  ifdef PNG_FLOATING_POINT_SUPPORTED
-8. void PNGAPI
-7. png_set_alpha_mode(png_structrp png_ptr, int mode, double output_gamma)
-6. {
-5.    png_set_alpha_mode_fixed(png_ptr, mode, convert_gamma_value(png_ptr,
-4.        output_gamma));
-3. }
-2. #  endif
-1. #endif
#ifdef PNG_READ_QUANTIZE_SUPPORTED

/*READ_QUANTIZE*/

 ",Not Useful
/*file*/,"-10.  *
-9.  * Last changed in libpng 1.6.33 [September 28, 2017]
-8.  * Copyright (c) 1998-2002,2004,2006-2017 Glenn Randers-Pehrson
-7.  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
-6.  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
-5.  *
-4.  * This code is released under the libpng license.
-3.  * For conditions of distribution and use, see the disclaimer
-2.  * and license in png.h
-1.  *
 * This file contains functions optionally called by an application

/*file*/

1.  * in order to tell libpng how to handle data when reading a PNG.
2.  * Transformations that are used in both reading and writing are
3.  * in pngtrans.c.
4.  */
5. #include ""pngpriv.h""
6. #ifdef PNG_READ_SUPPORTED",Not Useful
/*FLOATING_POINT*/,"-10.    png_ptr->transformations &= ~PNG_ENCODE_ALPHA;
-9.    png_ptr->flags &= ~PNG_FLAG_OPTIMIZE_ALPHA;
-8.    png_ptr->background = *background_color;
-7.    png_ptr->background_gamma = background_gamma;
-6.    png_ptr->background_gamma_type = (png_byte)(background_gamma_code);
-5.    if (need_expand != 0)
-4.       png_ptr->transformations |= PNG_BACKGROUND_EXPAND;
-3.    else
-2.       png_ptr->transformations &= ~PNG_BACKGROUND_EXPAND;
-1. }
#  ifdef PNG_FLOATING_POINT_SUPPORTED

/*FLOATING_POINT*/

1. void PNGAPI
2. png_set_background(png_structrp png_ptr,
3.     png_const_color_16p background_color, int background_gamma_code,
4.     int need_expand, double background_gamma)
5. {
6.    png_set_background_fixed(png_ptr, background_color, background_gamma_code,
7.       need_expand, png_fixed(png_ptr, background_gamma, ""png_set_background""));
8. }",Not Useful
/*READ_EXPAND*/,"
#ifdef PNG_READ_EXPAND_SUPPORTED



/*READ_EXPAND*/

 ",Not Useful
/*READ_EXPAND && READ_BACKGROUND*/,"-2.       }

/*READ_EXPAND && READ_BACKGROUND*/

1. }",Not Useful
/*FALLTHROUGH*/,"-2.          png_warning(png_ptr,
-1.              ""Can't discard critical data on CRC error"");

/*FALLTHROUGH*/

 ",Not Useful
/*back_1*/,"png_color back, back_1;

/*back_1*/

1.             png_colorp palette = png_ptr->palette;
2.             int num_palette = png_ptr->num_palette;
3.             int i;
4.             if (png_ptr->background_gamma_type == PNG_BACKGROUND_GAMMA_FILE)
5.             {
6.                back.red = png_ptr->gamma_table[png_ptr->background.red];
7.                back.green = png_ptr->gamma_table[png_ptr->background.green];
8.                back.blue = png_ptr->gamma_table[png_ptr->background.blue];
9.                back_1.red = png_ptr->gamma_to_1[png_ptr->background.red];
10.                back_1.green = png_ptr->gamma_to_1[png_ptr->background.green];",Not Useful
/*back*/,"-3. }
-2. #endif
-1. #ifdef PNG_READ_BACKGROUND_SUPPORTED

/*back*/

1. void PNGFAPI
2. png_set_background_fixed(png_structrp png_ptr,
3.     png_const_color_16p background_color, int background_gamma_code,
4.     int need_expand, png_fixed_point background_gamma)
5. {
6.    png_debug(1, ""in png_set_background_fixed"");
7.    if (png_rtran_ok(png_ptr, 0) == 0 || background_color == NULL)
8.       return;
9.    if (background_gamma_code == PNG_BACKGROUND_GAMMA_UNKNOWN)
10.    {",Not Useful
/*if (png_ptr->trans_alpha[i] != 0xff)*/,"-10.             }
-9.             for (i = 0; i < num_palette; i++)
-8.             {
-7.                if (i < (int)png_ptr->num_trans &&
-6.                    png_ptr->trans_alpha[i] != 0xff)
-5.                {
-4.                   if (png_ptr->trans_alpha[i] == 0)
-3.                   {
-2.                      palette[i] = back;
-1.                   }

/*if (png_ptr->trans_alpha[i] != 0xff)*/

1.                   {
2.                      png_byte v, w;
3.                      v = png_ptr->gamma_to_1[palette[i].red];
4.                      png_composite(w, v, png_ptr->trans_alpha[i], back_1.red);
5.                      palette[i].red = png_ptr->gamma_from_1[w];
6.                      v = png_ptr->gamma_to_1[palette[i].green];
7.                      png_composite(w, v, png_ptr->trans_alpha[i], back_1.green);
8.                      palette[i].green = png_ptr->gamma_from_1[w];
9.                      v = png_ptr->gamma_to_1[palette[i].blue];
10.                      png_composite(w, v, png_ptr->trans_alpha[i], back_1.blue);",Not Useful
/*gs = PNG_FP_1;*/,"-10.                back_1.green = png_ptr->gamma_to_1[png_ptr->background.green];
-9.                back_1.blue = png_ptr->gamma_to_1[png_ptr->background.blue];
-8.             }
-7.             else
-6.             {
-5.                png_fixed_point g, gs;
-4.                switch (png_ptr->background_gamma_type)
-3.                {
-2.                   case PNG_BACKGROUND_GAMMA_SCREEN:
-1.                      g = (png_ptr->screen_gamma);
                     gs = PNG_FP_1;

/*gs = PNG_FP_1;*/

1.                      break;
2.                   case PNG_BACKGROUND_GAMMA_FILE:
3.                      g = png_reciprocal(png_ptr->colorspace.gamma);
4.                      gs = png_reciprocal2(png_ptr->colorspace.gamma,
5.                          png_ptr->screen_gamma);
6.                      break;
7.                   case PNG_BACKGROUND_GAMMA_UNIQUE:
8.                      g = png_reciprocal(png_ptr->background_gamma);
9.                      gs = png_reciprocal2(png_ptr->background_gamma,
10.                          png_ptr->screen_gamma);",Not Useful
/*RGB or RGBA with color background*/,"-10.             if (g_sig != 0)
-9.                png_ptr->background_1.gray = png_gamma_correct(png_ptr,
-8.                    png_ptr->background.gray, g);
-7.             if (gs_sig != 0)
-6.                png_ptr->background.gray = png_gamma_correct(png_ptr,
-5.                    png_ptr->background.gray, gs);
-4.             if ((png_ptr->background.red != png_ptr->background.green) ||
-3.                 (png_ptr->background.red != png_ptr->background.blue) ||
-2.                 (png_ptr->background.red != png_ptr->background.gray))
-1.             {

/*RGB or RGBA with color background*/

1.                if (g_sig != 0)
2.                {
3.                   png_ptr->background_1.red = png_gamma_correct(png_ptr,
4.                       png_ptr->background.red, g);
5.                   png_ptr->background_1.green = png_gamma_correct(png_ptr,
6.                       png_ptr->background.green, g);
7.                   png_ptr->background_1.blue = png_gamma_correct(png_ptr,
8.                       png_ptr->background.blue, g);
9.                }
10.                if (gs_sig != 0)",Not Useful
"/*GRAY, GRAY ALPHA, RGB, or RGBA with gray background*/","-10.                   png_ptr->background.red = png_gamma_correct(png_ptr,
-9.                       png_ptr->background.red, gs);
-8.                   png_ptr->background.green = png_gamma_correct(png_ptr,
-7.                       png_ptr->background.green, gs);
-6.                   png_ptr->background.blue = png_gamma_correct(png_ptr,
-5.                       png_ptr->background.blue, gs);
-4.                }
-3.             }
-2.             else
-1.             {

/*GRAY, GRAY ALPHA, RGB, or RGBA with gray background*/

1.                png_ptr->background_1.red = png_ptr->background_1.green
2.                    = png_ptr->background_1.blue = png_ptr->background_1.gray;
3.                png_ptr->background.red = png_ptr->background.green
4.                    = png_ptr->background.blue = png_ptr->background.gray;
5.             }",Not Useful
/*READ_SHIFT*/,"
#ifdef PNG_READ_SHIFT_SUPPORTED



/*READ_SHIFT*/

1.    if ((png_ptr->transformations & PNG_SHIFT) != 0 &&
2.        (png_ptr->transformations & PNG_EXPAND) == 0 &&
3.        (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE))
4.    {
5.       int i;
6.       int istop = png_ptr->num_palette;
7.       int shift = 8 - png_ptr->sig_bit.red;
8.       png_ptr->transformations &= ~PNG_SHIFT;
9.       /* significant bits can be in the range 1 to 7 for a meaninful result, if
10.        * the number of significant bits is 0 then no shift is done (this is an",Not Useful
/*PRIVATE*/,"-10.    png_ptr->read_user_transform_fn = read_user_transform_fn;
-9. #endif
-8. }
-7. #endif
-6. #ifdef PNG_READ_TRANSFORMS_SUPPORTED
-5. #ifdef PNG_READ_GAMMA_SUPPORTED

/*PRIVATE*/

1. png_gamma_threshold(png_fixed_point screen_gamma, png_fixed_point file_gamma)
2. {",Not Useful
/*!READ_16BIT*/,"-10.          png_ptr->transformations |= PNG_16_TO_8;
-9.          info_ptr->bit_depth = 8;
-8. #     else
-7. #        ifdef PNG_READ_SCALE_16_TO_8_SUPPORTED
-6.             png_ptr->transformations |= PNG_SCALE_16_TO_8;
-5.             info_ptr->bit_depth = 8;
-4. #        else
-3.             CONFIGURATION ERROR: you must enable at least one 16 to 8 method
-2. #        endif
-1. #    endif

/*!READ_16BIT*/

1.    }
2. #ifdef PNG_READ_GRAY_TO_RGB_SUPPORTED
3.    if ((png_ptr->transformations & PNG_GRAY_TO_RGB) != 0)
4.       info_ptr->color_type = (png_byte)(info_ptr->color_type |
5.          PNG_COLOR_MASK_COLOR);
6. #endif
7. #ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED
8.    if ((png_ptr->transformations & PNG_RGB_TO_GRAY) != 0)
9.       info_ptr->color_type = (png_byte)(info_ptr->color_type &
10.          ~PNG_COLOR_MASK_COLOR);",Not Useful
/*NOTREACHED*/,"-10.             else
-9.                have_shift = 1;
-8.          }
-7.          if (have_shift == 0)
-6.             return;
-5.       }
-4.       switch (bit_depth)
-3.       {
-2.          default:

/*NOTREACHED*/

1.             break;
2.          case 2:",Not Useful
/*source*/,"-2. #ifdef PNG_READ_GAMMA_SUPPORTED
-1.    /* Prior to 1.5.4 these tests were performed from png_set_gamma, 1.5.4 adds
    * png_set_alpha_mode and this is another source for a default file gamma so

/*source*/

1.     * the test needs to be performed later - here.  In addition prior to 1.5.4
2.     * the tests were repeated for the PALETTE color type here - this is no
3.     * longer necessary (and doesn't seem to have been necessary before.)
4.     */
5.    {",Not Useful
/*end+1*/,"-8. static void
-7. png_do_scale_16_to_8(png_row_infop row_info, png_bytep row)
-6. {
-5.    png_debug(1, ""in png_do_scale_16_to_8"");
-4.    if (row_info->bit_depth == 16)
-3.    {

/*end+1*/

1.       while (sp < ep)
2.       {
3.          /* The input is an array of 16-bit components, these must be scaled to
4.           * 8 bits each.  For a 16-bit value V the required value (from the PNG
5.           * specification) is:
6.           *
7.           *    (V * 255) / 65535
8.           *
9.           * This reduces to round(V / 257), or floor((V + 128.5)/257)
10.           *",Not Useful
/*source*/,"-2. #ifdef PNG_READ_GAMMA_SUPPORTED
-1.    /* Prior to 1.5.4 these tests were performed from png_set_gamma, 1.5.4 adds
    * png_set_alpha_mode and this is another source for a default file gamma so

/*source*/

1.     * the test needs to be performed later - here.  In addition prior to 1.5.4
2.     * the tests were repeated for the PALETTE color type here - this is no
3.     * longer necessary (and doesn't seem to have been necessary before.)
4.     */
5.    {",Not Useful
/*destination*/,"-7. static void
-6. png_do_scale_16_to_8(png_row_infop row_info, png_bytep row)
-5. {
-4.    png_debug(1, ""in png_do_scale_16_to_8"");
-3.    if (row_info->bit_depth == 16)
-2.    {

/*destination*/

 ",Not Useful
/*end+1*/,"-8. static void
-7. png_do_scale_16_to_8(png_row_infop row_info, png_bytep row)
-6. {
-5.    png_debug(1, ""in png_do_scale_16_to_8"");
-4.    if (row_info->bit_depth == 16)
-3.    {

/*end+1*/

1.       while (sp < ep)
2.       {
3.          /* The input is an array of 16-bit components, these must be scaled to
4.           * 8 bits each.  For a 16-bit value V the required value (from the PNG
5.           * specification) is:
6.           *
7.           *    (V * 255) / 65535
8.           *
9.           * This reduces to round(V / 257), or floor((V + 128.5)/257)
10.           *",Not Useful
"/**(--dp) = *(--sp);
            *(--dp) = *(--sp);*/","-9.          if (row_info->bit_depth == 8)
-8.          {
-7.             png_bytep sp = row + row_info->rowbytes;
-6.             png_bytep dp = sp;
-5.             png_byte save;
-4.             png_uint_32 i;
-3.             for (i = 0; i < row_width; i++)
-2.             {
-1.                save = *(--sp);
               *(--dp) = *(--sp);

/**(--dp) = *(--sp);
            *(--dp) = *(--sp);*/

1.                *(--dp) = *(--sp);
2.                *(--dp) = *(--sp);
3.                *(--dp) = save;
4.             }
5.          }
6. #ifdef PNG_READ_16BIT_SUPPORTED",Not Useful
/*RGB bit_depth == 16*/,"-10.                    */
-9.                   *(dp++) = (png_byte)((rc*red + gc*green + bc*blue)>>15);
-8.                }
-7.                else
-6.                   *(dp++) = red;
-5.                if (have_alpha != 0)
-4.                   *(dp++) = *(sp++);
-3.             }
-2.          }
-1.       }

/*RGB bit_depth == 16*/

1.       {
2. #ifdef PNG_READ_GAMMA_SUPPORTED
3.          if (png_ptr->gamma_16_to_1 != NULL && png_ptr->gamma_16_from_1 != NULL)
4.          {
5.             png_bytep sp = row;
6.             png_bytep dp = row;
7.             png_uint_32 i;
8.             for (i = 0; i < row_width; i++)
9.             {
10.                png_uint_16 red, green, blue, w;",Not Useful
/*if (row_info->bit_depth == 16)*/,"-4. static void
-3. png_do_scale_16_to_8(png_row_infop row_info, png_bytep row)
-2. {
-1.    png_debug(1, ""in png_do_scale_16_to_8"");
   if (row_info->bit_depth == 16)

/*if (row_info->bit_depth == 16)*/

1.    {",Not Useful
/*if (png_ptr->bit_depth == 16)*/,"-10.                   for (i = 0; i < row_width; i++, sp += 2)
-9.                   {
-8.                      png_byte a = *(sp + 1);
-7.                      if (a == 0)
-6.                         *sp = (png_byte)png_ptr->background.gray;
-5.                      else if (a < 0xff)
-4.                         png_composite(*sp, *sp, a, png_ptr->background.gray);
-3.                   }
-2.                }
-1.             }

/*if (png_ptr->bit_depth == 16)*/

1.             {
2. #ifdef PNG_READ_GAMMA_SUPPORTED
3.                if (gamma_16 != NULL && gamma_16_from_1 != NULL &&
4.                    gamma_16_to_1 != NULL)
5.                {
6.                   sp = row;
7.                   for (i = 0; i < row_width; i++, sp += 4)
8.                   {
9.                      png_uint_16 a = (png_uint_16)(((*(sp + 2)) << 8)
10.                          + *(sp + 3));",Not Useful
/*if (row_info->bit_depth == 16)*/,"-4. static void
-3. png_do_scale_16_to_8(png_row_infop row_info, png_bytep row)
-2. {
-1.    png_debug(1, ""in png_do_scale_16_to_8"");
   if (row_info->bit_depth == 16)

/*if (row_info->bit_depth == 16)*/

1.    {",Not Useful
/*if (row_info->bit_depth == 16)*/,"-4. static void
-3. png_do_scale_16_to_8(png_row_infop row_info, png_bytep row)
-2. {
-1.    png_debug(1, ""in png_do_scale_16_to_8"");
   if (row_info->bit_depth == 16)

/*if (row_info->bit_depth == 16)*/

1.    {",Not Useful
/*if (row_info->bit_depth == 16)*/,"-4. static void
-3. png_do_scale_16_to_8(png_row_infop row_info, png_bytep row)
-2. {
-1.    png_debug(1, ""in png_do_scale_16_to_8"");
   if (row_info->bit_depth == 16)

/*if (row_info->bit_depth == 16)*/

1.    {",Not Useful
/*if (row_info->bit_depth == 16)*/,"-4. static void
-3. png_do_scale_16_to_8(png_row_infop row_info, png_bytep row)
-2. {
-1.    png_debug(1, ""in png_do_scale_16_to_8"");
   if (row_info->bit_depth == 16)

/*if (row_info->bit_depth == 16)*/

1.    {",Not Useful
/*READ_QUANTIZE*/,"-10. }
-9. #  ifdef PNG_FLOATING_POINT_SUPPORTED
-8. void PNGAPI
-7. png_set_alpha_mode(png_structrp png_ptr, int mode, double output_gamma)
-6. {
-5.    png_set_alpha_mode_fixed(png_ptr, mode, convert_gamma_value(png_ptr,
-4.        output_gamma));
-3. }
-2. #  endif
-1. #endif
#ifdef PNG_READ_QUANTIZE_SUPPORTED

/*READ_QUANTIZE*/

 ",Not Useful
/*READ_QUANTIZE*/,"-10. }
-9. #  ifdef PNG_FLOATING_POINT_SUPPORTED
-8. void PNGAPI
-7. png_set_alpha_mode(png_structrp png_ptr, int mode, double output_gamma)
-6. {
-5.    png_set_alpha_mode_fixed(png_ptr, mode, convert_gamma_value(png_ptr,
-4.        output_gamma));
-3. }
-2. #  endif
-1. #endif
#ifdef PNG_READ_QUANTIZE_SUPPORTED

/*READ_QUANTIZE*/

 ",Not Useful
/*png_ptr*/,"-1. void PNGAPI
png_set_crc_action(png_structrp png_ptr, int crit_action, int ancil_action)

/*png_ptr*/

1. {
2.    png_debug(1, ""in png_set_crc_action"");
3.    if (png_ptr == NULL)
4.       return;",Not Useful
/*row_info:*/,"-10.    if ((png_ptr->transformations & PNG_SWAP_BYTES) != 0)
-9.       png_do_swap(row_info, png_ptr->row_buf + 1);
-8. #endif
-7. #endif
-6. #ifdef PNG_READ_USER_TRANSFORM_SUPPORTED
-5.    if ((png_ptr->transformations & PNG_USER_TRANSFORM) != 0)
-4.    {
-3.       if (png_ptr->read_user_transform_fn != NULL)

/*row_info:*/

 ",Not Useful
/*png_uint_32 width;       width of row*/,"-10.       png_do_swap(row_info, png_ptr->row_buf + 1);
-9. #endif
-8. #endif
-7. #ifdef PNG_READ_USER_TRANSFORM_SUPPORTED
-6.    if ((png_ptr->transformations & PNG_USER_TRANSFORM) != 0)
-5.    {
-4.       if (png_ptr->read_user_transform_fn != NULL)

/*png_uint_32 width;       width of row*/

 ",Not Useful
/*png_byte bit_depth;      bit depth of samples*/,"-10. #ifdef PNG_READ_USER_TRANSFORM_SUPPORTED
-9.    if ((png_ptr->transformations & PNG_USER_TRANSFORM) != 0)
-8.    {
-7.       if (png_ptr->read_user_transform_fn != NULL)

/*png_byte bit_depth;      bit depth of samples*/

 ",Not Useful
/*READ_TRANSFORMS*/,"-6.       case PNG_CRC_DEFAULT:
-5.       default:
-4.          png_ptr->flags &= ~PNG_FLAG_CRC_ANCILLARY_MASK;
-3.          break;
-2.    }
-1. }
#ifdef PNG_READ_TRANSFORMS_SUPPORTED

/*READ_TRANSFORMS*/

 ",Not Useful
"/*SAFE, does not exceed 8*/","-2. png_push_read_sig(png_structrp png_ptr, png_inforp info_ptr)
-1. {

/*SAFE, does not exceed 8*/

1.        num_to_check = 8 - num_checked;
2.    if (png_ptr->buffer_size < num_to_check)
3.    {
4.       num_to_check = png_ptr->buffer_size;
5.    }
6.    png_push_fill_buffer(png_ptr, &(info_ptr->signature[num_checked]),
7.        num_to_check);
8.    png_ptr->sig_bytes = (png_byte)(png_ptr->sig_bytes + num_to_check);
9.    if (png_sig_cmp(info_ptr->signature, num_checked, num_to_check))
10.    {",Not Useful
/*READ_INTERLACING*/,"-8.    if (png_ptr->transformed_pixel_depth == 0)
-7.    {
-6.       png_ptr->transformed_pixel_depth = row_info.pixel_depth;
-5.       if (row_info.pixel_depth > png_ptr->maximum_pixel_depth)
-4.          png_error(png_ptr, ""progressive row overflow"");
-3.    }
-2.    else if (png_ptr->transformed_pixel_depth != row_info.pixel_depth)
-1.       png_error(png_ptr, ""internal progressive row size calculation error"");
#ifdef PNG_READ_INTERLACING_SUPPORTED

/*READ_INTERLACING*/

 ",Not Useful
/*READ_INTERLACING*/,"-8.    if (png_ptr->transformed_pixel_depth == 0)
-7.    {
-6.       png_ptr->transformed_pixel_depth = row_info.pixel_depth;
-5.       if (row_info.pixel_depth > png_ptr->maximum_pixel_depth)
-4.          png_error(png_ptr, ""progressive row overflow"");
-3.    }
-2.    else if (png_ptr->transformed_pixel_depth != row_info.pixel_depth)
-1.       png_error(png_ptr, ""internal progressive row size calculation error"");
#ifdef PNG_READ_INTERLACING_SUPPORTED

/*READ_INTERLACING*/

 ",Not Useful
/*Put the chunk name into png_ptr->chunk_name*/,"-3.    png_save_uint_32(buf, length);
-2.    png_save_uint_32(buf + 4, chunk_name);
-1.    png_write_data(png_ptr, buf, 8);

/*Put the chunk name into png_ptr->chunk_name*/

1.    png_ptr->chunk_name = chunk_name;",Not Useful
/*Finish a chunk started with png_write_chunk_header().*/,"-3.       png_calculate_crc(png_ptr, data, length);
-2.    }
-1. }

/*Finish a chunk started with png_write_chunk_header().*/

1. void PNGAPI
2. png_write_chunk_end(png_structrp png_ptr)
3. {
4.    png_byte buf[4];
5.    if (png_ptr == NULL) return;
6. #ifdef PNG_IO_STATE_SUPPORTED",Not Useful
/*WRITE_OPTIMIZE_CMF*/,"-10.                cb_base += (PNG_ROWBYTES(pd, pw)+1) * PNG_PASS_ROWS(h, pass);
-9.          }
-8.          return cb_base;
-7.       }
-6.       else
-5.          return (png_ptr->rowbytes+1) * h;
-4.    }
-3.    else
-2.       return 0xffffffffU;
-1. }
#ifdef PNG_WRITE_OPTIMIZE_CMF_SUPPORTED

/*WRITE_OPTIMIZE_CMF*/

 ",Not Useful
/*PRIVATE*/,"-10.        * pretty much the same set of error codes.
-9.        */
-8.       if (ret == Z_OK)
-7.          png_ptr->zowner = owner;
-6.       else
-5.          png_zstream_error(png_ptr, ret);
-4.       return ret;
-3.    }
-2. }

/*PRIVATE*/

1. png_free_buffer_list(png_structrp png_ptr, png_compression_bufferp *listp)
2. {
3.    png_compression_bufferp list = *listp;
4.    if (list != NULL)
5.    {
6.       *listp = NULL;
7.       do
8.       {
9.          png_compression_bufferp next = list->next;
10.          png_free(png_ptr, list);",Not Useful
/*The uncompressed input data*/,"-10.  * The compression_state structure is shared context for these functions
-9.  * set up by the caller to allow access to the relevant local variables.
-8.  *
-7.  * compression_buffer (new in 1.6.0) is just a linked list of zbuffer_size
-6.  * temporary buffers.  From 1.6.0 it is retained in png_struct so that it will
-5.  * be correctly freed in the event of a write error (previous implementations
-4.  * just leaked memory.)
-3.  */
-2. typedef struct
-1. {

/*The uncompressed input data*/

 ",Not Useful
/*Its length*/,"-10.  * set up by the caller to allow access to the relevant local variables.
-9.  *
-8.  * compression_buffer (new in 1.6.0) is just a linked list of zbuffer_size
-7.  * temporary buffers.  From 1.6.0 it is retained in png_struct so that it will
-6.  * be correctly freed in the event of a write error (previous implementations
-5.  * just leaked memory.)
-4.  */
-3. typedef struct
-2. {

/*Its length*/

 ",Not Useful
/*Final compressed length*/,"-10.  *
-9.  * compression_buffer (new in 1.6.0) is just a linked list of zbuffer_size
-8.  * temporary buffers.  From 1.6.0 it is retained in png_struct so that it will
-7.  * be correctly freed in the event of a write error (previous implementations
-6.  * just leaked memory.)
-5.  */
-4. typedef struct
-3. {

/*Final compressed length*/

 ",Not Useful
/*may be zero!*/,"-2.    {
-1.       png_compression_bufferp *end = &png_ptr->zbuffer_list;

/*may be zero!*/

1.       png_uint_32 output_len;",Not Useful
/*safety*/,"-10.          (png_ptr->zlib_set_level != level ||
-9.          png_ptr->zlib_set_method != method ||
-8.          png_ptr->zlib_set_window_bits != windowBits ||
-7.          png_ptr->zlib_set_mem_level != memLevel ||
-6.          png_ptr->zlib_set_strategy != strategy))
-5.       {
-4.          if (deflateEnd(&png_ptr->zstream) != Z_OK)
-3.             png_warning(png_ptr, ""deflateEnd failed (ignored)"");
-2.          png_ptr->flags &= ~PNG_FLAG_ZSTREAM_INITIALIZED;
-1.       }
      /* For safety clear out the input and output pointers (currently zlib

/*safety*/

1.        * doesn't use them on Init, but it might in the future).
2.        */
3.       png_ptr->zstream.next_in = NULL;
4.       png_ptr->zstream.avail_in = 0;
5.       png_ptr->zstream.next_out = NULL;
6.       png_ptr->zstream.avail_out = 0;",Not Useful
/*safety*/,"-10.          (png_ptr->zlib_set_level != level ||
-9.          png_ptr->zlib_set_method != method ||
-8.          png_ptr->zlib_set_window_bits != windowBits ||
-7.          png_ptr->zlib_set_mem_level != memLevel ||
-6.          png_ptr->zlib_set_strategy != strategy))
-5.       {
-4.          if (deflateEnd(&png_ptr->zstream) != Z_OK)
-3.             png_warning(png_ptr, ""deflateEnd failed (ignored)"");
-2.          png_ptr->flags &= ~PNG_FLAG_ZSTREAM_INITIALIZED;
-1.       }
      /* For safety clear out the input and output pointers (currently zlib

/*safety*/

1.        * doesn't use them on Init, but it might in the future).
2.        */
3.       png_ptr->zstream.next_in = NULL;
4.       png_ptr->zstream.avail_in = 0;
5.       png_ptr->zstream.next_out = NULL;
6.       png_ptr->zstream.avail_out = 0;",Not Useful
/*PRIVATE*/,"-10.        * pretty much the same set of error codes.
-9.        */
-8.       if (ret == Z_OK)
-7.          png_ptr->zowner = owner;
-6.       else
-5.          png_zstream_error(png_ptr, ret);
-4.       return ret;
-3.    }
-2. }

/*PRIVATE*/

1. png_free_buffer_list(png_structrp png_ptr, png_compression_bufferp *listp)
2. {
3.    png_compression_bufferp list = *listp;
4.    if (list != NULL)
5.    {
6.       *listp = NULL;
7.       do
8.       {
9.          png_compression_bufferp next = list->next;
10.          png_free(png_ptr, list);",Not Useful
/*Save the relevant information*/,"-10. #ifdef PNG_WRITE_INTERLACING_SUPPORTED
-9.    if (interlace_type != PNG_INTERLACE_NONE &&
-8.        interlace_type != PNG_INTERLACE_ADAM7)
-7.    {
-6.       png_warning(png_ptr, ""Invalid interlace type specified"");
-5.       interlace_type = PNG_INTERLACE_ADAM7;
-4.    }
-3. #else
-2.    interlace_type=PNG_INTERLACE_NONE;
-1. #endif

/*Save the relevant information*/

1.    png_ptr->bit_depth = (png_byte)bit_depth;
2.    png_ptr->color_type = (png_byte)color_type;
3.    png_ptr->interlaced = (png_byte)interlace_type;
4. #ifdef PNG_MNG_FEATURES_SUPPORTED
5.    png_ptr->filter_type = (png_byte)filter_type;
6. #endif
7.    png_ptr->compression_type = (png_byte)compression_type;
8.    png_ptr->width = width;
9.    png_ptr->height = height;
10.    png_ptr->pixel_depth = (png_byte)(bit_depth * png_ptr->channels);",Not Useful
/*not READY_FOR_ZTXT*/,"-9.    png_write_complete_chunk(png_ptr, png_IHDR, buf, (png_size_t)13);
-8.    if ((png_ptr->do_filter) == PNG_NO_FILTERS)
-7.    {
-6.       if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE ||
-5.           png_ptr->bit_depth < 8)
-4.          png_ptr->do_filter = PNG_FILTER_NONE;
-3.       else
-2.          png_ptr->do_filter = PNG_ALL_FILTERS;
-1.    }

/*not READY_FOR_ZTXT*/

1. }",Not Useful
/*PRIVATE*/,"-10.        * pretty much the same set of error codes.
-9.        */
-8.       if (ret == Z_OK)
-7.          png_ptr->zowner = owner;
-6.       else
-5.          png_zstream_error(png_ptr, ret);
-4.       return ret;
-3.    }
-2. }

/*PRIVATE*/

1. png_free_buffer_list(png_structrp png_ptr, png_compression_bufferp *listp)
2. {
3.    png_compression_bufferp list = *listp;
4.    if (list != NULL)
5.    {
6.       *listp = NULL;
7.       do
8.       {
9.          png_compression_bufferp next = list->next;
10.          png_free(png_ptr, list);",Not Useful
/*PRIVATE*/,"-10.        * pretty much the same set of error codes.
-9.        */
-8.       if (ret == Z_OK)
-7.          png_ptr->zowner = owner;
-6.       else
-5.          png_zstream_error(png_ptr, ret);
-4.       return ret;
-3.    }
-2. }

/*PRIVATE*/

1. png_free_buffer_list(png_structrp png_ptr, png_compression_bufferp *listp)
2. {
3.    png_compression_bufferp list = *listp;
4.    if (list != NULL)
5.    {
6.       *listp = NULL;
7.       do
8.       {
9.          png_compression_bufferp next = list->next;
10.          png_free(png_ptr, list);",Not Useful
/*Write an IEND chunk*/,"-5.          png_zstream_error(png_ptr, ret);
-4.          png_error(png_ptr, png_ptr->zstream.msg);
-3.       }
-2.    }
-1. }

/*Write an IEND chunk*/

 ",Not Useful
/*PRIVATE*/,"-10.        * pretty much the same set of error codes.
-9.        */
-8.       if (ret == Z_OK)
-7.          png_ptr->zowner = owner;
-6.       else
-5.          png_zstream_error(png_ptr, ret);
-4.       return ret;
-3.    }
-2. }

/*PRIVATE*/

1. png_free_buffer_list(png_structrp png_ptr, png_compression_bufferp *listp)
2. {
3.    png_compression_bufferp list = *listp;
4.    if (list != NULL)
5.    {
6.       *listp = NULL;
7.       do
8.       {
9.          png_compression_bufferp next = list->next;
10.          png_free(png_ptr, list);",Not Useful
/*Write a gAMA chunk*/,"-7. png_write_IEND(png_structrp png_ptr)
-6. {
-5.    png_debug(1, ""in png_write_IEND"");
-4.    png_write_complete_chunk(png_ptr, png_IEND, NULL, (png_size_t)0);
-3.    png_ptr->mode |= PNG_HAVE_IEND;
-2. }
-1. #ifdef PNG_WRITE_gAMA_SUPPORTED

/*Write a gAMA chunk*/

 ",Not Useful
/*PRIVATE*/,"-10.        * pretty much the same set of error codes.
-9.        */
-8.       if (ret == Z_OK)
-7.          png_ptr->zowner = owner;
-6.       else
-5.          png_zstream_error(png_ptr, ret);
-4.       return ret;
-3.    }
-2. }

/*PRIVATE*/

1. png_free_buffer_list(png_structrp png_ptr, png_compression_bufferp *listp)
2. {
3.    png_compression_bufferp list = *listp;
4.    if (list != NULL)
5.    {
6.       *listp = NULL;
7.       do
8.       {
9.          png_compression_bufferp next = list->next;
10.          png_free(png_ptr, list);",Not Useful
/*Write a sRGB chunk*/,"-5.    png_save_uint_32(buf, (png_uint_32)file_gamma);
-4.    png_write_complete_chunk(png_ptr, png_gAMA, buf, (png_size_t)4);
-3. }
-2. #endif
-1. #ifdef PNG_WRITE_sRGB_SUPPORTED

/*Write a sRGB chunk*/

 ",Not Useful
/*PRIVATE*/,"-10.        * pretty much the same set of error codes.
-9.        */
-8.       if (ret == Z_OK)
-7.          png_ptr->zowner = owner;
-6.       else
-5.          png_zstream_error(png_ptr, ret);
-4.       return ret;
-3.    }
-2. }

/*PRIVATE*/

1. png_free_buffer_list(png_structrp png_ptr, png_compression_bufferp *listp)
2. {
3.    png_compression_bufferp list = *listp;
4.    if (list != NULL)
5.    {
6.       *listp = NULL;
7.       do
8.       {
9.          png_compression_bufferp next = list->next;
10.          png_free(png_ptr, list);",Not Useful
/*Write an iCCP chunk*/,"-10.    png_byte buf[1];
-9.    png_debug(1, ""in png_write_sRGB"");
-8.    if (srgb_intent >= PNG_sRGB_INTENT_LAST)
-7.       png_warning(png_ptr,
-6.           ""Invalid sRGB rendering intent specified"");
-5.    buf[0]=(png_byte)srgb_intent;
-4.    png_write_complete_chunk(png_ptr, png_sRGB, buf, (png_size_t)1);
-3. }
-2. #endif
-1. #ifdef PNG_WRITE_iCCP_SUPPORTED

/*Write an iCCP chunk*/

 ",Not Useful
/*PRIVATE*/,"-10.        * pretty much the same set of error codes.
-9.        */
-8.       if (ret == Z_OK)
-7.          png_ptr->zowner = owner;
-6.       else
-5.          png_zstream_error(png_ptr, ret);
-4.       return ret;
-3.    }
-2. }

/*PRIVATE*/

1. png_free_buffer_list(png_structrp png_ptr, png_compression_bufferp *listp)
2. {
3.    png_compression_bufferp list = *listp;
4.    if (list != NULL)
5.    {
6.       *listp = NULL;
7.       do
8.       {
9.          png_compression_bufferp next = list->next;
10.          png_free(png_ptr, list);",Not Useful
/*Write a sPLT chunk*/,"-9.    if (png_text_compress(png_ptr, png_iCCP, &comp, name_len) != Z_OK)
-8.       png_error(png_ptr, png_ptr->zstream.msg);
-7.    png_write_chunk_header(png_ptr, png_iCCP, name_len + comp.output_len);
-6.    png_write_chunk_data(png_ptr, new_name, name_len);
-5.    png_write_compressed_data_out(png_ptr, &comp);
-4.    png_write_chunk_end(png_ptr);
-3. }
-2. #endif
-1. #ifdef PNG_WRITE_sPLT_SUPPORTED

/*Write a sPLT chunk*/

 ",Not Useful
/*PRIVATE*/,"-10.        * pretty much the same set of error codes.
-9.        */
-8.       if (ret == Z_OK)
-7.          png_ptr->zowner = owner;
-6.       else
-5.          png_zstream_error(png_ptr, ret);
-4.       return ret;
-3.    }
-2. }

/*PRIVATE*/

1. png_free_buffer_list(png_structrp png_ptr, png_compression_bufferp *listp)
2. {
3.    png_compression_bufferp list = *listp;
4.    if (list != NULL)
5.    {
6.       *listp = NULL;
7.       do
8.       {
9.          png_compression_bufferp next = list->next;
10.          png_free(png_ptr, list);",Not Useful
/*Write the sBIT chunk*/,"-10.          png_save_uint_16(entrybuf + 6, ep[i].alpha);
-9.          png_save_uint_16(entrybuf + 8, ep[i].frequency);
-8.       }
-7.       png_write_chunk_data(png_ptr, entrybuf, entry_size);
-6.    }
-5. #endif
-4.    png_write_chunk_end(png_ptr);
-3. }
-2. #endif
-1. #ifdef PNG_WRITE_sBIT_SUPPORTED

/*Write the sBIT chunk*/

 ",Not Useful
/*PRIVATE*/,"-10.        * pretty much the same set of error codes.
-9.        */
-8.       if (ret == Z_OK)
-7.          png_ptr->zowner = owner;
-6.       else
-5.          png_zstream_error(png_ptr, ret);
-4.       return ret;
-3.    }
-2. }

/*PRIVATE*/

1. png_free_buffer_list(png_structrp png_ptr, png_compression_bufferp *listp)
2. {
3.    png_compression_bufferp list = *listp;
4.    if (list != NULL)
5.    {
6.       *listp = NULL;
7.       do
8.       {
9.          png_compression_bufferp next = list->next;
10.          png_free(png_ptr, list);",Not Useful
/*Write the cHRM chunk*/,"-10.       {
-9.          png_warning(png_ptr, ""Invalid sBIT depth specified"");
-8.          return;
-7.       }
-6.       buf[size++] = sbit->alpha;
-5.    }
-4.    png_write_complete_chunk(png_ptr, png_sBIT, buf, size);
-3. }
-2. #endif
-1. #ifdef PNG_WRITE_cHRM_SUPPORTED

/*Write the cHRM chunk*/

 ",Not Useful
/*PRIVATE*/,"-10.        * pretty much the same set of error codes.
-9.        */
-8.       if (ret == Z_OK)
-7.          png_ptr->zowner = owner;
-6.       else
-5.          png_zstream_error(png_ptr, ret);
-4.       return ret;
-3.    }
-2. }

/*PRIVATE*/

1. png_free_buffer_list(png_structrp png_ptr, png_compression_bufferp *listp)
2. {
3.    png_compression_bufferp list = *listp;
4.    if (list != NULL)
5.    {
6.       *listp = NULL;
7.       do
8.       {
9.          png_compression_bufferp next = list->next;
10.          png_free(png_ptr, list);",Not Useful
/*Write the tRNS chunk*/,"-10.    png_save_int_32(buf +  8, xy->redx);
-9.    png_save_int_32(buf + 12, xy->redy);
-8.    png_save_int_32(buf + 16, xy->greenx);
-7.    png_save_int_32(buf + 20, xy->greeny);
-6.    png_save_int_32(buf + 24, xy->bluex);
-5.    png_save_int_32(buf + 28, xy->bluey);
-4.    png_write_complete_chunk(png_ptr, png_cHRM, buf, 32);
-3. }
-2. #endif
-1. #ifdef PNG_WRITE_tRNS_SUPPORTED

/*Write the tRNS chunk*/

 ",Not Useful
/*PRIVATE*/,"-10.        * pretty much the same set of error codes.
-9.        */
-8.       if (ret == Z_OK)
-7.          png_ptr->zowner = owner;
-6.       else
-5.          png_zstream_error(png_ptr, ret);
-4.       return ret;
-3.    }
-2. }

/*PRIVATE*/

1. png_free_buffer_list(png_structrp png_ptr, png_compression_bufferp *listp)
2. {
3.    png_compression_bufferp list = *listp;
4.    if (list != NULL)
5.    {
6.       *listp = NULL;
7.       do
8.       {
9.          png_compression_bufferp next = list->next;
10.          png_free(png_ptr, list);",Not Useful
/*PRIVATE*/,"-10.        * pretty much the same set of error codes.
-9.        */
-8.       if (ret == Z_OK)
-7.          png_ptr->zowner = owner;
-6.       else
-5.          png_zstream_error(png_ptr, ret);
-4.       return ret;
-3.    }
-2. }

/*PRIVATE*/

1. png_free_buffer_list(png_structrp png_ptr, png_compression_bufferp *listp)
2. {
3.    png_compression_bufferp list = *listp;
4.    if (list != NULL)
5.    {
6.       *listp = NULL;
7.       do
8.       {
9.          png_compression_bufferp next = list->next;
10.          png_free(png_ptr, list);",Not Useful
/*Write the Exif data*/,"-10.          png_warning(png_ptr,
-9.              ""Ignoring attempt to write bKGD chunk out-of-range for bit_depth"");
-8.          return;
-7.       }
-6.       png_save_uint_16(buf, back->gray);
-5.       png_write_complete_chunk(png_ptr, png_bKGD, buf, (png_size_t)2);
-4.    }
-3. }
-2. #endif
-1. #ifdef PNG_WRITE_eXIf_SUPPORTED

/*Write the Exif data*/

 ",Not Useful
/*PRIVATE*/,"-10.        * pretty much the same set of error codes.
-9.        */
-8.       if (ret == Z_OK)
-7.          png_ptr->zowner = owner;
-6.       else
-5.          png_zstream_error(png_ptr, ret);
-4.       return ret;
-3.    }
-2. }

/*PRIVATE*/

1. png_free_buffer_list(png_structrp png_ptr, png_compression_bufferp *listp)
2. {
3.    png_compression_bufferp list = *listp;
4.    if (list != NULL)
5.    {
6.       *listp = NULL;
7.       do
8.       {
9.          png_compression_bufferp next = list->next;
10.          png_free(png_ptr, list);",Not Useful
/*PRIVATE*/,"-10.        * pretty much the same set of error codes.
-9.        */
-8.       if (ret == Z_OK)
-7.          png_ptr->zowner = owner;
-6.       else
-5.          png_zstream_error(png_ptr, ret);
-4.       return ret;
-3.    }
-2. }

/*PRIVATE*/

1. png_free_buffer_list(png_structrp png_ptr, png_compression_bufferp *listp)
2. {
3.    png_compression_bufferp list = *listp;
4.    if (list != NULL)
5.    {
6.       *listp = NULL;
7.       do
8.       {
9.          png_compression_bufferp next = list->next;
10.          png_free(png_ptr, list);",Not Useful
/*Write a tEXt chunk*/,"-10.    png_write_chunk_header(png_ptr, png_hIST, (png_uint_32)(num_hist * 2));
-9.    for (i = 0; i < num_hist; i++)
-8.    {
-7.       png_save_uint_16(buf, hist[i]);
-6.       png_write_chunk_data(png_ptr, buf, (png_size_t)2);
-5.    }
-4.    png_write_chunk_end(png_ptr);
-3. }
-2. #endif
-1. #ifdef PNG_WRITE_tEXt_SUPPORTED

/*Write a tEXt chunk*/

 ",Not Useful
/*PRIVATE*/,"-10.        * pretty much the same set of error codes.
-9.        */
-8.       if (ret == Z_OK)
-7.          png_ptr->zowner = owner;
-6.       else
-5.          png_zstream_error(png_ptr, ret);
-4.       return ret;
-3.    }
-2. }

/*PRIVATE*/

1. png_free_buffer_list(png_structrp png_ptr, png_compression_bufferp *listp)
2. {
3.    png_compression_bufferp list = *listp;
4.    if (list != NULL)
5.    {
6.       *listp = NULL;
7.       do
8.       {
9.          png_compression_bufferp next = list->next;
10.          png_free(png_ptr, list);",Not Useful
/*PRIVATE*/,"-10.        * pretty much the same set of error codes.
-9.        */
-8.       if (ret == Z_OK)
-7.          png_ptr->zowner = owner;
-6.       else
-5.          png_zstream_error(png_ptr, ret);
-4.       return ret;
-3.    }
-2. }

/*PRIVATE*/

1. png_free_buffer_list(png_structrp png_ptr, png_compression_bufferp *listp)
2. {
3.    png_compression_bufferp list = *listp;
4.    if (list != NULL)
5.    {
6.       *listp = NULL;
7.       do
8.       {
9.          png_compression_bufferp next = list->next;
10.          png_free(png_ptr, list);",Not Useful
/*Close the chunk*/,"-1.    png_write_compressed_data_out(png_ptr, &comp);

/*Close the chunk*/

1.    png_write_chunk_end(png_ptr);
2. }
3. #endif
4. #ifdef PNG_WRITE_iTXt_SUPPORTED",Not Useful
/*Write an iTXt chunk*/,"-4.    png_write_chunk_end(png_ptr);
-3. }
-2. #endif
-1. #ifdef PNG_WRITE_iTXt_SUPPORTED

/*Write an iTXt chunk*/

 ",Not Useful
/*PRIVATE*/,"-10.        * pretty much the same set of error codes.
-9.        */
-8.       if (ret == Z_OK)
-7.          png_ptr->zowner = owner;
-6.       else
-5.          png_zstream_error(png_ptr, ret);
-4.       return ret;
-3.    }
-2. }

/*PRIVATE*/

1. png_free_buffer_list(png_structrp png_ptr, png_compression_bufferp *listp)
2. {
3.    png_compression_bufferp list = *listp;
4.    if (list != NULL)
5.    {
6.       *listp = NULL;
7.       do
8.       {
9.          png_compression_bufferp next = list->next;
10.          png_free(png_ptr, list);",Not Useful
/*SAFE*/,"-10.    if (compression != 0)
-9.    {
-8.       if (png_text_compress(png_ptr, png_iTXt, &comp, prefix_len) != Z_OK)
-7.          png_error(png_ptr, png_ptr->zstream.msg);
-6.    }
-5.    else
-4.    {
-3.       if (comp.input_len > PNG_UINT_31_MAX-prefix_len)
-2.          png_error(png_ptr, ""iTXt: uncompressed text too long"");

/*SAFE*/

1.    }
2.    png_write_chunk_header(png_ptr, png_iTXt, comp.output_len + prefix_len);
3.    png_write_chunk_data(png_ptr, new_key, key_len);
4.    png_write_chunk_data(png_ptr, (png_const_bytep)lang, lang_len);
5.    png_write_chunk_data(png_ptr, (png_const_bytep)lang_key, lang_key_len);
6.    if (compression != 0)
7.       png_write_compressed_data_out(png_ptr, &comp);
8.    else
9.       png_write_chunk_data(png_ptr, (png_const_bytep)text, comp.output_len);
10.    png_write_chunk_end(png_ptr);",Not Useful
/*Write the oFFs chunk*/,"-10.    png_write_chunk_data(png_ptr, (png_const_bytep)lang, lang_len);
-9.    png_write_chunk_data(png_ptr, (png_const_bytep)lang_key, lang_key_len);
-8.    if (compression != 0)
-7.       png_write_compressed_data_out(png_ptr, &comp);
-6.    else
-5.       png_write_chunk_data(png_ptr, (png_const_bytep)text, comp.output_len);
-4.    png_write_chunk_end(png_ptr);
-3. }
-2. #endif
-1. #ifdef PNG_WRITE_oFFs_SUPPORTED

/*Write the oFFs chunk*/

 ",Not Useful
/*PRIVATE*/,"-10.        * pretty much the same set of error codes.
-9.        */
-8.       if (ret == Z_OK)
-7.          png_ptr->zowner = owner;
-6.       else
-5.          png_zstream_error(png_ptr, ret);
-4.       return ret;
-3.    }
-2. }

/*PRIVATE*/

1. png_free_buffer_list(png_structrp png_ptr, png_compression_bufferp *listp)
2. {
3.    png_compression_bufferp list = *listp;
4.    if (list != NULL)
5.    {
6.       *listp = NULL;
7.       do
8.       {
9.          png_compression_bufferp next = list->next;
10.          png_free(png_ptr, list);",Not Useful
/*Write the pCAL chunk (described in the PNG extensions document)*/,"-10.    png_debug(1, ""in png_write_oFFs"");
-9.    if (unit_type >= PNG_OFFSET_LAST)
-8.       png_warning(png_ptr, ""Unrecognized unit type for oFFs chunk"");
-7.    png_save_int_32(buf, x_offset);
-6.    png_save_int_32(buf + 4, y_offset);
-5.    buf[8] = (png_byte)unit_type;
-4.    png_write_complete_chunk(png_ptr, png_oFFs, buf, (png_size_t)9);
-3. }
-2. #endif
-1. #ifdef PNG_WRITE_pCAL_SUPPORTED

/*Write the pCAL chunk (described in the PNG extensions document)*/

 ",Not Useful
/*PRIVATE*/,"-10.        * pretty much the same set of error codes.
-9.        */
-8.       if (ret == Z_OK)
-7.          png_ptr->zowner = owner;
-6.       else
-5.          png_zstream_error(png_ptr, ret);
-4.       return ret;
-3.    }
-2. }

/*PRIVATE*/

1. png_free_buffer_list(png_structrp png_ptr, png_compression_bufferp *listp)
2. {
3.    png_compression_bufferp list = *listp;
4.    if (list != NULL)
5.    {
6.       *listp = NULL;
7.       do
8.       {
9.          png_compression_bufferp next = list->next;
10.          png_free(png_ptr, list);",Not Useful
/*PRIVATE*/,"-10.        * pretty much the same set of error codes.
-9.        */
-8.       if (ret == Z_OK)
-7.          png_ptr->zowner = owner;
-6.       else
-5.          png_zstream_error(png_ptr, ret);
-4.       return ret;
-3.    }
-2. }

/*PRIVATE*/

1. png_free_buffer_list(png_structrp png_ptr, png_compression_bufferp *listp)
2. {
3.    png_compression_bufferp list = *listp;
4.    if (list != NULL)
5.    {
6.       *listp = NULL;
7.       do
8.       {
9.          png_compression_bufferp next = list->next;
10.          png_free(png_ptr, list);",Not Useful
/*Write the pHYs chunk*/,"-5.    png_debug1(3, ""sCAL total length = %u"", (unsigned int)total_len);
-4.    png_write_complete_chunk(png_ptr, png_sCAL, buf, total_len);
-3. }
-2. #endif
-1. #ifdef PNG_WRITE_pHYs_SUPPORTED

/*Write the pHYs chunk*/

 ",Not Useful
/*PRIVATE*/,"-10.        * pretty much the same set of error codes.
-9.        */
-8.       if (ret == Z_OK)
-7.          png_ptr->zowner = owner;
-6.       else
-5.          png_zstream_error(png_ptr, ret);
-4.       return ret;
-3.    }
-2. }

/*PRIVATE*/

1. png_free_buffer_list(png_structrp png_ptr, png_compression_bufferp *listp)
2. {
3.    png_compression_bufferp list = *listp;
4.    if (list != NULL)
5.    {
6.       *listp = NULL;
7.       do
8.       {
9.          png_compression_bufferp next = list->next;
10.          png_free(png_ptr, list);",Not Useful
/*PRIVATE*/,"-10.        * pretty much the same set of error codes.
-9.        */
-8.       if (ret == Z_OK)
-7.          png_ptr->zowner = owner;
-6.       else
-5.          png_zstream_error(png_ptr, ret);
-4.       return ret;
-3.    }
-2. }

/*PRIVATE*/

1. png_free_buffer_list(png_structrp png_ptr, png_compression_bufferp *listp)
2. {
3.    png_compression_bufferp list = *listp;
4.    if (list != NULL)
5.    {
6.       *listp = NULL;
7.       do
8.       {
9.          png_compression_bufferp next = list->next;
10.          png_free(png_ptr, list);",Not Useful
/*PRIVATE*/,"-10.        * pretty much the same set of error codes.
-9.        */
-8.       if (ret == Z_OK)
-7.          png_ptr->zowner = owner;
-6.       else
-5.          png_zstream_error(png_ptr, ret);
-4.       return ret;
-3.    }
-2. }

/*PRIVATE*/

1. png_free_buffer_list(png_structrp png_ptr, png_compression_bufferp *listp)
2. {
3.    png_compression_bufferp list = *listp;
4.    if (list != NULL)
5.    {
6.       *listp = NULL;
7.       do
8.       {
9.          png_compression_bufferp next = list->next;
10.          png_free(png_ptr, list);",Not Useful
/*WRITE_FILTER*/,"-4.    static PNG_CONST png_byte png_pass_yinc[7] = {8, 8, 8, 4, 4, 2, 2};
-3. #endif
-2.    png_alloc_size_t buf_size;
-1.    int usr_pixel_depth;
#ifdef PNG_WRITE_FILTER_SUPPORTED

/*WRITE_FILTER*/

1.    png_byte filters;
2. #endif
3.    png_debug(1, ""in png_write_start_row"");
4.    usr_pixel_depth = png_ptr->usr_channels * png_ptr->usr_bit_depth;
5.    buf_size = PNG_ROWBYTES(usr_pixel_depth, png_ptr->width) + 1;",Not Useful
/*PRIVATE*/,"-10.        * pretty much the same set of error codes.
-9.        */
-8.       if (ret == Z_OK)
-7.          png_ptr->zowner = owner;
-6.       else
-5.          png_zstream_error(png_ptr, ret);
-4.       return ret;
-3.    }
-2. }

/*PRIVATE*/

1. png_free_buffer_list(png_structrp png_ptr, png_compression_bufferp *listp)
2. {
3.    png_compression_bufferp list = *listp;
4.    if (list != NULL)
5.    {
6.       *listp = NULL;
7.       do
8.       {
9.          png_compression_bufferp next = list->next;
10.          png_free(png_ptr, list);",Not Useful
/*PRIVATE*/,"-10.        * pretty much the same set of error codes.
-9.        */
-8.       if (ret == Z_OK)
-7.          png_ptr->zowner = owner;
-6.       else
-5.          png_zstream_error(png_ptr, ret);
-4.       return ret;
-3.    }
-2. }

/*PRIVATE*/

1. png_free_buffer_list(png_structrp png_ptr, png_compression_bufferp *listp)
2. {
3.    png_compression_bufferp list = *listp;
4.    if (list != NULL)
5.    {
6.       *listp = NULL;
7.       do
8.       {
9.          png_compression_bufferp next = list->next;
10.          png_free(png_ptr, list);",Not Useful
/*PRIVATE*/,"-10.        * pretty much the same set of error codes.
-9.        */
-8.       if (ret == Z_OK)
-7.          png_ptr->zowner = owner;
-6.       else
-5.          png_zstream_error(png_ptr, ret);
-4.       return ret;
-3.    }
-2. }

/*PRIVATE*/

1. png_free_buffer_list(png_structrp png_ptr, png_compression_bufferp *listp)
2. {
3.    png_compression_bufferp list = *listp;
4.    if (list != NULL)
5.    {
6.       *listp = NULL;
7.       do
8.       {
9.          png_compression_bufferp next = list->next;
10.          png_free(png_ptr, list);",Not Useful
/*PRIVATE*/,"-10.        * pretty much the same set of error codes.
-9.        */
-8.       if (ret == Z_OK)
-7.          png_ptr->zowner = owner;
-6.       else
-5.          png_zstream_error(png_ptr, ret);
-4.       return ret;
-3.    }
-2. }

/*PRIVATE*/

1. png_free_buffer_list(png_structrp png_ptr, png_compression_bufferp *listp)
2. {
3.    png_compression_bufferp list = *listp;
4.    if (list != NULL)
5.    {
6.       *listp = NULL;
7.       do
8.       {
9.          png_compression_bufferp next = list->next;
10.          png_free(png_ptr, list);",Not Useful
/*PRIVATE*/,"-10.        * pretty much the same set of error codes.
-9.        */
-8.       if (ret == Z_OK)
-7.          png_ptr->zowner = owner;
-6.       else
-5.          png_zstream_error(png_ptr, ret);
-4.       return ret;
-3.    }
-2. }

/*PRIVATE*/

1. png_free_buffer_list(png_structrp png_ptr, png_compression_bufferp *listp)
2. {
3.    png_compression_bufferp list = *listp;
4.    if (list != NULL)
5.    {
6.       *listp = NULL;
7.       do
8.       {
9.          png_compression_bufferp next = list->next;
10.          png_free(png_ptr, list);",Not Useful
/*PRIVATE*/,"-10.        * pretty much the same set of error codes.
-9.        */
-8.       if (ret == Z_OK)
-7.          png_ptr->zowner = owner;
-6.       else
-5.          png_zstream_error(png_ptr, ret);
-4.       return ret;
-3.    }
-2. }

/*PRIVATE*/

1. png_free_buffer_list(png_structrp png_ptr, png_compression_bufferp *listp)
2. {
3.    png_compression_bufferp list = *listp;
4.    if (list != NULL)
5.    {
6.       *listp = NULL;
7.       do
8.       {
9.          png_compression_bufferp next = list->next;
10.          png_free(png_ptr, list);",Not Useful
/*PRIVATE*/,"-10.        * pretty much the same set of error codes.
-9.        */
-8.       if (ret == Z_OK)
-7.          png_ptr->zowner = owner;
-6.       else
-5.          png_zstream_error(png_ptr, ret);
-4.       return ret;
-3.    }
-2. }

/*PRIVATE*/

1. png_free_buffer_list(png_structrp png_ptr, png_compression_bufferp *listp)
2. {
3.    png_compression_bufferp list = *listp;
4.    if (list != NULL)
5.    {
6.       *listp = NULL;
7.       do
8.       {
9.          png_compression_bufferp next = list->next;
10.          png_free(png_ptr, list);",Not Useful
/*PRIVATE*/,"-10.        * pretty much the same set of error codes.
-9.        */
-8.       if (ret == Z_OK)
-7.          png_ptr->zowner = owner;
-6.       else
-5.          png_zstream_error(png_ptr, ret);
-4.       return ret;
-3.    }
-2. }

/*PRIVATE*/

1. png_free_buffer_list(png_structrp png_ptr, png_compression_bufferp *listp)
2. {
3.    png_compression_bufferp list = *listp;
4.    if (list != NULL)
5.    {
6.       *listp = NULL;
7.       do
8.       {
9.          png_compression_bufferp next = list->next;
10.          png_free(png_ptr, list);",Not Useful
/*PRIVATE*/,"-10.        * pretty much the same set of error codes.
-9.        */
-8.       if (ret == Z_OK)
-7.          png_ptr->zowner = owner;
-6.       else
-5.          png_zstream_error(png_ptr, ret);
-4.       return ret;
-3.    }
-2. }

/*PRIVATE*/

1. png_free_buffer_list(png_structrp png_ptr, png_compression_bufferp *listp)
2. {
3.    png_compression_bufferp list = *listp;
4.    if (list != NULL)
5.    {
6.       *listp = NULL;
7.       do
8.       {
9.          png_compression_bufferp next = list->next;
10.          png_free(png_ptr, list);",Not Useful
/*PRIVATE*/,"-10.        * pretty much the same set of error codes.
-9.        */
-8.       if (ret == Z_OK)
-7.          png_ptr->zowner = owner;
-6.       else
-5.          png_zstream_error(png_ptr, ret);
-4.       return ret;
-3.    }
-2. }

/*PRIVATE*/

1. png_free_buffer_list(png_structrp png_ptr, png_compression_bufferp *listp)
2. {
3.    png_compression_bufferp list = *listp;
4.    if (list != NULL)
5.    {
6.       *listp = NULL;
7.       do
8.       {
9.          png_compression_bufferp next = list->next;
10.          png_free(png_ptr, list);",Not Useful
/*PRIVATE*/,"-10.        * pretty much the same set of error codes.
-9.        */
-8.       if (ret == Z_OK)
-7.          png_ptr->zowner = owner;
-6.       else
-5.          png_zstream_error(png_ptr, ret);
-4.       return ret;
-3.    }
-2. }

/*PRIVATE*/

1. png_free_buffer_list(png_structrp png_ptr, png_compression_bufferp *listp)
2. {
3.    png_compression_bufferp list = *listp;
4.    if (list != NULL)
5.    {
6.       *listp = NULL;
7.       do
8.       {
9.          png_compression_bufferp next = list->next;
10.          png_free(png_ptr, list);",Not Useful
/*WRITE_FILTER*/,"-4.    static PNG_CONST png_byte png_pass_yinc[7] = {8, 8, 8, 4, 4, 2, 2};
-3. #endif
-2.    png_alloc_size_t buf_size;
-1.    int usr_pixel_depth;
#ifdef PNG_WRITE_FILTER_SUPPORTED

/*WRITE_FILTER*/

1.    png_byte filters;
2. #endif
3.    png_debug(1, ""in png_write_start_row"");
4.    usr_pixel_depth = png_ptr->usr_channels * png_ptr->usr_bit_depth;
5.    buf_size = PNG_ROWBYTES(usr_pixel_depth, png_ptr->width) + 1;",Not Useful
/*PRIVATE*/,"-10.        * pretty much the same set of error codes.
-9.        */
-8.       if (ret == Z_OK)
-7.          png_ptr->zowner = owner;
-6.       else
-5.          png_zstream_error(png_ptr, ret);
-4.       return ret;
-3.    }
-2. }

/*PRIVATE*/

1. png_free_buffer_list(png_structrp png_ptr, png_compression_bufferp *listp)
2. {
3.    png_compression_bufferp list = *listp;
4.    if (list != NULL)
5.    {
6.       *listp = NULL;
7.       do
8.       {
9.          png_compression_bufferp next = list->next;
10.          png_free(png_ptr, list);",Not Useful
/*WRITE_FILTER*/,"-4.    static PNG_CONST png_byte png_pass_yinc[7] = {8, 8, 8, 4, 4, 2, 2};
-3. #endif
-2.    png_alloc_size_t buf_size;
-1.    int usr_pixel_depth;
#ifdef PNG_WRITE_FILTER_SUPPORTED

/*WRITE_FILTER*/

1.    png_byte filters;
2. #endif
3.    png_debug(1, ""in png_write_start_row"");
4.    usr_pixel_depth = png_ptr->usr_channels * png_ptr->usr_bit_depth;
5.    buf_size = PNG_ROWBYTES(usr_pixel_depth, png_ptr->width) + 1;",Not Useful
/*WRITE_FILTER*/,"-4.    static PNG_CONST png_byte png_pass_yinc[7] = {8, 8, 8, 4, 4, 2, 2};
-3. #endif
-2.    png_alloc_size_t buf_size;
-1.    int usr_pixel_depth;
#ifdef PNG_WRITE_FILTER_SUPPORTED

/*WRITE_FILTER*/

1.    png_byte filters;
2. #endif
3.    png_debug(1, ""in png_write_start_row"");
4.    usr_pixel_depth = png_ptr->usr_channels * png_ptr->usr_bit_depth;
5.    buf_size = PNG_ROWBYTES(usr_pixel_depth, png_ptr->width) + 1;",Not Useful
/*WRITE_FLUSH*/,"-1.    png_write_finish_row(png_ptr);
#ifdef PNG_WRITE_FLUSH_SUPPORTED

/*WRITE_FLUSH*/

1.    png_ptr->flush_rows++;
2.    if (png_ptr->flush_dist > 0 &&
3.        png_ptr->flush_rows >= png_ptr->flush_dist)
4.    {
5.       png_write_flush(png_ptr);
6.    }",Not Useful
/*PACKSWAP || WRITE_PACKSWAP*/,"-10.       else if (row_info->bit_depth == 2)
-9.          table = twobppswaptable;
-8.       else if (row_info->bit_depth == 4)
-7.          table = fourbppswaptable;
-6.       else
-5.          return;
-4.       for (rp = row; rp < end; rp++)
-3.          *rp = table[*rp];
-2.    }
-1. }

/*PACKSWAP || WRITE_PACKSWAP*/

1. #if defined(PNG_WRITE_FILLER_SUPPORTED) || \
2.     defined(PNG_READ_STRIP_ALPHA_SUPPORTED)",Not Useful
/*source pointer*/,"-2. png_do_strip_channel(png_row_infop row_info, png_bytep row, int at_start)
-1. {

/*source pointer*/

 ",Not Useful
/*destination pointer*/,"-3. png_do_strip_channel(png_row_infop row_info, png_bytep row, int at_start)
-2. {

/*destination pointer*/

 ",Not Useful
/*READ_BGR || WRITE_BGR*/,"-10.                *(rp + 4) = save;
-9.                save = *(rp + 1);
-8.                *(rp + 1) = *(rp + 5);
-7.                *(rp + 5) = save;
-6.             }
-5.          }
-4.       }
-3. #endif
-2.    }
-1. }

/*READ_BGR || WRITE_BGR*/

1. #if defined(PNG_READ_CHECK_FOR_INVALID_INDEX_SUPPORTED) || \
2.     defined(PNG_WRITE_CHECK_FOR_INVALID_INDEX_SUPPORTED)",Not Useful
/*num_palette can be 0 in MNG files*/,"-3. png_do_check_palette_indexes(png_structrp png_ptr, png_row_infop row_info)
-2. {
-1.    if (png_ptr->num_palette < (1 << row_info->bit_depth) &&

/*num_palette can be 0 in MNG files*/

1.    {",Not Useful
/*CHECK_FOR_INVALID_INDEX*/,"
#if defined(PNG_READ_CHECK_FOR_INVALID_INDEX_SUPPORTED) || \



/*CHECK_FOR_INVALID_INDEX*/

1.     defined(PNG_WRITE_CHECK_FOR_INVALID_INDEX_SUPPORTED)",Not Useful
/*USER_TRANSFORM_INFO*/,"-10.  */
-9. #ifdef PNG_USER_TRANSFORM_PTR_SUPPORTED
-8. png_voidp PNGAPI
-7. png_get_user_transform_ptr(png_const_structrp png_ptr)
-6. {
-5.    if (png_ptr == NULL)
-4.       return (NULL);
-3.    return png_ptr->user_transform_ptr;
-2. }
-1. #endif
#ifdef PNG_USER_TRANSFORM_INFO_SUPPORTED

/*USER_TRANSFORM_INFO*/

1. png_uint_32 PNGAPI
2. png_get_current_row_number(png_const_structrp png_ptr)
3. {",Not Useful
/*READ_USER_TRANSFORM || WRITE_USER_TRANSFORM*/,"-2. }

/*READ_USER_TRANSFORM || WRITE_USER_TRANSFORM*/

 ",Not Useful
/*png_set_invert_mono*/,"-10. {
-9.    UNUSED(colour_type)
-8.    this->next = *that;
-7.    *that = this;
-6.    return bit_depth < 8;
-5. }
-4. IT(packswap);
-3. #undef PT
-2. #define PT ITSTRUCT(packswap)

/*png_set_invert_mono*/

1. #ifdef PNG_READ_INVERT_MONO_SUPPORTED",Not Useful
/*PNG_READ_INVERT_MONO_SUPPORTED*/,"
#ifdef PNG_READ_INVERT_MONO_SUPPORTED



/*PNG_READ_INVERT_MONO_SUPPORTED*/

 ",Not Useful
/*SAFE*/,"-5.       {
-4.          png_size_t cb = st;
-3.          if (cb > STORE_BUFFER_SIZE - writepos)
-2.             cb = STORE_BUFFER_SIZE - writepos;

/*SAFE*/

1.          memcpy(ps->new.buffer + writepos, pb, cb);",Not Useful
/*SAFE*/,"-5.       {
-4.          png_size_t cb = st;
-3.          if (cb > STORE_BUFFER_SIZE - writepos)
-2.             cb = STORE_BUFFER_SIZE - writepos;

/*SAFE*/

1.          memcpy(ps->new.buffer + writepos, pb, cb);",Not Useful
/*SAFE*/,"-5.       {
-4.          png_size_t cb = st;
-3.          if (cb > STORE_BUFFER_SIZE - writepos)
-2.             cb = STORE_BUFFER_SIZE - writepos;

/*SAFE*/

1.          memcpy(ps->new.buffer + writepos, pb, cb);",Not Useful
/*SAFE*/,"-5.       {
-4.          png_size_t cb = st;
-3.          if (cb > STORE_BUFFER_SIZE - writepos)
-2.             cb = STORE_BUFFER_SIZE - writepos;

/*SAFE*/

1.          memcpy(ps->new.buffer + writepos, pb, cb);",Not Useful
/*SAFE*/,"-5.       {
-4.          png_size_t cb = st;
-3.          if (cb > STORE_BUFFER_SIZE - writepos)
-2.             cb = STORE_BUFFER_SIZE - writepos;

/*SAFE*/

1.          memcpy(ps->new.buffer + writepos, pb, cb);",Not Useful
/*PNG_READ_SHIFT_SUPPORTED*/,"
#ifdef PNG_READ_SHIFT_SUPPORTED



/*PNG_READ_SHIFT_SUPPORTED*/

 ",Not Useful
/*PNG_READ_TRANSFORMS_SUPPORTED*/,"-10.       pos = bufsize-1;
-9.    buffer[pos] = 0;
-8.    return pos;
-7. }
-6. static size_t safecatn(char *buffer, size_t bufsize, size_t pos, int n)
-5. {
-4.    char number[64];
-3.    sprintf(number, ""%d"", n);
-2.    return safecat(buffer, bufsize, pos, number);
-1. }
#ifdef PNG_READ_TRANSFORMS_SUPPORTED

/*PNG_READ_TRANSFORMS_SUPPORTED*/

1. static size_t safecatd(char *buffer, size_t bufsize, size_t pos, double d,
2.     int precision)
3. {
4.    char number[64];
5.    sprintf(number, ""%.*f"", precision, d);
6.    return safecat(buffer, bufsize, pos, number);
7. }
8. #endif
9. static const char invalid[] = ""invalid"";
10. static const char sep[] = "": "";",Not Useful
/*Local variables*/,"-3.    png_modifier*              pm;
-2.    const image_transform* transform_list;
-1.    unsigned int max_gamma_8;

/*Local variables*/

1.    png_byte output_colour_type;
2.    png_byte output_bit_depth;
3.    png_byte unpacked;",Not Useful
/*Standard fields*/,"-5. static void
-4. transform_display_init(transform_display *dp, png_modifier *pm, png_uint_32 id,
-3.     const image_transform *transform_list)
-2. {
-1.    memset(dp, 0, sizeof *dp);

/*Standard fields*/

1.    standard_display_init(&dp->this, &pm->this, id, do_read_interlace,
2.       pm->use_update_info);",Not Useful
/*Reuse the standard stuff as appropriate.*/,"-4. }
-3. static void
-2. transform_info_imp(transform_display *dp, png_structp pp, png_infop pi)
-1. {

/*Reuse the standard stuff as appropriate.*/

1.    standard_info_part1(&dp->this, pp, pi);",Not Useful
/*The following works both in 1.5.4 and earlier versions:*/,"-4.    if (dp->scale16)
-3. #     ifdef PNG_READ_SCALE_16_TO_8_SUPPORTED
-2.          png_set_scale_16(pp);
-1. #     else

/*The following works both in 1.5.4 and earlier versions:*/

1. #        ifdef PNG_READ_16_TO_8_SUPPORTED
2.             png_set_strip_16(pp);
3. #        else
4.             png_error(pp, ""scale16 (16 to 8 bit conversion) not supported"");
5. #        endif
6. #     endif
7.    if (dp->expand16)
8. #     ifdef PNG_READ_EXPAND_16_SUPPORTED
9.          png_set_expand_16(pp);
10. #     else",Not Useful
/*need_expand*/,"-2. #ifdef PNG_READ_BACKGROUND_SUPPORTED
-1. /* png_set_background(png_structp, png_const_color_16p background_color,
 *    int background_gamma_code, int need_expand, double background_gamma)

/*need_expand*/

1.  * png_set_background_fixed(png_structp, png_const_color_16p background_color,
2.  *    int background_gamma_code, int need_expand,
3.  *    png_fixed_point background_gamma)
4.  *
5.  * This ignores the gamma (at present.)
6. */
7. #define data ITDATA(background)
8. static image_pixel data;
9. static void
10. image_transform_png_set_background_set(const image_transform *this,",Not Useful
/*need_expand*/,"-2. #ifdef PNG_READ_BACKGROUND_SUPPORTED
-1. /* png_set_background(png_structp, png_const_color_16p background_color,
 *    int background_gamma_code, int need_expand, double background_gamma)

/*need_expand*/

1.  * png_set_background_fixed(png_structp, png_const_color_16p background_color,
2.  *    int background_gamma_code, int need_expand,
3.  *    png_fixed_point background_gamma)
4.  *
5.  * This ignores the gamma (at present.)
6. */
7. #define data ITDATA(background)
8. static image_pixel data;
9. static void
10. image_transform_png_set_background_set(const image_transform *this,",Not Useful
/*A component*/,"-5.             output_is_encoded = 0;
-4.             log_max_error = 0;
-3.          }
-2.       }
-1. #ifdef PNG_READ_ALPHA_MODE_SUPPORTED

/*A component*/

1.       {
2.          if (do_background == ALPHA_MODE_OFFSET + PNG_ALPHA_OPTIMIZED &&",Not Useful
/*Quantize this appropriately:*/,"-10.           * this encode input_sample adjusted by the maximum error (tmp) above.
-9.           */
-8.          es_lo = encoded_sample - vi->maxout;
-7.          if (es_lo > 0 && input_sample-tmp > 0)
-6.          {
-5.             double low_value = input_sample-tmp;
-4.             if (output_is_encoded)
-3.                low_value = pow(low_value, vi->screen_inverse);
-2.             low_value *= outmax;
-1.             if (low_value < es_lo) es_lo = low_value;

/*Quantize this appropriately:*/

1.             es_lo = ceil(es_lo / vi->outquant - .5) * vi->outquant;
2.          }
3.          else
4.             es_lo = 0;
5.          es_hi = encoded_sample + vi->maxout;
6.          if (es_hi < outmax && input_sample+tmp < 1)
7.          {
8.             double high_value = input_sample+tmp;
9.             if (output_is_encoded)
10.                high_value = pow(high_value, vi->screen_inverse);",Not Useful
/*!use_input_precision*/,"-10.                      if (!(od < is_lo || od > is_hi))
-9.                      {
-8.                         if (encoded_error < vi->outlog)
-7.                            return i;
-6.                         pass = ""within 8 bit limits:\n"";
-5.                      }
-4.                   }
-3. #              endif
-2. #           endif
-1.          }

/*!use_input_precision*/

1.             is_lo = es_lo, is_hi = es_hi;",Not Useful
/*FALLTHROUGH*/,"-4.    switch (dp->output_colour_type)
-3.    {
-2.    case PNG_COLOR_TYPE_PALETTE:
-1.       if (dp->output_bit_depth > 8) goto error;

/*FALLTHROUGH*/

1.    case PNG_COLOR_TYPE_GRAY:
2.       if (dp->output_bit_depth == 1 || dp->output_bit_depth == 2 ||
3.          dp->output_bit_depth == 4)
4.          break;",Not Useful
/*name' is the component name*/,"-2.             if (compose != do_compose)
-1.                png_error(vi->pp, ""internal error (compose)"");

/*name' is the component name*/

1.             pos = safecat(msg, sizeof msg, pos, name);
2.             pos = safecat(msg, sizeof msg, pos, ""("");
3.             pos = safecatn(msg, sizeof msg, pos, id);",Not Useful
/*component*/,"-10.     * all spectra that produce this response as the same color, therefore this
-9.     * is effectively a description of a color.
-8.     */
-7.    double X, Y, Z;
-6. } CIE_color;
-5. typedef struct color_encoding
-4. {
-3.    /* A description of an (R,G,B) encoding of color (as defined above); this
-2.     * includes the actual colors of the (R,G,B) triples (1,0,0), (0,1,0) and
-1.     * (0,0,1) plus an encoding value that is used to encode the linear
    * components R, G and B to give the actual values R^gamma, G^gamma and

/*component*/

1.     * B^gamma that are stored.
2.     */",Not Useful
/*component*/,"-10.     * all spectra that produce this response as the same color, therefore this
-9.     * is effectively a description of a color.
-8.     */
-7.    double X, Y, Z;
-6. } CIE_color;
-5. typedef struct color_encoding
-4. {
-3.    /* A description of an (R,G,B) encoding of color (as defined above); this
-2.     * includes the actual colors of the (R,G,B) triples (1,0,0), (0,1,0) and
-1.     * (0,0,1) plus an encoding value that is used to encode the linear
    * components R, G and B to give the actual values R^gamma, G^gamma and

/*component*/

1.     * B^gamma that are stored.
2.     */",Not Useful
/*component*/,"-10.     * all spectra that produce this response as the same color, therefore this
-9.     * is effectively a description of a color.
-8.     */
-7.    double X, Y, Z;
-6. } CIE_color;
-5. typedef struct color_encoding
-4. {
-3.    /* A description of an (R,G,B) encoding of color (as defined above); this
-2.     * includes the actual colors of the (R,G,B) triples (1,0,0), (0,1,0) and
-1.     * (0,0,1) plus an encoding value that is used to encode the linear
    * components R, G and B to give the actual values R^gamma, G^gamma and

/*component*/

1.     * B^gamma that are stored.
2.     */",Not Useful
/*component*/,"-10.     * all spectra that produce this response as the same color, therefore this
-9.     * is effectively a description of a color.
-8.     */
-7.    double X, Y, Z;
-6. } CIE_color;
-5. typedef struct color_encoding
-4. {
-3.    /* A description of an (R,G,B) encoding of color (as defined above); this
-2.     * includes the actual colors of the (R,G,B) triples (1,0,0), (0,1,0) and
-1.     * (0,0,1) plus an encoding value that is used to encode the linear
    * components R, G and B to give the actual values R^gamma, G^gamma and

/*component*/

1.     * B^gamma that are stored.
2.     */",Not Useful
/*No transform is expected on the threshold tests.*/,"-6.             }
-5.          }
-4.       }
-3.       else if (memcmp(std, pRow, cbRow) != 0)
-2.       {
-1.          char msg[64];

/*No transform is expected on the threshold tests.*/

1.          sprintf(msg, ""gamma: below threshold row %lu changed"",
2.             (unsigned long)y);
3.          png_error(pp, msg);
4.       }",Not Useful
/*row (y) loop*/,"-10.                out_pixel.blue, sample_depth, in_pixel.bluee,
-9.                dp->pm->limit + 1./(2*((1U<<in_pixel.blue_sBIT)-1)), ""blue"",
-8.                digitization_error);
-7.          if ((out_ct & PNG_COLOR_MASK_ALPHA) != 0 &&
-6.             in_pixel.alpha != out_pixel.alpha)
-5.             transform_range_check(pp, r, g, b, a, in_pixel.alpha,
-4.                in_pixel.alphaf, out_pixel.alpha, sample_depth, in_pixel.alphae,
-3.                dp->pm->limit + 1./(2*((1U<<in_pixel.alpha_sBIT)-1)), ""alpha"",
-2.                digitization_error);

/*row (y) loop*/

 ",Not Useful
/*modifier_read expects a png_modifier**/,"-4.          modifier_progressive_read(d.pm, pp, pi);
-3.       }
-2.       else
-1.       {

/*modifier_read expects a png_modifier**/

1.          png_set_read_fn(pp, d.pm, modifier_read);",Not Useful
/*sBIT*/,"-7. #define CHUNK(a,b,c,d) (((a)<<24)+((b)<<16)+((c)<<8)+(d))
-6. #define CHUNK_IHDR CHUNK(73,72,68,82)
-5. #define CHUNK_PLTE CHUNK(80,76,84,69)
-4. #define CHUNK_IDAT CHUNK(73,68,65,84)
-3. #define CHUNK_IEND CHUNK(73,69,78,68)
-2. #define CHUNK_cHRM CHUNK(99,72,82,77)
-1. #define CHUNK_gAMA CHUNK(103,65,77,65)
#define CHUNK_sBIT CHUNK(115,66,73,84)

/*sBIT*/

1. #define CHUNK_sRGB CHUNK(115,82,71,66)",Not Useful
/*threshold test*/,"-10.    {
-9.       vi->sbit = dp->sbit;
-8.       vi->isbit_shift = in_depth - dp->sbit;
-7.    }
-6.    else
-5.    {
-4.       vi->sbit = (png_byte)in_depth;
-3.       vi->isbit_shift = 0;
-2.    }
-1.    vi->sbit_max = (1U << vi->sbit)-1;
   /* This mimics the libpng threshold test, '0' is used to prevent gamma

/*threshold test*/

1.     * correction in the validation test.
2.     */
3.    vi->screen_gamma = dp->screen_gamma;
4.    if (fabs(vi->screen_gamma-1) < PNG_GAMMA_THRESHOLD)
5.       vi->screen_gamma = vi->screen_inverse = 0;
6.    else
7.       vi->screen_inverse = 1/vi->screen_gamma;
8.    vi->use_input_precision = dp->use_input_precision;
9.    vi->outmax = outmax;
10.    vi->maxabs = abserr(dp->pm, in_depth, out_depth);",Not Useful
/*no scale16*/,"-10. {
-9.    size_t pos = 0;
-8.    char name[64];
-7.    pos = safecat(name, sizeof name, pos, ""threshold "");
-6.    pos = safecatd(name, sizeof name, pos, file_gamma, 3);
-5.    pos = safecat(name, sizeof name, pos, ""/"");
-4.    pos = safecatd(name, sizeof name, pos, screen_gamma, 3);

/*no scale16*/

 ",Not Useful
/*hence*/,"-8. static int
-7. test_size(png_modifier* const pm, png_byte const colour_type,
-6.     int bdlo, int const bdhi)
-5. {
-4.    /* Run the tests on each combination.
-3.     *
-2.     * NOTE: on my 32 bit x86 each of the following blocks takes
-1.     * a total of 3.5 seconds if done across every combo of bit depth
    * width and height.  This is a waste of time in practice, hence the

/*hence*/

1.     * hinc and winc stuff:
2.     */
3.    static const png_byte hinc[] = {1, 3, 11, 1, 5};
4.    static const png_byte winc[] = {1, 9, 5, 7, 1};
5.    const int save_bdlo = bdlo;
6.    for (; bdlo <= bdhi; ++bdlo)
7.    {
8.       png_uint_32 h, w;
9.       for (h=1; h<=16; h+=hinc[bdlo]) for (w=1; w<=16; w+=winc[bdlo])
10.       {",Not Useful
/*sBIT*/,"-7. #define CHUNK(a,b,c,d) (((a)<<24)+((b)<<16)+((c)<<8)+(d))
-6. #define CHUNK_IHDR CHUNK(73,72,68,82)
-5. #define CHUNK_PLTE CHUNK(80,76,84,69)
-4. #define CHUNK_IDAT CHUNK(73,68,65,84)
-3. #define CHUNK_IEND CHUNK(73,69,78,68)
-2. #define CHUNK_cHRM CHUNK(99,72,82,77)
-1. #define CHUNK_gAMA CHUNK(103,65,77,65)
#define CHUNK_sBIT CHUNK(115,66,73,84)

/*sBIT*/

1. #define CHUNK_sRGB CHUNK(115,82,71,66)",Not Useful
/*scale16*/,"-1.    unsigned int             test_gamma_sbit :1;
   unsigned int             test_gamma_scale16 :1;

/*scale16*/

1.    unsigned int             test_gamma_background :1;
2.    unsigned int             test_gamma_alpha_mode :1;
3.    unsigned int             test_gamma_expand16 :1;
4.    unsigned int             test_exhaustive :1;",Not Useful
/*scale16*/,"-1.    unsigned int             test_gamma_sbit :1;
   unsigned int             test_gamma_scale16 :1;

/*scale16*/

1.    unsigned int             test_gamma_background :1;
2.    unsigned int             test_gamma_alpha_mode :1;
3.    unsigned int             test_gamma_expand16 :1;
4.    unsigned int             test_exhaustive :1;",Not Useful
/*scale16*/,"-1.    unsigned int             test_gamma_sbit :1;
   unsigned int             test_gamma_scale16 :1;

/*scale16*/

1.    unsigned int             test_gamma_background :1;
2.    unsigned int             test_gamma_alpha_mode :1;
3.    unsigned int             test_gamma_expand16 :1;
4.    unsigned int             test_exhaustive :1;",Not Useful
/*scale16*/,"-1.    unsigned int             test_gamma_sbit :1;
   unsigned int             test_gamma_scale16 :1;

/*scale16*/

1.    unsigned int             test_gamma_background :1;
2.    unsigned int             test_gamma_alpha_mode :1;
3.    unsigned int             test_gamma_expand16 :1;
4.    unsigned int             test_exhaustive :1;",Not Useful
/*scale16*/,"-1.    unsigned int             test_gamma_sbit :1;
   unsigned int             test_gamma_scale16 :1;

/*scale16*/

1.    unsigned int             test_gamma_background :1;
2.    unsigned int             test_gamma_alpha_mode :1;
3.    unsigned int             test_gamma_expand16 :1;
4.    unsigned int             test_exhaustive :1;",Not Useful
/*should not be used*/,"-4.    switch (do_background)
-3.    {
-2.       default:
-1.          base = """";

/*should not be used*/

1.          break;
2.       case PNG_BACKGROUND_GAMMA_SCREEN:
3.          base = "" bckg(Screen):"";
4.          bg = 1/screen_gamma;
5.          break;
6.       case PNG_BACKGROUND_GAMMA_FILE:
7.          base = "" bckg(File):"";
8.          bg = file_gamma;
9.          break;
10.       case PNG_BACKGROUND_GAMMA_UNIQUE:",Not Useful
/*should not be used*/,"-4.    switch (do_background)
-3.    {
-2.       default:
-1.          base = """";

/*should not be used*/

1.          break;
2.       case PNG_BACKGROUND_GAMMA_SCREEN:
3.          base = "" bckg(Screen):"";
4.          bg = 1/screen_gamma;
5.          break;
6.       case PNG_BACKGROUND_GAMMA_FILE:
7.          base = "" bckg(File):"";
8.          bg = file_gamma;
9.          break;
10.       case PNG_BACKGROUND_GAMMA_UNIQUE:",Not Useful
/*should not be used*/,"-4.    switch (do_background)
-3.    {
-2.       default:
-1.          base = """";

/*should not be used*/

1.          break;
2.       case PNG_BACKGROUND_GAMMA_SCREEN:
3.          base = "" bckg(Screen):"";
4.          bg = 1/screen_gamma;
5.          break;
6.       case PNG_BACKGROUND_GAMMA_FILE:
7.          base = "" bckg(File):"";
8.          bg = file_gamma;
9.          break;
10.       case PNG_BACKGROUND_GAMMA_UNIQUE:",Not Useful
/*should not be used*/,"-4.    switch (do_background)
-3.    {
-2.       default:
-1.          base = """";

/*should not be used*/

1.          break;
2.       case PNG_BACKGROUND_GAMMA_SCREEN:
3.          base = "" bckg(Screen):"";
4.          bg = 1/screen_gamma;
5.          break;
6.       case PNG_BACKGROUND_GAMMA_FILE:
7.          base = "" bckg(File):"";
8.          bg = file_gamma;
9.          break;
10.       case PNG_BACKGROUND_GAMMA_UNIQUE:",Not Useful
/*should not be used*/,"-4.    switch (do_background)
-3.    {
-2.       default:
-1.          base = """";

/*should not be used*/

1.          break;
2.       case PNG_BACKGROUND_GAMMA_SCREEN:
3.          base = "" bckg(Screen):"";
4.          bg = 1/screen_gamma;
5.          break;
6.       case PNG_BACKGROUND_GAMMA_FILE:
7.          base = "" bckg(File):"";
8.          bg = file_gamma;
9.          break;
10.       case PNG_BACKGROUND_GAMMA_UNIQUE:",Not Useful
/*sBIT*/,"-7. #define CHUNK(a,b,c,d) (((a)<<24)+((b)<<16)+((c)<<8)+(d))
-6. #define CHUNK_IHDR CHUNK(73,72,68,82)
-5. #define CHUNK_PLTE CHUNK(80,76,84,69)
-4. #define CHUNK_IDAT CHUNK(73,68,65,84)
-3. #define CHUNK_IEND CHUNK(73,69,78,68)
-2. #define CHUNK_cHRM CHUNK(99,72,82,77)
-1. #define CHUNK_gAMA CHUNK(103,65,77,65)
#define CHUNK_sBIT CHUNK(115,66,73,84)

/*sBIT*/

1. #define CHUNK_sRGB CHUNK(115,82,71,66)",Not Useful
/*strip 16*/,"-4. #     ifdef PNG_READ_ACCURATE_SCALE_SUPPORTED
-3. #        if PNG_LIBPNG_VER >= 10504
-2. #           error PNG_READ_ACCURATE_SCALE should not be set
-1. #        endif
         /* The strip 16 algorithm drops the low 8 bits rather than calculating

/*strip 16*/

1.           * 1/257, so we need to adjust the permitted errors appropriately:
2.           * Notice that this is only relevant prior to the addition of the
3.           * png_set_scale_16 API in 1.5.4 (but 1.5.4+ always defines the above!)
4.           */
5.          {
6.             const double d = (255-128.5)/65535;
7.             that->rede += d;
8.             that->greene += d;
9.             that->bluee += d;
10.             that->alphae += d;",Not Useful
/*who*/,"-2.    ps->cb_row = cbRow;
-1.    ps->image_h = cRows;
   /* For error checking, the whole buffer is set to 10110010 (0xb2 - 178).

/*who*/

1.     * This deliberately doesn't match the bits in the size test image which are
2.     * outside the image; these are set to 0xff (all 1).  To make the row
3.     * comparison work in the 'size' test case the size rows are pre-initialized
4.     * to the same value prior to calling 'standard_row'.
5.     */
6.    memset(ps->image, 178, cb);",Not Useful
/*Should be READ_16BIT_SUPPORTED*/,"-3.       if (fail(pm))
-2.          return;
-1.    }

/*Should be READ_16BIT_SUPPORTED*/

1.    if (pm->test_gamma_scale16)
2.    {",Not Useful
/*PNG_READ_SUPPORTED*/,"-6. static png_fixed_point
-5. fix(double d)
-4. {
-3.    d = floor(d * PNG_FP_1 + .5);
-2.    return (png_fixed_point)d;
-1. }

/*PNG_READ_SUPPORTED*/

 ",Not Useful
/*Is row 'y' in pass 'pass'?*/,"-4. }
-3. static int
-2. png_row_in_interlace_pass(png_uint_32 y, int pass)
-1. {

/*Is row 'y' in pass 'pass'?*/

1.    int x;
2.    y &= 7;
3.    ++pass;
4.    for (x=0; x<8; ++x) if (adam7[y][x] == pass)
5.       return 1;
6.    return 0;
7. }
8. static int
9. png_col_in_interlace_pass(png_uint_32 x, int pass)
10. {",Not Useful
/*Is column 'x' in pass 'pass'?*/,"-10.    int x;
-9.    y &= 7;
-8.    ++pass;
-7.    for (x=0; x<8; ++x) if (adam7[y][x] == pass)
-6.       return 1;
-5.    return 0;
-4. }
-3. static int
-2. png_col_in_interlace_pass(png_uint_32 x, int pass)
-1. {

/*Is column 'x' in pass 'pass'?*/

1.    int y;
2.    x &= 7;
3.    ++pass;
4.    for (y=0; y<8; ++y) if (adam7[y][x] == pass)
5.       return 1;
6.    return 0;
7. }
8. static png_uint_32
9. png_pass_rows(png_uint_32 height, int pass)
10. {",Not Useful
/*Kodak ProPhoto (wide gamut)*/,"-10.  * The png_modifier code assumes that encodings[0] is sRGB and treats it
-9.  * specially: do not change the first entry in this list!
-8.  */
-7. static const color_encoding test_encodings[] =
-6. {

/*Kodak ProPhoto (wide gamut)*/

 ",Not Useful
/*png_structp*/,"
#  define png_const_structp png_structp



/*png_structp*/

1. #endif
2. #ifndef RELEASE_BUILD",Not Useful
/*main program*/,"-10.     */
-9.    if (signum != SIGTERM)
-8.    {
-7.       struct exception_context *the_exception_context =
-6.          &pm.this.exception_context;
-5.       Throw &pm.this;
-4.    }
-3.    else
-2.       exit(1);
-1. }

/*main program*/

1. int main(int argc, char **argv)
2. {",Not Useful
/*And the test encodings*/,"-10.     * this is fixed turn them off for some gamma cases:
-9.     */
-8. #  ifdef PNG_WRITE_tRNS_SUPPORTED
-7.       pm.test_tRNS = 1;
-6. #  endif
-5.    pm.test_lbg = PNG_LIBPNG_VER >= 10600;
-4.    pm.test_lbg_gamma_threshold = 1;
-3.    pm.test_lbg_gamma_transform = PNG_LIBPNG_VER >= 10600;
-2.    pm.test_lbg_gamma_sbit = 1;
-1.    pm.test_lbg_gamma_composition = PNG_LIBPNG_VER >= 10700;

/*And the test encodings*/

1.    pm.encodings = test_encodings;
2.    pm.nencodings = ARRAY_SIZE(test_encodings);
3. #  if PNG_LIBPNG_VER < 10700",Not Useful
/*1/20000*/,"-10.    pm.use_input_precision_16to8 = 1U;

/*1/20000*/

 ",Not Useful
/*1/20000*/,"-10.    pm.use_input_precision_16to8 = 1U;

/*1/20000*/

 ",Not Useful
"/*I.e., 1/200% - 1/20000*/","-10.       pm.maxcalcG = 1./((1<<16)-1);
-9. #  endif

/*I.e., 1/200% - 1/20000*/

 ",Not Useful
/*PNG_READ_TRANSFORMS_SUPPORTED*/,"-10.       pos = bufsize-1;
-9.    buffer[pos] = 0;
-8.    return pos;
-7. }
-6. static size_t safecatn(char *buffer, size_t bufsize, size_t pos, int n)
-5. {
-4.    char number[64];
-3.    sprintf(number, ""%d"", n);
-2.    return safecat(buffer, bufsize, pos, number);
-1. }
#ifdef PNG_READ_TRANSFORMS_SUPPORTED

/*PNG_READ_TRANSFORMS_SUPPORTED*/

1. static size_t safecatd(char *buffer, size_t bufsize, size_t pos, double d,
2.     int precision)
3. {
4.    char number[64];
5.    sprintf(number, ""%.*f"", precision, d);
6.    return safecat(buffer, bufsize, pos, number);
7. }
8. #endif
9. static const char invalid[] = ""invalid"";
10. static const char sep[] = "": "";",Not Useful
/*!CAN_WRITE_INTERLACE*/,"-4.       else if (strcmp(*argv, ""--interlace"") == 0)
-3.       {
-2. #        if CAN_WRITE_INTERLACE
-1.             pm.interlace_type = PNG_INTERLACE_ADAM7;

/*!CAN_WRITE_INTERLACE*/

1.             fprintf(stderr, ""pngvalid: no write interlace support\n"");
2.             return SKIP;",Not Useful
/*!CAN_WRITE_INTERLACE*/,"-4.       else if (strcmp(*argv, ""--interlace"") == 0)
-3.       {
-2. #        if CAN_WRITE_INTERLACE
-1.             pm.interlace_type = PNG_INTERLACE_ADAM7;

/*!CAN_WRITE_INTERLACE*/

1.             fprintf(stderr, ""pngvalid: no write interlace support\n"");
2.             return SKIP;",Not Useful
/*PNG_SET_OPTION_SUPPORTED*/,"-10. #     ifdef PNG_USER_MEM_SUPPORTED
-9.          if (!ps->speed)
-8.             ps->pwrite = png_create_write_struct_2(PNG_LIBPNG_VER_STRING,
-7.                ps, store_error, store_warning, &ps->write_memory_pool,
-6.                store_malloc, store_free);
-5.          else
-4. #     endif
-3.          ps->pwrite = png_create_write_struct(PNG_LIBPNG_VER_STRING,
-2.             ps, store_error, store_warning);
-1.       png_set_write_fn(ps->pwrite, ps, store_write, store_flush);
#     ifdef PNG_SET_OPTION_SUPPORTED

/*PNG_SET_OPTION_SUPPORTED*/

1.          {
2.             int opt;
3.             for (opt=0; opt<ps->noptions; ++opt)
4.                if (png_set_option(ps->pwrite, ps->options[opt].option,
5.                   ps->options[opt].setting) == PNG_OPTION_INVALID)
6.                   png_error(ps->pwrite, ""png option invalid"");
7.          }
8. #     endif
9.       if (ppi != NULL)
10.          *ppi = ps->piwrite = png_create_info_struct(ps->pwrite);",Not Useful
/*consumed an extra *argv*/,"-5.       else
-4.       {
-3.          fprintf(stderr, ""pngvalid: %s: unknown argument\n"", *argv);
-2.          exit(99);
-1.       }

/*consumed an extra *argv*/

1.       {
2.          cp = safecat(command, sizeof command, cp, "" "");
3.          cp = safecat(command, sizeof command, cp, *argv);
4.       }
5.    }",Not Useful
/*Nothing to test so turn everything off:*/,"-10.    {
-9.       pm.test_gamma_threshold = 1;
-8.       pm.test_gamma_transform = 1;
-7.       pm.test_gamma_sbit = 1;
-6.       pm.test_gamma_scale16 = 1;
-5.       pm.test_gamma_background = 1;
-4.       pm.test_gamma_alpha_mode = 1;
-3.    }
-2.    else if (pm.ngamma_tests == 0)
-1.    {

/*Nothing to test so turn everything off:*/

1.       pm.test_gamma_threshold = 0;
2.       pm.test_gamma_transform = 0;
3.       pm.test_gamma_sbit = 0;
4.       pm.test_gamma_scale16 = 0;
5.       pm.test_gamma_background = 0;
6.       pm.test_gamma_alpha_mode = 0;
7.    }
8.    Try
9.    {",Not Useful
/*Combinatorial transforms:*/,"-8.       if (pm.test_size)
-7.       {
-6.          make_size_images(&pm.this);
-5. #        ifdef PNG_READ_SUPPORTED
-4.             perform_size_test(&pm);
-3. #        endif
-2.       }
-1. #ifdef PNG_READ_TRANSFORMS_SUPPORTED

/*Combinatorial transforms:*/

1.       if (pm.test_transform)
2.          perform_transform_test(&pm);",Not Useful
/*PNG_READ_TRANSFORMS_SUPPORTED*/,"-10.       pos = bufsize-1;
-9.    buffer[pos] = 0;
-8.    return pos;
-7. }
-6. static size_t safecatn(char *buffer, size_t bufsize, size_t pos, int n)
-5. {
-4.    char number[64];
-3.    sprintf(number, ""%d"", n);
-2.    return safecat(buffer, bufsize, pos, number);
-1. }
#ifdef PNG_READ_TRANSFORMS_SUPPORTED

/*PNG_READ_TRANSFORMS_SUPPORTED*/

1. static size_t safecatd(char *buffer, size_t bufsize, size_t pos, double d,
2.     int precision)
3. {
4.    char number[64];
5.    sprintf(number, ""%.*f"", precision, d);
6.    return safecat(buffer, bufsize, pos, number);
7. }
8. #endif
9. static const char invalid[] = ""invalid"";
10. static const char sep[] = "": "";",Not Useful
/*So the test is skipped:*/,"-4. int main(void)
-3. {
-2.    fprintf(stderr,
-1.       ""pngvalid: no low level write support in libpng, all tests skipped\n"");

/*So the test is skipped:*/

1.    return SKIP;
2. }
3. #endif",Not Useful
/*!EOF*/,"-5.    for (i=8; i; i--)
-4.    {
-3.       GETBREAK;
-2.       putchar(c);
-1.    }

/*!EOF*/

1. for (;;)
2.  {",Not Useful
/*EOF*/,"-10.  *
-9.  *     gcc -O -o png-fix-itxt png-fix-itxt.c -lz
-8.  *
-7.  * If you need to handle iTXt chunks larger than 500000 kbytes you must
-6.  * rebuild png-fix-itxt with a larger values of MAX_LENGTH (or a smaller value
-5.  * if you know you will never encounter such huge iTXt chunks).
-4.  */
-3. #include <stdio.h>
-2. #include <zlib.h>
-1. #define MAX_LENGTH 500000

/*EOF*/

1. #define GETBREAK inchar=getchar(); \
2.                  c=(inchar & 0xffU);\
3.                  if (inchar != c) break
4. int
5. main(void)
6. {
7.    unsigned int i;
8.    unsigned char buf[MAX_LENGTH];
9.    unsigned long crc;
10.    unsigned char c;",Not Useful
/*Calculate the CRC*/,"-1.          break;

/*Calculate the CRC*/

1.       crc = crc32(crc, buf+4, (uInt)length+4);
2.       for (;;)
3.       {",Not Useful
/*EOF*/,"-10.  *
-9.  *     gcc -O -o png-fix-itxt png-fix-itxt.c -lz
-8.  *
-7.  * If you need to handle iTXt chunks larger than 500000 kbytes you must
-6.  * rebuild png-fix-itxt with a larger values of MAX_LENGTH (or a smaller value
-5.  * if you know you will never encounter such huge iTXt chunks).
-4.  */
-3. #include <stdio.h>
-2. #include <zlib.h>
-1. #define MAX_LENGTH 500000

/*EOF*/

1. #define GETBREAK inchar=getchar(); \
2.                  c=(inchar & 0xffU);\
3.                  if (inchar != c) break
4. int
5. main(void)
6. {
7.    unsigned int i;
8.    unsigned char buf[MAX_LENGTH];
9.    unsigned long crc;
10.    unsigned char c;",Not Useful
/*EOF*/,"-10.  *
-9.  *     gcc -O -o png-fix-itxt png-fix-itxt.c -lz
-8.  *
-7.  * If you need to handle iTXt chunks larger than 500000 kbytes you must
-6.  * rebuild png-fix-itxt with a larger values of MAX_LENGTH (or a smaller value
-5.  * if you know you will never encounter such huge iTXt chunks).
-4.  */
-3. #include <stdio.h>
-2. #include <zlib.h>
-1. #define MAX_LENGTH 500000

/*EOF*/

1. #define GETBREAK inchar=getchar(); \
2.                  c=(inchar & 0xffU);\
3.                  if (inchar != c) break
4. int
5. main(void)
6. {
7.    unsigned int i;
8.    unsigned char buf[MAX_LENGTH];
9.    unsigned long crc;
10.    unsigned char c;",Not Useful
/*EOF*/,"-10.  *
-9.  *     gcc -O -o png-fix-itxt png-fix-itxt.c -lz
-8.  *
-7.  * If you need to handle iTXt chunks larger than 500000 kbytes you must
-6.  * rebuild png-fix-itxt with a larger values of MAX_LENGTH (or a smaller value
-5.  * if you know you will never encounter such huge iTXt chunks).
-4.  */
-3. #include <stdio.h>
-2. #include <zlib.h>
-1. #define MAX_LENGTH 500000

/*EOF*/

1. #define GETBREAK inchar=getchar(); \
2.                  c=(inchar & 0xffU);\
3.                  if (inchar != c) break
4. int
5. main(void)
6. {
7.    unsigned int i;
8.    unsigned char buf[MAX_LENGTH];
9.    unsigned long crc;
10.    unsigned char c;",Not Useful
/*EOF*/,"-10.  *
-9.  *     gcc -O -o png-fix-itxt png-fix-itxt.c -lz
-8.  *
-7.  * If you need to handle iTXt chunks larger than 500000 kbytes you must
-6.  * rebuild png-fix-itxt with a larger values of MAX_LENGTH (or a smaller value
-5.  * if you know you will never encounter such huge iTXt chunks).
-4.  */
-3. #include <stdio.h>
-2. #include <zlib.h>
-1. #define MAX_LENGTH 500000

/*EOF*/

1. #define GETBREAK inchar=getchar(); \
2.                  c=(inchar & 0xffU);\
3.                  if (inchar != c) break
4. int
5. main(void)
6. {
7.    unsigned int i;
8.    unsigned char buf[MAX_LENGTH];
9.    unsigned long crc;
10.    unsigned char c;",Not Useful
/*WRITE_16BIT*/,"-10.             png_uint_32 row_width = row_info->width;
-9.             for (i = 0, sp = dp = row; i < row_width; i++)
-8.             {
-7.                png_byte save = *(sp++);
-6.                *(dp++) = *(sp++);
-5.                *(dp++) = *(sp++);
-4.                *(dp++) = *(sp++);
-3.                *(dp++) = save;
-2.             }
-1.          }
#ifdef PNG_WRITE_16BIT_SUPPORTED

/*WRITE_16BIT*/

1.          else
2.          {",Not Useful
/*WRITE_16BIT*/,"-10.             png_uint_32 row_width = row_info->width;
-9.             for (i = 0, sp = dp = row; i < row_width; i++)
-8.             {
-7.                png_byte save = *(sp++);
-6.                *(dp++) = *(sp++);
-5.                *(dp++) = *(sp++);
-4.                *(dp++) = *(sp++);
-3.                *(dp++) = save;
-2.             }
-1.          }
#ifdef PNG_WRITE_16BIT_SUPPORTED

/*WRITE_16BIT*/

1.          else
2.          {",Not Useful
"/*Does nothing
               *(dp++) = *(sp++);
               *(dp++) = *(sp++);
               *(dp++) = *(sp++);*/","-5.             png_bytep sp, dp;
-4.             png_uint_32 i;
-3.             png_uint_32 row_width = row_info->width;
-2.             for (i = 0, sp = dp = row; i < row_width; i++)
-1.             {
               /* Does nothing
               *(dp++) = *(sp++);
               *(dp++) = *(sp++);

/*Does nothing
               *(dp++) = *(sp++);
               *(dp++) = *(sp++);
               *(dp++) = *(sp++);*/

1.                */
2.                sp+=2; dp = sp;
3.                *(dp++) = (png_byte)(255 - *(sp++));
4.                *dp     = (png_byte)(255 - *(sp++));
5.             }
6.          }",Not Useful
"/*Does nothing
               *(dp++) = *(sp++);
               *(dp++) = *(sp++);
               *(dp++) = *(sp++);
               *(dp++) = *(sp++);
               *(dp++) = *(sp++);
               *(dp++) = *(sp++);*/","-5.             png_bytep sp, dp;
-4.             png_uint_32 i;
-3.             png_uint_32 row_width = row_info->width;
-2.             for (i = 0, sp = dp = row; i < row_width; i++)
-1.             {
               /* Does nothing
               *(dp++) = *(sp++);
               *(dp++) = *(sp++);

/*Does nothing
               *(dp++) = *(sp++);
               *(dp++) = *(sp++);
               *(dp++) = *(sp++);
               *(dp++) = *(sp++);
               *(dp++) = *(sp++);
               *(dp++) = *(sp++);*/

1.                */
2.                sp+=2; dp = sp;
3.                *(dp++) = (png_byte)(255 - *(sp++));
4.                *dp     = (png_byte)(255 - *(sp++));
5.             }
6.          }",Not Useful
/*WRITE_16BIT*/,"-10.             png_uint_32 row_width = row_info->width;
-9.             for (i = 0, sp = dp = row; i < row_width; i++)
-8.             {
-7.                png_byte save = *(sp++);
-6.                *(dp++) = *(sp++);
-5.                *(dp++) = *(sp++);
-4.                *(dp++) = *(sp++);
-3.                *(dp++) = save;
-2.             }
-1.          }
#ifdef PNG_WRITE_16BIT_SUPPORTED

/*WRITE_16BIT*/

1.          else
2.          {",Not Useful
"/*Does nothing
               *(dp++) = *(sp++);
               *(dp++) = *(sp++);*/","-5.             png_bytep sp, dp;
-4.             png_uint_32 i;
-3.             png_uint_32 row_width = row_info->width;
-2.             for (i = 0, sp = dp = row; i < row_width; i++)
-1.             {
               /* Does nothing
               *(dp++) = *(sp++);
               *(dp++) = *(sp++);

/*Does nothing
               *(dp++) = *(sp++);
               *(dp++) = *(sp++);*/

1.                */
2.                sp+=2; dp = sp;
3.                *(dp++) = (png_byte)(255 - *(sp++));
4.                *dp     = (png_byte)(255 - *(sp++));
5.             }
6.          }",Not Useful
/*WRITE_16BIT*/,"-10.             png_uint_32 row_width = row_info->width;
-9.             for (i = 0, sp = dp = row; i < row_width; i++)
-8.             {
-7.                png_byte save = *(sp++);
-6.                *(dp++) = *(sp++);
-5.                *(dp++) = *(sp++);
-4.                *(dp++) = *(sp++);
-3.                *(dp++) = save;
-2.             }
-1.          }
#ifdef PNG_WRITE_16BIT_SUPPORTED

/*WRITE_16BIT*/

1.          else
2.          {",Not Useful
/*png_ptr*/,"
png_do_write_transformations(png_structrp png_ptr, png_row_infop row_info)



/*png_ptr*/

1. {
2.    png_debug(1, ""in png_do_write_transformations"");
3.    if (png_ptr == NULL)
4.       return;
5. #ifdef PNG_WRITE_USER_TRANSFORM_SUPPORTED
6.    if ((png_ptr->transformations & PNG_USER_TRANSFORM) != 0)
7.       if (png_ptr->write_user_transform_fn != NULL)",Not Useful
/*row_info:*/,"-10. {
-9.    png_debug(1, ""in png_do_write_transformations"");
-8.    if (png_ptr == NULL)
-7.       return;
-6. #ifdef PNG_WRITE_USER_TRANSFORM_SUPPORTED
-5.    if ((png_ptr->transformations & PNG_USER_TRANSFORM) != 0)
-4.       if (png_ptr->write_user_transform_fn != NULL)

/*row_info:*/

 ",Not Useful
/*png_uint_32 width;       width of row*/,"-10.    png_debug(1, ""in png_do_write_transformations"");
-9.    if (png_ptr == NULL)
-8.       return;
-7. #ifdef PNG_WRITE_USER_TRANSFORM_SUPPORTED
-6.    if ((png_ptr->transformations & PNG_USER_TRANSFORM) != 0)
-5.       if (png_ptr->write_user_transform_fn != NULL)

/*png_uint_32 width;       width of row*/

 ",Not Useful
/*WRITE_TRANSFORMS*/,"-10.  * Copyright (c) 1998-2002,2004,2006-2016 Glenn Randers-Pehrson
-9.  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
-8.  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
-7.  *
-6.  * This code is released under the libpng license.
-5.  * For conditions of distribution and use, see the disclaimer
-4.  * and license in png.h
-3.  */
-2. #include ""pngpriv.h""
-1. #ifdef PNG_WRITE_SUPPORTED
#ifdef PNG_WRITE_TRANSFORMS_SUPPORTED

/*WRITE_TRANSFORMS*/

1. #ifdef PNG_WRITE_PACK_SUPPORTED",Not Useful
/*FLOATING_POINT*/,"-10.    XYZ.green_Y = int_green_Y;
-9.    XYZ.green_Z = int_green_Z;
-8.    XYZ.blue_X = int_blue_X;
-7.    XYZ.blue_Y = int_blue_Y;
-6.    XYZ.blue_Z = int_blue_Z;
-5.    if (png_colorspace_set_endpoints(png_ptr, &info_ptr->colorspace,
-4.        &XYZ, 2) != 0)
-3.       info_ptr->colorspace.flags |= PNG_COLORSPACE_FROM_cHRM;
-2.    png_colorspace_sync_info(png_ptr, info_ptr);
-1. }
#  ifdef PNG_FLOATING_POINT_SUPPORTED

/*FLOATING_POINT*/

1. void PNGAPI
2. png_set_cHRM(png_const_structrp png_ptr, png_inforp info_ptr,
3.     double white_x, double white_y, double red_x, double red_y,
4.     double green_x, double green_y, double blue_x, double blue_y)
5. {
6.    png_set_cHRM_fixed(png_ptr, info_ptr,
7.        png_fixed(png_ptr, white_x, ""cHRM White X""),
8.        png_fixed(png_ptr, white_y, ""cHRM White Y""),
9.        png_fixed(png_ptr, red_x, ""cHRM Red X""),
10.        png_fixed(png_ptr, red_y, ""cHRM Red Y""),",Not Useful
/*cHRM*/,"-10. png_set_bKGD(png_const_structrp png_ptr, png_inforp info_ptr,
-9.     png_const_color_16p background)
-8. {
-7.    png_debug1(1, ""in %s storage function"", ""bKGD"");
-6.    if (png_ptr == NULL || info_ptr == NULL || background == NULL)
-5.       return;
-4.    info_ptr->background = *background;
-3.    info_ptr->valid |= PNG_INFO_bKGD;
-2. }
-1. #endif
#ifdef PNG_cHRM_SUPPORTED

/*cHRM*/

1. void PNGFAPI
2. png_set_cHRM_fixed(png_const_structrp png_ptr, png_inforp info_ptr,
3.     png_fixed_point white_x, png_fixed_point white_y, png_fixed_point red_x,
4.     png_fixed_point red_y, png_fixed_point green_x, png_fixed_point green_y,
5.     png_fixed_point blue_x, png_fixed_point blue_y)
6. {
7.    png_xy xy;
8.    png_debug1(1, ""in %s storage function"", ""cHRM fixed"");
9.    if (png_ptr == NULL || info_ptr == NULL)
10.       return;",Not Useful
/*eXIf*/,"
#ifdef PNG_eXIf_SUPPORTED



/*eXIf*/

1. void PNGAPI
2. png_set_eXIf(png_const_structrp png_ptr, png_inforp info_ptr,
3.     const png_bytep eXIf_buf)
4. {
5.   png_warning(png_ptr, ""png_set_eXIf does not work; use png_set_eXIf_1"");
6.   PNG_UNUSED(info_ptr)
7.   PNG_UNUSED(eXIf_buf)
8. }
9. void PNGAPI
10. png_set_eXIf_1(png_const_structrp png_ptr, png_inforp info_ptr,",Not Useful
/*Validate params[nparams]*/,"-10.       png_chunk_report(png_ptr, ""Invalid pCAL equation type"",
-9.             PNG_CHUNK_WRITE_ERROR);
-8.       return;
-7.    }
-6.    if (nparams < 0 || nparams > 255)
-5.    {
-4.       png_chunk_report(png_ptr, ""Invalid pCAL parameter count"",
-3.             PNG_CHUNK_WRITE_ERROR);
-2.       return;
-1.    }

/*Validate params[nparams]*/

1.    for (i=0; i<nparams; ++i)
2.    {
3.       if (params[i] == NULL ||
4.           !png_check_fp_string(params[i], strlen(params[i])))
5.       {
6.          png_chunk_report(png_ptr, ""Invalid format for pCAL parameter"",
7.                PNG_CHUNK_WRITE_ERROR);
8.          return;
9.       }
10.    }",Not Useful
/*-'*/,"-3.    if (unit != 1 && unit != 2)
-2.       png_error(png_ptr, ""Invalid sCAL unit"");
-1.    if (swidth == NULL || (lengthw = strlen(swidth)) == 0 ||

/*-'*/

1.       png_error(png_ptr, ""Invalid sCAL width"");
2.    if (sheight == NULL || (lengthh = strlen(sheight)) == 0 ||",Not Useful
/*-'*/,"-3.    if (unit != 1 && unit != 2)
-2.       png_error(png_ptr, ""Invalid sCAL unit"");
-1.    if (swidth == NULL || (lengthw = strlen(swidth)) == 0 ||

/*-'*/

1.       png_error(png_ptr, ""Invalid sCAL width"");
2.    if (sheight == NULL || (lengthh = strlen(sheight)) == 0 ||",Not Useful
/*sRGB*/,"-10. png_set_sBIT(png_const_structrp png_ptr, png_inforp info_ptr,
-9.     png_const_color_8p sig_bit)
-8. {
-7.    png_debug1(1, ""in %s storage function"", ""sBIT"");
-6.    if (png_ptr == NULL || info_ptr == NULL || sig_bit == NULL)
-5.       return;
-4.    info_ptr->sig_bit = *sig_bit;
-3.    info_ptr->valid |= PNG_INFO_sBIT;
-2. }
-1. #endif
#ifdef PNG_sRGB_SUPPORTED

/*sRGB*/

1. void PNGAPI
2. png_set_sRGB(png_const_structrp png_ptr, png_inforp info_ptr, int srgb_intent)
3. {
4.    png_debug1(1, ""in %s storage function"", ""sRGB"");
5.    if (png_ptr == NULL || info_ptr == NULL)
6.       return;
7.    (void)png_colorspace_set_sRGB(png_ptr, &info_ptr->colorspace, srgb_intent);
8.    png_colorspace_sync_info(png_ptr, info_ptr);
9. }
10. void PNGAPI",Not Useful
/*iTXt*/,"-10.              PNG_CHUNK_WRITE_ERROR);
-9.          continue;
-8.       }
-7.       key_len = strlen(text_ptr[i].key);
-6.       if (text_ptr[i].compression <= 0)
-5.       {
-4.          lang_len = 0;
-3.          lang_key_len = 0;
-2.       }
-1.       else
#  ifdef PNG_iTXt_SUPPORTED

/*iTXt*/

1.       {",Not Useful
/*sPLT*/,"-10.          num_trans = 1;
-9.    }
-8.    info_ptr->num_trans = (png_uint_16)num_trans;
-7.    if (num_trans != 0)
-6.    {
-5.       info_ptr->valid |= PNG_INFO_tRNS;
-4.       info_ptr->free_me |= PNG_FREE_TRNS;
-3.    }
-2. }
-1. #endif
#ifdef PNG_sPLT_SUPPORTED

/*sPLT*/

1. void PNGAPI
2. png_set_sPLT(png_const_structrp png_ptr,
3.     png_inforp info_ptr, png_const_sPLT_tp entries, int nentries)
4. /*
5.  *  entries        - array of png_sPLT_t structures
6.  *                   to be added to the list of palettes
7.  *                   in the info structure.
8.  *
9.  *  nentries       - number of palette structures to be
10.  *                   added.",Not Useful
/*Use the old behavior*/,"-2.       png_app_warning(png_ptr,
-1.           ""png_set_unknown_chunks now expects a valid location"");

/*Use the old behavior*/

1.       location = (png_byte)(png_ptr->mode &
2.           (PNG_HAVE_IHDR|PNG_HAVE_PLTE|PNG_AFTER_IDAT));
3.    }",Not Useful
/*But just skip storing the unknown chunk*/,"-10.          np->size = 0;
-9.       }
-8.       else
-7.       {
-6.          np->data = png_voidcast(png_bytep,
-5.              png_malloc_base(png_ptr, unknowns->size));
-4.          if (np->data == NULL)
-3.          {
-2.             png_chunk_report(png_ptr, ""unknown chunk: out of memory"",
-1.                 PNG_CHUNK_WRITE_ERROR);

/*But just skip storing the unknown chunk*/

1.             continue;
2.          }
3.          memcpy(np->data, unknowns->data, unknowns->size);
4.          np->size = unknowns->size;
5.       }",Not Useful
/*undocumented!*/,"-10.     *
-9.     * TODO: add a png_app_warning in 1.7
-8.     */
-7.    if (png_ptr != NULL && info_ptr != NULL && chunk >= 0 &&
-6.       chunk < info_ptr->unknown_chunks_num)
-5.    {
-4.       if ((location & (PNG_HAVE_IHDR|PNG_HAVE_PLTE|PNG_AFTER_IDAT)) == 0)
-3.       {
-2.          png_app_error(png_ptr, ""invalid unknown chunk location"");

/*undocumented!*/

1.             location = PNG_AFTER_IDAT;
2.          else",Not Useful
/*also undocumented*/,"-2.             location = PNG_AFTER_IDAT;
-1.          else

/*also undocumented*/

1.       }
2.       info_ptr->unknown_chunks[chunk].location =
3.          check_location(png_ptr, location);
4.    }
5. }",Not Useful
/*STORE_UNKNOWN_CHUNKS*/,"
#ifdef PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED



/*STORE_UNKNOWN_CHUNKS*/

1. static png_byte
2. check_location(png_const_structrp png_ptr, int location)
3. {
4.    location &= (PNG_HAVE_IHDR|PNG_HAVE_PLTE|PNG_AFTER_IDAT);",Not Useful
/*bKGD*/,"-10.  * For conditions of distribution and use, see the disclaimer
-9.  * and license in png.h
-8.  *
-7.  * The functions here are used during reads to store data from the file
-6.  * into the info struct, and during writes to store application data
-5.  * into the info struct for writing into the file.  This abstracts the
-4.  * info struct and allows us to change the structure in the future.
-3.  */
-2. #include ""pngpriv.h""
-1. #if defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED)
#ifdef PNG_bKGD_SUPPORTED

/*bKGD*/

1. void PNGAPI
2. png_set_bKGD(png_const_structrp png_ptr, png_inforp info_ptr,
3.     png_const_color_16p background)
4. {
5.    png_debug1(1, ""in %s storage function"", ""bKGD"");
6.    if (png_ptr == NULL || info_ptr == NULL || background == NULL)
7.       return;
8.    info_ptr->background = *background;
9.    info_ptr->valid |= PNG_INFO_bKGD;
10. }",Not Useful
/*cHRM*/,"-10. png_set_bKGD(png_const_structrp png_ptr, png_inforp info_ptr,
-9.     png_const_color_16p background)
-8. {
-7.    png_debug1(1, ""in %s storage function"", ""bKGD"");
-6.    if (png_ptr == NULL || info_ptr == NULL || background == NULL)
-5.       return;
-4.    info_ptr->background = *background;
-3.    info_ptr->valid |= PNG_INFO_bKGD;
-2. }
-1. #endif
#ifdef PNG_cHRM_SUPPORTED

/*cHRM*/

1. void PNGFAPI
2. png_set_cHRM_fixed(png_const_structrp png_ptr, png_inforp info_ptr,
3.     png_fixed_point white_x, png_fixed_point white_y, png_fixed_point red_x,
4.     png_fixed_point red_y, png_fixed_point green_x, png_fixed_point green_y,
5.     png_fixed_point blue_x, png_fixed_point blue_y)
6. {
7.    png_xy xy;
8.    png_debug1(1, ""in %s storage function"", ""cHRM fixed"");
9.    if (png_ptr == NULL || info_ptr == NULL)
10.       return;",Not Useful
/*eXIf*/,"
#ifdef PNG_eXIf_SUPPORTED



/*eXIf*/

1. void PNGAPI
2. png_set_eXIf(png_const_structrp png_ptr, png_inforp info_ptr,
3.     const png_bytep eXIf_buf)
4. {
5.   png_warning(png_ptr, ""png_set_eXIf does not work; use png_set_eXIf_1"");
6.   PNG_UNUSED(info_ptr)
7.   PNG_UNUSED(eXIf_buf)
8. }
9. void PNGAPI
10. png_set_eXIf_1(png_const_structrp png_ptr, png_inforp info_ptr,",Not Useful
/*gAMA*/,"
#ifdef PNG_gAMA_SUPPORTED



/*gAMA*/

1. void PNGFAPI
2. png_set_gAMA_fixed(png_const_structrp png_ptr, png_inforp info_ptr,
3.     png_fixed_point file_gamma)
4. {
5.    png_debug1(1, ""in %s storage function"", ""gAMA"");
6.    if (png_ptr == NULL || info_ptr == NULL)
7.       return;
8.    png_colorspace_set_gamma(png_ptr, &info_ptr->colorspace, file_gamma);
9.    png_colorspace_sync_info(png_ptr, info_ptr);
10. }",Not Useful
/*hIST*/,"-10. }
-9. #  ifdef PNG_FLOATING_POINT_SUPPORTED
-8. void PNGAPI
-7. png_set_gAMA(png_const_structrp png_ptr, png_inforp info_ptr, double file_gamma)
-6. {
-5.    png_set_gAMA_fixed(png_ptr, info_ptr, png_fixed(png_ptr, file_gamma,
-4.        ""png_set_gAMA""));
-3. }
-2. #  endif
-1. #endif
#ifdef PNG_hIST_SUPPORTED

/*hIST*/

1. void PNGAPI
2. png_set_hIST(png_const_structrp png_ptr, png_inforp info_ptr,
3.     png_const_uint_16p hist)
4. {
5.    int i;
6.    png_debug1(1, ""in %s storage function"", ""hIST"");
7.    if (png_ptr == NULL || info_ptr == NULL)
8.       return;
9.    if (info_ptr->num_palette == 0 || info_ptr->num_palette
10.        > PNG_MAX_PALETTE_LENGTH)",Not Useful
/*iCCP*/,"
#ifdef PNG_iCCP_SUPPORTED



/*iCCP*/

1. void PNGAPI
2. png_set_iCCP(png_const_structrp png_ptr, png_inforp info_ptr,
3.     png_const_charp name, int compression_type,
4.     png_const_bytep profile, png_uint_32 proflen)
5. {
6.    png_charp new_iccp_name;
7.    png_bytep new_iccp_profile;
8.    png_size_t length;
9.    png_debug1(1, ""in %s storage function"", ""iCCP"");
10.    if (png_ptr == NULL || info_ptr == NULL || name == NULL || profile == NULL)",Not Useful
/*iTXt*/,"-10.              PNG_CHUNK_WRITE_ERROR);
-9.          continue;
-8.       }
-7.       key_len = strlen(text_ptr[i].key);
-6.       if (text_ptr[i].compression <= 0)
-5.       {
-4.          lang_len = 0;
-3.          lang_key_len = 0;
-2.       }
-1.       else
#  ifdef PNG_iTXt_SUPPORTED

/*iTXt*/

1.       {",Not Useful
/*oFFs*/,"-10.       info_ptr->channels = 1;
-9.    else if ((info_ptr->color_type & PNG_COLOR_MASK_COLOR) != 0)
-8.       info_ptr->channels = 3;
-7.    else
-6.       info_ptr->channels = 1;
-5.    if ((info_ptr->color_type & PNG_COLOR_MASK_ALPHA) != 0)
-4.       info_ptr->channels++;
-3.    info_ptr->pixel_depth = (png_byte)(info_ptr->channels * info_ptr->bit_depth);
-2.    info_ptr->rowbytes = PNG_ROWBYTES(info_ptr->pixel_depth, width);
-1. }
#ifdef PNG_oFFs_SUPPORTED

/*oFFs*/

1. void PNGAPI
2. png_set_oFFs(png_const_structrp png_ptr, png_inforp info_ptr,
3.     png_int_32 offset_x, png_int_32 offset_y, int unit_type)
4. {
5.    png_debug1(1, ""in %s storage function"", ""oFFs"");
6.    if (png_ptr == NULL || info_ptr == NULL)
7.       return;
8.    info_ptr->x_offset = offset_x;
9.    info_ptr->y_offset = offset_y;
10.    info_ptr->offset_unit_type = (png_byte)unit_type;",Not Useful
/*pCAL*/,"-10. {
-9.    png_debug1(1, ""in %s storage function"", ""oFFs"");
-8.    if (png_ptr == NULL || info_ptr == NULL)
-7.       return;
-6.    info_ptr->x_offset = offset_x;
-5.    info_ptr->y_offset = offset_y;
-4.    info_ptr->offset_unit_type = (png_byte)unit_type;
-3.    info_ptr->valid |= PNG_INFO_oFFs;
-2. }
-1. #endif
#ifdef PNG_pCAL_SUPPORTED

/*pCAL*/

1. void PNGAPI
2. png_set_pCAL(png_const_structrp png_ptr, png_inforp info_ptr,
3.     png_const_charp purpose, png_int_32 X0, png_int_32 X1, int type,
4.     int nparams, png_const_charp units, png_charpp params)
5. {
6.    png_size_t length;
7.    int i;
8.    png_debug1(1, ""in %s storage function"", ""pCAL"");
9.    if (png_ptr == NULL || info_ptr == NULL || purpose == NULL || units == NULL
10.        || (nparams > 0 && params == NULL))",Not Useful
/*pHYs*/,"-9.       char swidth[PNG_sCAL_MAX_DIGITS+1];
-8.       char sheight[PNG_sCAL_MAX_DIGITS+1];
-7.       png_ascii_from_fixed(png_ptr, swidth, (sizeof swidth), width);
-6.       png_ascii_from_fixed(png_ptr, sheight, (sizeof sheight), height);
-5.       png_set_sCAL_s(png_ptr, info_ptr, unit, swidth, sheight);
-4.    }
-3. }
-2. #  endif
-1. #endif
#ifdef PNG_pHYs_SUPPORTED

/*pHYs*/

1. void PNGAPI
2. png_set_pHYs(png_const_structrp png_ptr, png_inforp info_ptr,
3.     png_uint_32 res_x, png_uint_32 res_y, int unit_type)
4. {
5.    png_debug1(1, ""in %s storage function"", ""pHYs"");
6.    if (png_ptr == NULL || info_ptr == NULL)
7.       return;
8.    info_ptr->x_pixels_per_unit = res_x;
9.    info_ptr->y_pixels_per_unit = res_y;
10.    info_ptr->phys_unit_type = (png_byte)unit_type;",Not Useful
/*sBIT*/,"-10.    png_ptr->palette = png_voidcast(png_colorp, png_calloc(png_ptr,
-9.        PNG_MAX_PALETTE_LENGTH * (sizeof (png_color))));
-8.    if (num_palette > 0)
-7.       memcpy(png_ptr->palette, palette, (unsigned int)num_palette *
-6.           (sizeof (png_color)));
-5.    info_ptr->palette = png_ptr->palette;
-4.    info_ptr->num_palette = png_ptr->num_palette = (png_uint_16)num_palette;
-3.    info_ptr->free_me |= PNG_FREE_PLTE;
-2.    info_ptr->valid |= PNG_INFO_PLTE;
-1. }
#ifdef PNG_sBIT_SUPPORTED

/*sBIT*/

1. void PNGAPI
2. png_set_sBIT(png_const_structrp png_ptr, png_inforp info_ptr,
3.     png_const_color_8p sig_bit)
4. {
5.    png_debug1(1, ""in %s storage function"", ""sBIT"");
6.    if (png_ptr == NULL || info_ptr == NULL || sig_bit == NULL)
7.       return;
8.    info_ptr->sig_bit = *sig_bit;
9.    info_ptr->valid |= PNG_INFO_sBIT;
10. }",Not Useful
/*sCAL*/,"-10.       {
-9.          png_warning(png_ptr, ""Insufficient memory for pCAL parameter"");
-8.          return;
-7.       }
-6.       memcpy(info_ptr->pcal_params[i], params[i], length);
-5.    }
-4.    info_ptr->valid |= PNG_INFO_pCAL;
-3.    info_ptr->free_me |= PNG_FREE_PCAL;
-2. }
-1. #endif
#ifdef PNG_sCAL_SUPPORTED

/*sCAL*/

1. void PNGAPI
2. png_set_sCAL_s(png_const_structrp png_ptr, png_inforp info_ptr,
3.     int unit, png_const_charp swidth, png_const_charp sheight)
4. {
5.    png_size_t lengthw = 0, lengthh = 0;
6.    png_debug1(1, ""in %s storage function"", ""sCAL"");
7.    if (png_ptr == NULL || info_ptr == NULL)
8.       return;
9.    /* Double check the unit (should never get here with an invalid
10.     * unit unless this is an API call.)",Not Useful
/*sPLT*/,"-10.          num_trans = 1;
-9.    }
-8.    info_ptr->num_trans = (png_uint_16)num_trans;
-7.    if (num_trans != 0)
-6.    {
-5.       info_ptr->valid |= PNG_INFO_tRNS;
-4.       info_ptr->free_me |= PNG_FREE_TRNS;
-3.    }
-2. }
-1. #endif
#ifdef PNG_sPLT_SUPPORTED

/*sPLT*/

1. void PNGAPI
2. png_set_sPLT(png_const_structrp png_ptr,
3.     png_inforp info_ptr, png_const_sPLT_tp entries, int nentries)
4. /*
5.  *  entries        - array of png_sPLT_t structures
6.  *                   to be added to the list of palettes
7.  *                   in the info structure.
8.  *
9.  *  nentries       - number of palette structures to be
10.  *                   added.",Not Useful
/*sTER*/,"-10.         103,  65,  77,  65, '\0',  /* gAMA */
-9.         104,  73,  83,  84, '\0',  /* hIST */
-8.         105,  67,  67,  80, '\0',  /* iCCP */
-7.         105,  84,  88, 116, '\0',  /* iTXt */
-6.          ,  70,  70, 115, '\0',  /* oFFs */
-5.         112,  67,  65,  76, '\0',  /* pCAL */
-4.         112,  72,  89, 115, '\0',  /* pHYs */
-3.         115,  66,  73,  84, '\0',  /* sBIT */
-2.         115,  67,  65,  76, '\0',  /* sCAL */
-1.         115,  80,  76,  84, '\0',  /* sPLT */
        115,  84,  69,  82, '\0',  /* sTER */

/*sTER*/

 ",Not Useful
/*sRGB*/,"-10. png_set_sBIT(png_const_structrp png_ptr, png_inforp info_ptr,
-9.     png_const_color_8p sig_bit)
-8. {
-7.    png_debug1(1, ""in %s storage function"", ""sBIT"");
-6.    if (png_ptr == NULL || info_ptr == NULL || sig_bit == NULL)
-5.       return;
-4.    info_ptr->sig_bit = *sig_bit;
-3.    info_ptr->valid |= PNG_INFO_sBIT;
-2. }
-1. #endif
#ifdef PNG_sRGB_SUPPORTED

/*sRGB*/

1. void PNGAPI
2. png_set_sRGB(png_const_structrp png_ptr, png_inforp info_ptr, int srgb_intent)
3. {
4.    png_debug1(1, ""in %s storage function"", ""sRGB"");
5.    if (png_ptr == NULL || info_ptr == NULL)
6.       return;
7.    (void)png_colorspace_set_sRGB(png_ptr, &info_ptr->colorspace, srgb_intent);
8.    png_colorspace_sync_info(png_ptr, info_ptr);
9. }
10. void PNGAPI",Not Useful
/*tEXt*/,"-10.         105,  67,  67,  80, '\0',  /* iCCP */
-9.         105,  84,  88, 116, '\0',  /* iTXt */
-8.          ,  70,  70, 115, '\0',  /* oFFs */
-7.         112,  67,  65,  76, '\0',  /* pCAL */
-6.         112,  72,  89, 115, '\0',  /* pHYs */
-5.         115,  66,  73,  84, '\0',  /* sBIT */
-4.         115,  67,  65,  76, '\0',  /* sCAL */
-3.         115,  80,  76,  84, '\0',  /* sPLT */
-2.         115,  84,  69,  82, '\0',  /* sTER */
-1.         115,  82,  71,  66, '\0',  /* sRGB */
        116,  69,  88, 116, '\0',  /* tEXt */

/*tEXt*/

 ",Not Useful
/*tIME*/,"-10.       {
-9.          textp->text_length = text_length;
-8.          textp->itxt_length = 0;
-7.       }
-6.       info_ptr->num_text++;
-5.       png_debug1(3, ""transferred text chunk %d"", info_ptr->num_text);
-4.    }
-3.    return(0);
-2. }
-1. #endif
#ifdef PNG_tIME_SUPPORTED

/*tIME*/

1. void PNGAPI
2. png_set_tIME(png_const_structrp png_ptr, png_inforp info_ptr,
3.     png_const_timep mod_time)
4. {
5.    png_debug1(1, ""in %s storage function"", ""tIME"");
6.    if (png_ptr == NULL || info_ptr == NULL || mod_time == NULL ||
7.        (png_ptr->mode & PNG_WROTE_tIME) != 0)
8.       return;
9.    if (mod_time->month == 0   || mod_time->month > 12  ||
10.        mod_time->day   == 0   || mod_time->day   > 31  ||",Not Useful
/*zTXt*/,"-10.          ,  70,  70, 115, '\0',  /* oFFs */
-9.         112,  67,  65,  76, '\0',  /* pCAL */
-8.         112,  72,  89, 115, '\0',  /* pHYs */
-7.         115,  66,  73,  84, '\0',  /* sBIT */
-6.         115,  67,  65,  76, '\0',  /* sCAL */
-5.         115,  80,  76,  84, '\0',  /* sPLT */
-4.         115,  84,  69,  82, '\0',  /* sTER */
-3.         115,  82,  71,  66, '\0',  /* sRGB */
-2.         116,  69,  88, 116, '\0',  /* tEXt */
-1.         116,  73,  77,  69, '\0',  /* tIME */
        122,  84,  88, 116, '\0'   /* zTXt */

/*zTXt*/

1.       };
2.       chunk_list = chunks_to_ignore;",Not Useful
/*SAFE*/,"-10.         115,  66,  73,  84, '\0',  /* sBIT */
-9.         115,  67,  65,  76, '\0',  /* sCAL */
-8.         115,  80,  76,  84, '\0',  /* sPLT */
-7.         115,  84,  69,  82, '\0',  /* sTER */
-6.         115,  82,  71,  66, '\0',  /* sRGB */
-5.         116,  69,  88, 116, '\0',  /* tEXt */
-4.         116,  73,  77,  69, '\0',  /* tIME */
-3.         122,  84,  88, 116, '\0'   /* zTXt */
-2.       };
-1.       chunk_list = chunks_to_ignore;
      num_chunks = (unsigned int)/*SAFE*/(sizeof chunks_to_ignore)/5U;

/*SAFE*/

1.    }",Not Useful
/*num_chunks_in > 0*/,"-4.       };
-3.       chunk_list = chunks_to_ignore;

/*num_chunks_in > 0*/

1.    {
2.       if (chunk_list == NULL)
3.       {",Not Useful
/*must fit*/,"-4.       if (size > ZLIB_IO_MAX)
-3.       {
-2.          png_warning(png_ptr,
-1.              ""Compression buffer size limited to system maximum"");

/*must fit*/

1.       }
2. #endif
3.       if (size < 6)
4.       {",Not Useful
"/*Deflate will potentially go into an infinite loop on a SYNC_FLUSH
          * if this is permitted.*/","-4.       }
-3. #endif
-2.       if (size < 6)
-1.       {
         /* Deflate will potentially go into an infinite loop on a SYNC_FLUSH
          * if this is permitted.

/*Deflate will potentially go into an infinite loop on a SYNC_FLUSH
          * if this is permitted.*/

1.           */
2.          png_warning(png_ptr,
3.              ""Compression buffer size cannot be reduced below 6"");
4.          return;
5.       }
6.       if (png_ptr->zbuffer_size != size)
7.       {
8.          png_free_buffer_list(png_ptr, &png_ptr->zbuffer_list);
9.          png_ptr->zbuffer_size = (uInt)size;
10.       }",Not Useful
/*?SET_USER_LIMITS*/,"-7. void PNGAPI
-6. png_set_chunk_malloc_max (png_structrp png_ptr,
-5.     png_alloc_size_t user_chunk_malloc_max)
-4. {
-3.    if (png_ptr != NULL)
-2.       png_ptr->user_chunk_malloc_max = user_chunk_malloc_max;
-1. }

/*?SET_USER_LIMITS*/

1. #ifdef PNG_BENIGN_ERRORS_SUPPORTED
2. void PNGAPI
3. png_set_benign_errors(png_structrp png_ptr, int allowed)
4. {
5.    png_debug(1, ""in png_set_benign_errors"");",Not Useful
/*BENIGN_ERRORS*/,"
#ifdef PNG_BENIGN_ERRORS_SUPPORTED



/*BENIGN_ERRORS*/

1. void PNGAPI
2. png_set_benign_errors(png_structrp png_ptr, int allowed)
3. {
4.    png_debug(1, ""in png_set_benign_errors"");",Not Useful
/*&& ch <= 255*/,"-10.    int space = 1;
-9.    png_debug(1, ""in png_check_keyword"");
-8.    if (key == NULL)
-7.    {
-6.       *new_key = 0;
-5.       return 0;
-4.    }
-3.    while (*key && key_len < 79)
-2.    {
-1.       png_byte ch = (png_byte)*key++;

/*&& ch <= 255*/

1.       {
2.          *new_key++ = ch; ++key_len; space = 0;
3.       }
4.       else if (space == 0)
5.       {",Not Useful
/*Terminate the keyword*/,"-5.    {
-4.       --key_len; --new_key;
-3.       if (bad_character == 0)
-2.          bad_character = 32;
-1.    }

/*Terminate the keyword*/

1.    *new_key = 0;
2.    if (key_len == 0)
3.       return 0;
4. #ifdef PNG_WARNINGS_SUPPORTED",Not Useful
/*keyword too long*/,"-5.    *new_key = 0;
-4.    if (key_len == 0)
-3.       return 0;
-2. #ifdef PNG_WARNINGS_SUPPORTED

/*keyword too long*/

1.       png_warning(png_ptr, ""keyword truncated"");
2.    else if (bad_character != 0)
3.    {
4.       PNG_WARNING_PARAMETERS(p)
5.       png_warning_parameter(p, 1, orig_key);
6.       png_warning_parameter_signed(p, 2, PNG_NUMBER_FORMAT_02x, bad_character);
7.       png_formatted_warning(png_ptr, p, ""keyword \""@1\"": bad character '0x@2'"");
8.    }",Not Useful
/*!WARNINGS*/,"-8.       png_warning(png_ptr, ""keyword truncated"");
-7.    else if (bad_character != 0)
-6.    {
-5.       PNG_WARNING_PARAMETERS(p)
-4.       png_warning_parameter(p, 1, orig_key);
-3.       png_warning_parameter_signed(p, 2, PNG_NUMBER_FORMAT_02x, bad_character);
-2.       png_formatted_warning(png_ptr, p, ""keyword \""@1\"": bad character '0x@2'"");
-1.    }

/*!WARNINGS*/

1.    PNG_UNUSED(png_ptr)",Not Useful
/*!WARNINGS*/,"-8.       png_warning(png_ptr, ""keyword truncated"");
-7.    else if (bad_character != 0)
-6.    {
-5.       PNG_WARNING_PARAMETERS(p)
-4.       png_warning_parameter(p, 1, orig_key);
-3.       png_warning_parameter_signed(p, 2, PNG_NUMBER_FORMAT_02x, bad_character);
-2.       png_formatted_warning(png_ptr, p, ""keyword \""@1\"": bad character '0x@2'"");
-1.    }

/*!WARNINGS*/

1.    PNG_UNUSED(png_ptr)",Not Useful
/*TEXT || pCAL || iCCP || sPLT*/,"-2.    return key_len;
-1. }

/*TEXT || pCAL || iCCP || sPLT*/

 ",Not Useful
/*pHYs*/,"-10. png_get_compression_type(png_const_structrp png_ptr, png_const_inforp info_ptr)
-9. {
-8.    if (png_ptr != NULL && info_ptr != NULL)
-7.       return info_ptr->compression_type;
-6.    return (0);
-5. }
-4. png_uint_32 PNGAPI
-3. png_get_x_pixels_per_meter(png_const_structrp png_ptr, png_const_inforp
-2.    info_ptr)
-1. {
#ifdef PNG_pHYs_SUPPORTED

/*pHYs*/

1.    if (png_ptr != NULL && info_ptr != NULL &&
2.        (info_ptr->valid & PNG_INFO_pHYs) != 0)
3.       {
4.          png_debug1(1, ""in %s retrieval function"",
5.              ""png_get_x_pixels_per_meter"");
6.          if (info_ptr->phys_unit_type == PNG_RESOLUTION_METER)
7.             return (info_ptr->x_pixels_per_unit);
8.       }
9. #else
10.    PNG_UNUSED(png_ptr)",Not Useful
/*INCH_CONVERSIONS*/,"-10.       png_debug1(1, ""in %s retrieval function"", ""png_get_y_offset_pixels"");
-9.       if (info_ptr->offset_unit_type == PNG_OFFSET_PIXEL)
-8.          return (info_ptr->y_offset);
-7.    }
-6. #else
-5.    PNG_UNUSED(png_ptr)
-4.    PNG_UNUSED(info_ptr)
-3. #endif
-2.    return (0);
-1. }
#ifdef PNG_INCH_CONVERSIONS_SUPPORTED

/*INCH_CONVERSIONS*/

1. static png_uint_32
2. ppi_from_ppm(png_uint_32 ppm)
3. {
4. #if 0",Not Useful
/*EASY_ACCESS*/,"-10. }
-9. #ifdef PNG_INFO_IMAGE_SUPPORTED
-8. png_bytepp PNGAPI
-7. png_get_rows(png_const_structrp png_ptr, png_const_inforp info_ptr)
-6. {
-5.    if (png_ptr != NULL && info_ptr != NULL)
-4.       return(info_ptr->row_pointers);
-3.    return(0);
-2. }
-1. #endif
#ifdef PNG_EASY_ACCESS_SUPPORTED

/*EASY_ACCESS*/

 ",Not Useful
/*FLOATING_ARITHMETIC*/,"-10.       *nparams = (int)info_ptr->pcal_nparams;
-9.       *units = info_ptr->pcal_units;
-8.       *params = info_ptr->pcal_params;
-7.       return (PNG_INFO_pCAL);
-6.    }
-5.    return (0);
-4. }
-3. #endif
-2. #ifdef PNG_sCAL_SUPPORTED
-1. #  ifdef PNG_FIXED_POINT_SUPPORTED
#    if defined(PNG_FLOATING_ARITHMETIC_SUPPORTED) || \

/*FLOATING_ARITHMETIC*/

1.          defined(PNG_FLOATING_POINT_SUPPORTED)
2. png_uint_32 PNGAPI
3. png_get_sCAL_fixed(png_const_structrp png_ptr, png_const_inforp info_ptr,
4.     int *unit, png_fixed_point *width, png_fixed_point *height)
5. {
6.    if (png_ptr != NULL && info_ptr != NULL &&
7.        (info_ptr->valid & PNG_INFO_sCAL) != 0)
8.    {
9.       *unit = info_ptr->scal_unit;
10.       /*TODO: make this work without FP support; the API is currently eliminated",Not Useful
/*FIXED_POINT*/,"-10.          return ((float)((float)info_ptr->y_pixels_per_unit
-9.              /(float)info_ptr->x_pixels_per_unit));
-8.    }
-7. #else
-6.    PNG_UNUSED(png_ptr)
-5.    PNG_UNUSED(info_ptr)
-4. #endif
-3.    return ((float)0.0);
-2. }
-1. #endif
#ifdef PNG_FIXED_POINT_SUPPORTED

/*FIXED_POINT*/

1. png_fixed_point PNGAPI
2. png_get_pixel_aspect_ratio_fixed(png_const_structrp png_ptr,
3.     png_const_inforp info_ptr)
4. {
5. #ifdef PNG_READ_pHYs_SUPPORTED
6.    if (png_ptr != NULL && info_ptr != NULL &&
7.        (info_ptr->valid & PNG_INFO_pHYs) != 0 &&
8.        info_ptr->x_pixels_per_unit > 0 && info_ptr->y_pixels_per_unit > 0 &&
9.        info_ptr->x_pixels_per_unit <= PNG_UINT_31_MAX &&
10.        info_ptr->y_pixels_per_unit <= PNG_UINT_31_MAX)",Not Useful
/*sCAL*/,"-10.       *X1 = info_ptr->pcal_X1;
-9.       *type = (int)info_ptr->pcal_type;
-8.       *nparams = (int)info_ptr->pcal_nparams;
-7.       *units = info_ptr->pcal_units;
-6.       *params = info_ptr->pcal_params;
-5.       return (PNG_INFO_pCAL);
-4.    }
-3.    return (0);
-2. }
-1. #endif
#ifdef PNG_sCAL_SUPPORTED

/*sCAL*/

1. #  ifdef PNG_FIXED_POINT_SUPPORTED
2. #    if defined(PNG_FLOATING_ARITHMETIC_SUPPORTED) || \
3.          defined(PNG_FLOATING_POINT_SUPPORTED)
4. png_uint_32 PNGAPI
5. png_get_sCAL_fixed(png_const_structrp png_ptr, png_const_inforp info_ptr,
6.     int *unit, png_fixed_point *width, png_fixed_point *height)
7. {
8.    if (png_ptr != NULL && info_ptr != NULL &&
9.        (info_ptr->valid & PNG_INFO_sCAL) != 0)
10.    {",Not Useful
/*pHYs*/,"-10. png_get_compression_type(png_const_structrp png_ptr, png_const_inforp info_ptr)
-9. {
-8.    if (png_ptr != NULL && info_ptr != NULL)
-7.       return info_ptr->compression_type;
-6.    return (0);
-5. }
-4. png_uint_32 PNGAPI
-3. png_get_x_pixels_per_meter(png_const_structrp png_ptr, png_const_inforp
-2.    info_ptr)
-1. {
#ifdef PNG_pHYs_SUPPORTED

/*pHYs*/

1.    if (png_ptr != NULL && info_ptr != NULL &&
2.        (info_ptr->valid & PNG_INFO_pHYs) != 0)
3.       {
4.          png_debug1(1, ""in %s retrieval function"",
5.              ""png_get_x_pixels_per_meter"");
6.          if (info_ptr->phys_unit_type == PNG_RESOLUTION_METER)
7.             return (info_ptr->x_pixels_per_unit);
8.       }
9. #else
10.    PNG_UNUSED(png_ptr)",Not Useful
/*SET_USER_LIMITS*/,"-10.       return png_ptr->IDAT_read_size;
-9. #else
-8.       return PNG_IDAT_READ_SIZE;
-7. #endif
-6.    }
-5. #ifdef PNG_WRITE_SUPPORTED
-4.    else
-3.       return png_ptr->zbuffer_size;
-2. #endif
-1. }
#ifdef PNG_SET_USER_LIMITS_SUPPORTED

/*SET_USER_LIMITS*/

 ",Not Useful
/*IO_STATE*/,"
#ifdef PNG_IO_STATE_SUPPORTED



/*IO_STATE*/

1. png_uint_32 PNGAPI
2. png_get_io_state (png_const_structrp png_ptr)
3. {
4.    return png_ptr->io_state;
5. }
6. png_uint_32 PNGAPI
7. png_get_io_chunk_type (png_const_structrp png_ptr)
8. {
9.    return png_ptr->chunk_name;
10. }",Not Useful
/*1.6.3*/,"-2. /* pngfix.c
-1.  *
 * Last changed in libpng 1.6.31 [July 27, 2017]

/*1.6.3*/

1.  * Copyright (c) 2014-2017 John Cunningham Bowler
2.  *
3.  * This code is released under the libpng license.
4.  * For conditions of distribution and use, see the disclaimer
5.  * and license in png.h
6.  *
7.  * Tool to check and fix the zlib inflate 'too far back' problem.
8.  * See the usage message for more information.
9.  */
10. #include <stdlib.h>",Not Useful
/*__cplusplus*/,"
#ifdef __cplusplus



/*__cplusplus*/

1. #  define voidcast(type, value) static_cast<type>(value)
2. #  define constcast(type, value) const_cast<type>(value)
3. #  define aligncast(type, value) \
4.    static_cast<type>(static_cast<void*>(value))
5. #  define aligncastconst(type, value) \
6.    static_cast<type>(static_cast<const void*>(value))
7. #else
8. #  define voidcast(type, value) (value)
9. #  define constcast(type, value) ((type)(value))
10. #  define aligncast(type, value) ((void*)(value))",Not Useful
/*Chunk tags (copied from pngpriv.h)*/,"-1. #if PNG_LIBPNG_VER < 10700

/*Chunk tags (copied from pngpriv.h)*/

1. #define PNG_32b(b,s) ((png_uint_32)(b) << (s))
2. #define PNG_U32(b1,b2,b3,b4) \
3.    (PNG_32b(b1,24) | PNG_32b(b2,16) | PNG_32b(b3,8) | PNG_32b(b4,0))",Not Useful
/*deprecated*/,"-2. #define png_gAMA PNG_U32(103,  65,  77,  65)
-1. #define png_gIFg PNG_U32(103,  73,  70, 103)

/*deprecated*/

1. #define png_gIFx PNG_U32(103,  73,  70, 120)
2. #define png_hIST PNG_U32(104,  73,  83,  84)
3. #define png_iCCP PNG_U32(105,  67,  67,  80)
4. #define png_iTXt PNG_U32(105,  84,  88, 116)
5. #define png_oFFs PNG_U32( ,  70,  70, 115)
6. #define png_pCAL PNG_U32(112,  67,  65,  76)
7. #define png_pHYs PNG_U32(112,  72,  89, 115)
8. #define png_sBIT PNG_U32(115,  66,  73,  84)
9. #define png_sCAL PNG_U32(115,  67,  65,  76)
10. #define png_sPLT PNG_U32(115,  80,  76,  84)",Not Useful
/*Is the chunk critical?*/,"-2. #define sig1 PNG_U32(137,  80,  78,  71)
-1. #define sig2 PNG_U32( 13,  10,  26,  10)

/*Is the chunk critical?*/

1. #define CRITICAL(chunk) (((chunk) & PNG_U32(32,0,0,0)) == 0)",Not Useful
/*Is it safe to copy?*/,"-1. #define CRITICAL(chunk) (((chunk) & PNG_U32(32,0,0,0)) == 0)

/*Is it safe to copy?*/

1. #define SAFE_TO_COPY(chunk) (((chunk) & PNG_U32(0,0,0,32)) != 0)",Not Useful
/*may be 0*/,"-10.    }
-9.    while (add != 0 && add != (-1))
-8.    {
-7.       num[out_digits++] = (png_uint_16)(add & 0xffff);
-6.       add >>= 16;
-5.    }
-4.    if (add == 0)
-3.    {
-2.       while (out_digits > 0 && num[out_digits-1] == 0)
-1.          --out_digits;

/*may be 0*/

1.    }",Not Useful
/*UNUSED*/,"-10.       return -1;
-9.    if (adigits > bdigits)
-8.       return 1;
-7.    while (adigits-- > 0)
-6.       if (a[adigits] < b[adigits])
-5.          return -1;
-4.       else if (a[adigits] > b[adigits])
-3.          return 1;
-2.    return 0;
-1. }

/*UNUSED*/

1. static int
2. uarb_eq32(uarb num, int digits, png_uint_32 val)",Not Useful
/**************************** CONTROL INFORMATION *****************************/,"-4.    c -= PNG_U32(25,25,25,26);
-3.    t |= ~c;
-2.    return (t & 0xe0e0e0e0) == 0;
-1. }

/**************************** CONTROL INFORMATION *****************************/

 ",Not Useful
/*Everything but tRNS and sBIT*/,"-6. #     define SKIP_NONE      0

/*Everything but tRNS and sBIT*/

 ",Not Useful
/*0 to perform no re-chunking*/,"-7. #     define SKIP_NONE      0

/*0 to perform no re-chunking*/

 ",Not Useful
/*truncated but still readable*/,"-10. #     define SKIP_UNSAFE    2    /* Chunks not safe to copy */
-9. #     define SKIP_UNUSED    3    /* Chunks not used by libpng */
-8. #     define SKIP_TRANSFORM 4    /* Chunks only used in transforms */
-7. #     define SKIP_COLOR     5    /* Everything but tRNS, sBIT, gAMA and sRGB */
-6. #     define SKIP_ALL       6    /* Everything but tRNS and sBIT */
-5.    png_uint_32    idat_max;         /* 0 to perform no re-chunking */
-4.    int            status_code;      /* Accumulated status code */
-3. #     define TOO_FAR_BACK   0x01 /* found a too-far-back error */
-2. #     define CRC_ERROR      0x02 /* fixed an invalid CRC */
-1. #     define STREAM_ERROR   0x04 /* damaged PNG stream (may be fixable) */
#     define TRUNCATED      0x08 /* truncated but still readable */

/*truncated but still readable*/

 ",Not Useful
/*Never strip critical chunks:*/,"-1. {

/*Never strip critical chunks:*/

1.    if (CRITICAL(type))
2.       return 0;
3.    switch (type)
4.    {",Not Useful
/*as above*/,"-3.       default:
-2.          if (SAFE_TO_COPY(type))
-1.          {

/*as above*/

1.                return 1;
2.          }
3.          else if (global->skip >= SKIP_UNSAFE)
4.             return 1;
5.          return 0;
6.    }
7. }",Not Useful
/*IHDR information*/,"-7.    const char *   file_name;

/*IHDR information*/

1.    png_uint_32    width;
2.    png_uint_32    height;
3.    png_byte       bit_depth;
4.    png_byte       color_type;
5.    png_byte       compression_method;
6.    png_byte       filter_method;
7.    png_byte       interlace_method;
8.    udigit         image_bytes[5];
9.    int            image_digits;",Not Useful
/*Open the files:*/,"-6.    file->read_count = 0;
-5.    file->state = STATE_SIGNATURE;
-4.    file->chunk = NULL;
-3.    file->idat = NULL;
-2.    file->alloc_ptr = alloc_ptr;
-1.    file->alloc = alloc;

/*Open the files:*/

1.    assert(file_name != NULL);
2.    file->file = fopen(file_name, ""rb"");
3.    if (file->file == NULL)
4.    {
5.       file->read_errno = errno;
6.       file->status_code |= FILE_ERROR;",Not Useful
/*need two quiets to stop this.*/,"-10.     * finding errors in the previous chunks.  We know that is happening because
-9.     * we are at the start of the IDAT (i.e. no IDAT data has yet been written.)
-8.     *
-7.     * SUMMARY FORMAT (stop):
-6.     *
-5.     * IDAT ERR status code read-errno write-errno message file
-4.     *
-3.     * 'uncompressed' will be 0 if there was a problem in the IHDR.  The errno
-2.     * values are emit_string(strerror(errno)).
-1.     */

/*need two quiets to stop this.*/

1.    {
2.       png_uint_32 type;
3.       if (file->chunk != NULL)",Not Useful
/*unexpected*/,"-8. };

/*unexpected*/

1. static void
2. emit_string(const char *str, FILE *out)",Not Useful
/*Truncated*/,"-10.     * if the input is truncated.
-9.     */
-8. {
-7.    if (length > 0)
-6.    {
-5.       png_uint_32 crc = file->crc;
-4.       do
-3.       {
-2.          int ch = read_byte(file);
-1.          if (ch == EOF)

/*Truncated*/

1.          crc = crc_one_byte(crc, ch);
2.       }
3.       while (--length > 0);
4.       file->crc = crc;
5.    }",Not Useful
/*OK*/,"-5.          crc = crc_one_byte(crc, ch);
-4.       }
-3.       while (--length > 0);
-2.       file->crc = crc;
-1.    }

/*OK*/

1. }
2. static int
3. calc_image_size(struct file *file)",Not Useful
/*g*/,"
/* pngfix.c



/*g*/

1.  *
2.  * Last changed in libpng 1.6.31 [July 27, 2017]
3.  * Copyright (c) 2014-2017 John Cunningham Bowler
4.  *
5.  * This code is released under the libpng license.
6.  * For conditions of distribution and use, see the disclaimer
7.  * and license in png.h
8.  *
9.  * Tool to check and fix the zlib inflate 'too far back' problem.
10.  * See the usage message for more information.",Not Useful
/*ga*/,"-10.     * pngfix.c:
-9.     * In function 'zlib_advance':
-8.     * pngfix.c:181:13: error: assuming signed overflow does not
-7.     *   occur when simplifying conditional to constant [-Werror=strict-overflow]
-6.     */
-5. #  define FIX_GCC volatile
-4. #else
-3. #  define FIX_GCC
-2. #endif
-1. #define PROGRAM_NAME ""pngfix""
/* Define the following to use this program against your installed libpng,

/*ga*/

1.  * rather than the one being built here:
2.  */
3. #ifdef PNG_FREESTANDING_TESTS
4. #  include <png.h>
5. #else
6. #  include ""../../png.h""
7. #endif",Not Useful
/*calculate 1+((pw*pd+7)>>3) in row_bytes*/,"-10.          {
-9.             int pass;
-8.             int image_digits = 0;
-7.             udigit row_width[2], row_bytes[3];
-6.             for (pass=0; pass<=6; ++pass)
-5.             {
-4.                png_uint_32 pw = PNG_PASS_COLS(file->width, pass);
-3.                if (pw > 0)
-2.                {
-1.                   int  digits;

/*calculate 1+((pw*pd+7)>>3) in row_bytes*/

1.                   digits = uarb_mult_digit(row_bytes, uarb_set(row_bytes, 7),
2.                      row_width, uarb_set(row_width, pw), pd);
3.                   digits = uarb_shift(row_bytes, digits, 3);
4.                   digits = uarb_inc(row_bytes, digits, 1);",Not Useful
/*magic*/,"-4.       else
-3.          type = file->type;
-2.       if (type)
-1.          type_name(type, stdout);

/*magic*/

 ",Not Useful
/*skip*/,"-10.       while (out_digits < n_digits || carry > 0)
-9.       {
-8.          if (out_digits < a_digits)
-7.             carry += acc[out_digits];
-6.          if (out_digits < n_digits)
-5.             carry += (png_uint_32)num[out_digits] * val;
-4.          acc[out_digits++] = (png_uint_16)(carry & 0xffff);
-3.          carry >>= 16;
-2.       }
-1.       /* So carry is 0 and all the input digits have been consumed. This means
       * that it is possible to skip any remaining digits in acc.

/*skip*/

1.        */
2.       if (out_digits > a_digits)
3.          return out_digits;
4.    }
5.    return a_digits;
6. }
7. static int
8. uarb_mult32(uarb acc, int a_digits, uarb num, int n_digits, png_uint_32 val)
9.    /* calculate acc += num * val, 'val' may be any 32-bit value, 'acc' and 'num'
10.     * may be any value, returns the number of digits in 'acc'.",Not Useful
/*Like zTXt but more fields.*/,"-4. }
-3. static int
-2. process_iTXt(struct file *file)
-1. {

/*Like zTXt but more fields.*/

1.    struct chunk *chunk = file->chunk;
2.    png_uint_32 length;
3.    png_uint_32 index = 0;
4.    assert(chunk != NULL && file->idat == NULL);
5.    length = chunk->chunk_length;
6.    setpos(chunk);
7.    while (length >= 5)
8.    {
9.       --length;
10.       ++index;",Not Useful
/*Skip the translated keyword*/,"-1.             {

/*Skip the translated keyword*/

1.                while (length >= 8)
2.                {
3.                   --length;
4.                   ++index;",Not Useful
/*skip*/,"-10.       while (out_digits < n_digits || carry > 0)
-9.       {
-8.          if (out_digits < a_digits)
-7.             carry += acc[out_digits];
-6.          if (out_digits < n_digits)
-5.             carry += (png_uint_32)num[out_digits] * val;
-4.          acc[out_digits++] = (png_uint_16)(carry & 0xffff);
-3.          carry >>= 16;
-2.       }
-1.       /* So carry is 0 and all the input digits have been consumed. This means
       * that it is possible to skip any remaining digits in acc.

/*skip*/

1.        */
2.       if (out_digits > a_digits)
3.          return out_digits;
4.    }
5.    return a_digits;
6. }
7. static int
8. uarb_mult32(uarb acc, int a_digits, uarb num, int n_digits, png_uint_32 val)
9.    /* calculate acc += num * val, 'val' may be any 32-bit value, 'acc' and 'num'
10.     * may be any value, returns the number of digits in 'acc'.",Not Useful
/*chunk*/,"-3. #define PNG_32b(b,s) ((png_uint_32)(b) << (s))
-2. #define PNG_U32(b1,b2,b3,b4) \
-1.    (PNG_32b(b1,24) | PNG_32b(b2,16) | PNG_32b(b3,8) | PNG_32b(b4,0))

/*chunk*/

1. #define png_IDAT PNG_U32( 73,  68,  65,  84)
2. #define png_IEND PNG_U32( 73,  69,  78,  68)
3. #define png_IHDR PNG_U32( 73,  72,  68,  82)
4. #define png_PLTE PNG_U32( 80,  76,  84,  69)
5. #define png_bKGD PNG_U32( 98,  75,  71,  68)
6. #define png_cHRM PNG_U32( 99,  72,  82,  77)",Not Useful
/*use the cache*/,"-4.    {
-3.       const struct IDAT_list *cur;
-2.       unsigned int count;
-1.       if (start)

/*use the cache*/

 ",Not Useful
/*rechunking*/,"-5.    file->idat = idat;
-4. }
-3. static png_uint_32
-2. rechunk_length(struct IDAT *idat, int start)
-1.    /* Return the length for the next IDAT chunk, taking into account
    * rechunking.

/*rechunking*/

1.     */
2. {
3.    png_uint_32 len = idat->global->idat_max;",Not Useful
/*unexpected*/,"-8. };

/*unexpected*/

1. static void
2. emit_string(const char *str, FILE *out)",Not Useful
/*unexpected*/,"-8. };

/*unexpected*/

1. static void
2. emit_string(const char *str, FILE *out)",Not Useful
/*unset*/,"-1.    zlib->file_bits = 24;

/*unset*/

 ",Not Useful
/*unexpected*/,"-8. };

/*unexpected*/

1. static void
2. emit_string(const char *str, FILE *out)",Not Useful
/*unexpected*/,"-8. };

/*unexpected*/

1. static void
2. emit_string(const char *str, FILE *out)",Not Useful
/*FALLTHROUGH*/,"-6.                if (zlib->z.msg != NULL &&
-5.                   strcmp(zlib->z.msg, ""invalid distance too far back"") == 0)
-4.                {
-3.                   endrc = ZLIB_TOO_FAR_BACK;
-2.                   break;
-1.                }

/*FALLTHROUGH*/

1.             default:",Not Useful
/*keep going*/,"-10.    if (cb >   256) return  9;
-9.    return 8;
-8. }
-7. static int
-6. zlib_advance(struct zlib *zlib, png_uint_32 nbytes)
-5.    /* Read nbytes compressed bytes; the stream will be initialized if required.
-4.     * Bytes are always being reread and errors are fatal.  The return code is as
-3.     * follows:
-2.     *
-1.     *    -1: saw the ""too far back"" error
    *     0: ok, keep going

/*keep going*/

1.     *     1: saw Z_STREAM_END (zlib->extra_bytes indicates too much data)
2.     *     2: a zlib error that cannot be corrected (error message already
3.     *        output if required.)
4.     */
5. #  define ZLIB_TOO_FAR_BACK (-1)
6. #  define ZLIB_OK           0
7. #  define ZLIB_STREAM_END   1
8. #  define ZLIB_FATAL        2
9. {
10.    int state = zlib->state;",Not Useful
/*stop*/,"-1. };

/*stop*/

 ",Not Useful
/*FALLTHROUGH*/,"-6.                if (zlib->z.msg != NULL &&
-5.                   strcmp(zlib->z.msg, ""invalid distance too far back"") == 0)
-4.                {
-3.                   endrc = ZLIB_TOO_FAR_BACK;
-2.                   break;
-1.                }

/*FALLTHROUGH*/

1.             default:",Not Useful
/*expected*/,"-8. };

/*expected*/

1. static void
2. emit_string(const char *str, FILE *out)",Not Useful
/*FALLTHROUGH*/,"-6.                if (zlib->z.msg != NULL &&
-5.                   strcmp(zlib->z.msg, ""invalid distance too far back"") == 0)
-4.                {
-3.                   endrc = ZLIB_TOO_FAR_BACK;
-2.                   break;
-1.                }

/*FALLTHROUGH*/

1.             default:",Not Useful
/*The loop guarantees this*/,"-5.          {
-4.             zlib_end(&zlib);
-3.             return 0;
-2.          }
-1.       }

/*The loop guarantees this*/

1.       assert(zlib.ok_bits == max_bits);
2.       zlib_end(&zlib);
3.       return 1;
4.    }",Not Useful
/*This will cause an IEND with a bad CRC to stop*/,"-2.       if (file->global->skip != SKIP_BAD_CRC)
-1.          type_message(file, type, ""bad CRC"");

/*This will cause an IEND with a bad CRC to stop*/

1.       else if (CRITICAL(type))
2.          stop(file, READ_ERROR_CODE, ""bad CRC in critical chunk"");
3.       else
4.       {
5.          type_message(file, type, ""skipped: bad CRC"");",Not Useful
/*chunk*/,"-3. #define PNG_32b(b,s) ((png_uint_32)(b) << (s))
-2. #define PNG_U32(b1,b2,b3,b4) \
-1.    (PNG_32b(b1,24) | PNG_32b(b2,16) | PNG_32b(b3,8) | PNG_32b(b4,0))

/*chunk*/

1. #define png_IDAT PNG_U32( 73,  68,  65,  84)
2. #define png_IEND PNG_U32( 73,  69,  78,  68)
3. #define png_IHDR PNG_U32( 73,  72,  68,  82)
4. #define png_PLTE PNG_U32( 80,  76,  84,  69)
5. #define png_bKGD PNG_U32( 98,  75,  71,  68)
6. #define png_cHRM PNG_U32( 99,  72,  82,  77)",Not Useful
"/*or, nused &= 7 ;-)*/","-1.                nread -= nused & ~7;

/*or, nused &= 7 ;-)*/

 ",Not Useful
/*IEND*/,"-1. #define png_IDAT PNG_U32( 73,  68,  65,  84)
#define png_IEND PNG_U32( 73,  69,  78,  68)

/*IEND*/

1. #define png_IHDR PNG_U32( 73,  72,  68,  82)
2. #define png_PLTE PNG_U32( 80,  76,  84,  69)
3. #define png_bKGD PNG_U32( 98,  75,  71,  68)
4. #define png_cHRM PNG_U32( 99,  72,  82,  77)",Not Useful
/*FALLTHROUGH*/,"-6.                if (zlib->z.msg != NULL &&
-5.                   strcmp(zlib->z.msg, ""invalid distance too far back"") == 0)
-4.                {
-3.                   endrc = ZLIB_TOO_FAR_BACK;
-2.                   break;
-1.                }

/*FALLTHROUGH*/

1.             default:",Not Useful
/*Advance one chunk*/,"-2.                      while (idat->idat_index >= idat->idat_length)
-1.                      {

/*Advance one chunk*/

1.                         struct IDAT_list *cur = idat->idat_cur;
2.                         assert(idat->idat_index == idat->idat_length);
3.                         assert(cur != NULL && cur->count > 0);",Not Useful
/*conditioning*/,"-10.    return crc_table[(crc ^ b) & 0xff] ^ (crc >> 8);
-9. }
-8. static png_uint_32
-7. crc_init_4(png_uint_32 value)
-6. {
-5.    /* This is an alternative to the algorithm used in zlib, which requires four
-4.     * separate tables to parallelize the four byte operations, it only works for
-3.     * a CRC of the first four bytes of the stream, but this is what happens in
-2.     * the parser below where length+chunk-name is read and chunk-name used to
-1.     * initialize the CRC.  Notice that the calculation here avoids repeated
    * conditioning (xor with 0xffffffff) by storing the conditioned value.

/*conditioning*/

1.     */
2.    png_uint_32 crc = crc_table[(~value >> 24)] ^ 0xffffff;
3.    crc = crc_table[(crc ^ (value >> 16)) & 0xff] ^ (crc >> 8);
4.    crc = crc_table[(crc ^ (value >> 8)) & 0xff] ^ (crc >> 8);
5.    return crc_table[(crc ^ value) & 0xff] ^ (crc >> 8);
6. }
7. static int
8. chunk_type_valid(png_uint_32 c)
9.    /* Bit whacking approach to chunk name validation that is intended to avoid
10.     * branches.  The cost is that it uses a lot of 32-bit constants, which might",Not Useful
/*chunk*/,"-3. #define PNG_32b(b,s) ((png_uint_32)(b) << (s))
-2. #define PNG_U32(b1,b2,b3,b4) \
-1.    (PNG_32b(b1,24) | PNG_32b(b2,16) | PNG_32b(b3,8) | PNG_32b(b4,0))

/*chunk*/

1. #define png_IDAT PNG_U32( 73,  68,  65,  84)
2. #define png_IEND PNG_U32( 73,  69,  78,  68)
3. #define png_IHDR PNG_U32( 73,  72,  68,  82)
4. #define png_PLTE PNG_U32( 80,  76,  84,  69)
5. #define png_bKGD PNG_U32( 98,  75,  71,  68)
6. #define png_cHRM PNG_U32( 99,  72,  82,  77)",Not Useful
/*NYI*/,"-10. ""      Write the optimized/corrected version of the next PNG to <file>.  This"",
-9. ""      overrides the following two options"",
-8. ""    --suffix=<suffix>:"",
-7. ""      Set --out=<name><suffix> for all following files unless overridden on"",
-6. ""      a per-file basis by explicit --out."",
-5. ""    --prefix=<prefix>:"",
-4. ""      Set --out=<prefix><name> for all the following files unless overridden"",
-3. ""      on a per-file basis by explicit --out."",
-2. ""      These two options can be used together to produce a suffix and prefix."",
-1. ""  INTERNAL OPTIONS"",

/*NYI*/

1. #ifdef PNG_MAXIMUM_INFLATE_WINDOW
2. ""    --test:"",
3. ""      Test the PNG_MAXIMUM_INFLATE_WINDOW option.  Setting this disables"",
4. ""      output as this would produce a broken file."",
5. #endif
6. #endif
7. 0,
8. ""EXIT CODES"",
9. ""  *** SUBJECT TO CHANGE ***"",
10. ""  The program exit code is value in the range 0..127 holding a bit mask of"",",Not Useful
/*NYI*/,"-10. ""      Write the optimized/corrected version of the next PNG to <file>.  This"",
-9. ""      overrides the following two options"",
-8. ""    --suffix=<suffix>:"",
-7. ""      Set --out=<name><suffix> for all following files unless overridden on"",
-6. ""      a per-file basis by explicit --out."",
-5. ""    --prefix=<prefix>:"",
-4. ""      Set --out=<prefix><name> for all the following files unless overridden"",
-3. ""      on a per-file basis by explicit --out."",
-2. ""      These two options can be used together to produce a suffix and prefix."",
-1. ""  INTERNAL OPTIONS"",

/*NYI*/

1. #ifdef PNG_MAXIMUM_INFLATE_WINDOW
2. ""    --test:"",
3. ""      Test the PNG_MAXIMUM_INFLATE_WINDOW option.  Setting this disables"",
4. ""      output as this would produce a broken file."",
5. #endif
6. #endif
7. 0,
8. ""EXIT CODES"",
9. ""  *** SUBJECT TO CHANGE ***"",
10. ""  The program exit code is value in the range 0..127 holding a bit mask of"",",Not Useful
/*Consider the prefix/suffix options*/,"-1.          {

/*Consider the prefix/suffix options*/

1.             if (prefix != NULL)
2.             {
3.                size_t prefixlen = strlen(prefix);
4.                if (prefixlen+outlen > FILENAME_MAX)
5.                {
6.                   fprintf(stderr, ""%s: output file name too long: %s%s%s\n"",
7.                      prog, prefix, *argv, suffix ? suffix : """");
8.                   global.status_code |= WRITE_ERROR;
9.                   continue;
10.                }",Not Useful
/*ZLIB_VERNUM < 0x1240*/,"-10.          }
-9.          (void)one_file(&global, *argv, outfile);
-8.          ++done;
-7.          outfile = NULL;
-6.       }
-5.    }
-4.    if (!done)
-3.       usage(prog);
-2.    return global_end(&global);
-1. }

/*ZLIB_VERNUM < 0x1240*/

1. int
2. main(void)
3. {
4.    fprintf(stderr,
5.       ""pngfix needs libpng with a zlib >=1.2.4 (not 0x%x)\n"",
6.       ZLIB_VERNUM);
7.    return 77;
8. }",Not Useful
/*ZLIB_VERNUM*/,"#if ZLIB_VERNUM < 0x1260

/*ZLIB_VERNUM*/

1. #  define PNGZ_MSG_CAST(s) constcast(char*,s)
2. #  define PNGZ_INPUT_CAST(b) constcast(png_bytep,b)
3. #else
4. #  define PNGZ_MSG_CAST(s) (s)
5. #  define PNGZ_INPUT_CAST(b) (b)
6. #endif
7. #ifndef PNG_MAXIMUM_INFLATE_WINDOW
8. #  error ""pngfix not supported in this libpng version""
9. #endif
10. #if ZLIB_VERNUM >= 0x1240",Not Useful
/*PNG_READ_SUPPORTED && PNG_EASY_ACCESS_SUPPORTED*/,"-6. int
-5. main(void)
-4. {
-3.    fprintf(stderr, ""pngfix does not work without read deinterlace support\n"");
-2.    return 77;
-1. }

/*PNG_READ_SUPPORTED && PNG_EASY_ACCESS_SUPPORTED*/

 ",Not Useful
"/*This is the function that does the actual writing of data.  If you are
 * not writing to a standard C stream, you should create a replacement
 * write_data function and use it at run time with png_set_write_fn(), rather
 * than changing the library.*/","-7.    if (png_ptr->write_data_fn != NULL )
-6.       (*(png_ptr->write_data_fn))(png_ptr, png_constcast(png_bytep,data),
-5.           length);
-4.    else
-3.       png_error(png_ptr, ""Call to NULL write function"");
-2. }
-1. #ifdef PNG_STDIO_SUPPORTED
/* This is the function that does the actual writing of data.  If you are
 * not writing to a standard C stream, you should create a replacement
 * write_data function and use it at run time with png_set_write_fn(), rather
 * than changing the library.

 /*This is the function that does the actual writing of data.  If you are
 * not writing to a standard C stream, you should create a replacement
 * write_data function and use it at run time with png_set_write_fn(), rather
 * than changing the library.*/

1.  */
2. void PNGCBAPI
3. png_default_write_data(png_structp png_ptr, png_bytep data, png_size_t length)
4. {
5.    png_size_t check;
6.    if (png_ptr == NULL)
7.       return;
8.    check = fwrite(data, 1, length, (png_FILE_p)(png_ptr->io_ptr));
9.    if (check != length)
10.       png_error(png_ptr, ""Write Error"");",Useful
"/*This function is called to output any data pending writing (normally
 * to disk).  After png_flush is called, there should be no data pending
 * writing in any buffers.*/","-10. png_default_write_data(png_structp png_ptr, png_bytep data, png_size_t length)
-9. {
-8.    png_size_t check;
-7.    if (png_ptr == NULL)
-6.       return;
-5.    check = fwrite(data, 1, length, (png_FILE_p)(png_ptr->io_ptr));
-4.    if (check != length)
-3.       png_error(png_ptr, ""Write Error"");
-2. }
-1. #endif
/* This function is called to output any data pending writing (normally
 * to disk).  After png_flush is called, there should be no data pending
 * writing in any buffers.

 /*This function is called to output any data pending writing (normally
 * to disk).  After png_flush is called, there should be no data pending
 * writing in any buffers.*/

1.  */
2. #ifdef PNG_WRITE_FLUSH_SUPPORTED",Useful
"/*This function allows the application to supply new output functions for
 * libpng if standard C streams aren't being used.
 *
 * This function takes as its arguments:
 * png_ptr       - pointer to a png output data structure
 * io_ptr        - pointer to user supplied structure containing info about
 *                 the output functions.  May be NULL.
 * write_data_fn - pointer to a new output function that takes as its
 *                 arguments a pointer to a png_struct, a pointer to
 *                 data to be written, and a 32-bit unsigned int that is
 *                 the number of bytes to be written.  The new write
 *                 function should call png_error(png_ptr, ""Error msg"")
 *                 to exit and output any fatal error messages.  May be
 *                 NULL, in which case libpng's default function will
 *                 be used.
 * flush_data_fn - pointer to a new flush function that takes as its
 *                 arguments a pointer to a png_struct.  After a call to
 *                 the flush function, there should be no data in any buffers
 *                 or pending transmission.  If the output method doesn't do
 *                 any buffering of output, a function prototype must still be
 *                 supplied although it doesn't have to do anything.  If
 *                 PNG_WRITE_FLUSH_SUPPORTED is not defined at libpng compile
 *                 time, output_flush_fn will be ignored, although it must be
 *                 supplied for compatibility.  May be NULL, in which case
 *                 libpng's default function will be used, if
 *                 PNG_WRITE_FLUSH_SUPPORTED is defined.  This is not
 *                 a good idea if io_ptr does not point to a standard
 *                 *FILE structure.*/","-10. png_default_flush(png_structp png_ptr)
-9. {
-8.    png_FILE_p io_ptr;
-7.    if (png_ptr == NULL)
-6.       return;
-5.    io_ptr = png_voidcast(png_FILE_p, (png_ptr->io_ptr));
-4.    fflush(io_ptr);
-3. }
-2. #  endif
-1. #endif
/* This function allows the application to supply new output functions for
 * libpng if standard C streams aren't being used.
 *
 * This function takes as its arguments:
 * png_ptr       - pointer to a png output data structure
 * io_ptr        - pointer to user supplied structure containing info about
 *                 the output functions.  May be NULL.
 * write_data_fn - pointer to a new output function that takes as its
 *                 arguments a pointer to a png_struct, a pointer to
 *                 data to be written, and a 32-bit unsigned int that is
 *                 the number of bytes to be written.  The new write
 *                 function should call png_error(png_ptr, ""Error msg"")
 *                 to exit and output any fatal error messages.  May be
 *                 NULL, in which case libpng's default function will
 *                 be used.
 * flush_data_fn - pointer to a new flush function that takes as its
 *                 arguments a pointer to a png_struct.  After a call to
 *                 the flush function, there should be no data in any buffers
 *                 or pending transmission.  If the output method doesn't do
 *                 any buffering of output, a function prototype must still be
 *                 supplied although it doesn't have to do anything.  If
 *                 PNG_WRITE_FLUSH_SUPPORTED is not defined at libpng compile
 *                 time, output_flush_fn will be ignored, although it must be
 *                 supplied for compatibility.  May be NULL, in which case
 *                 libpng's default function will be used, if
 *                 PNG_WRITE_FLUSH_SUPPORTED is defined.  This is not
 *                 a good idea if io_ptr does not point to a standard
 *                 *FILE structure.

 /*This function allows the application to supply new output functions for
 * libpng if standard C streams aren't being used.
 *
 * This function takes as its arguments:
 * png_ptr       - pointer to a png output data structure
 * io_ptr        - pointer to user supplied structure containing info about
 *                 the output functions.  May be NULL.
 * write_data_fn - pointer to a new output function that takes as its
 *                 arguments a pointer to a png_struct, a pointer to
 *                 data to be written, and a 32-bit unsigned int that is
 *                 the number of bytes to be written.  The new write
 *                 function should call png_error(png_ptr, ""Error msg"")
 *                 to exit and output any fatal error messages.  May be
 *                 NULL, in which case libpng's default function will
 *                 be used.
 * flush_data_fn - pointer to a new flush function that takes as its
 *                 arguments a pointer to a png_struct.  After a call to
 *                 the flush function, there should be no data in any buffers
 *                 or pending transmission.  If the output method doesn't do
 *                 any buffering of output, a function prototype must still be
 *                 supplied although it doesn't have to do anything.  If
 *                 PNG_WRITE_FLUSH_SUPPORTED is not defined at libpng compile
 *                 time, output_flush_fn will be ignored, although it must be
 *                 supplied for compatibility.  May be NULL, in which case
 *                 libpng's default function will be used, if
 *                 PNG_WRITE_FLUSH_SUPPORTED is defined.  This is not
 *                 a good idea if io_ptr does not point to a standard
 *                 *FILE structure.*/

 ",Useful
/*It is an error to read while writing a png file*/,"-1. #ifdef PNG_READ_SUPPORTED

 /*It is an error to read while writing a png file*/

1.    if (png_ptr->read_data_fn != NULL)
2.    {
3.       png_ptr->read_data_fn = NULL;
4.       png_warning(png_ptr,
5.           ""Can't set both read_data_fn and write_data_fn in the""
6.           "" same structure"");
7.    }
8. #endif
9. }",Useful
/*invalidate the client area for later update*/,"-3.             if (!LoadImageFile (hwnd, szImgPathName,
-2.                 &pbImage, &cxImgSize, &cyImgSize, &cImgChannels, &bkgColor))
-1.                 return 0;

 /*invalidate the client area for later update*/

1.             InvalidateRect (hwnd, NULL, TRUE);",Useful
/*invalidate the client area for later update*/,"-3.             if (!LoadImageFile (hwnd, szImgPathName,
-2.                 &pbImage, &cxImgSize, &cyImgSize, &cImgChannels, &bkgColor))
-1.                 return 0;

 /*invalidate the client area for later update*/

1.             InvalidateRect (hwnd, NULL, TRUE);",Useful
/*invalidate the client area for later update*/,"-3.             if (!LoadImageFile (hwnd, szImgPathName,
-2.                 &pbImage, &cxImgSize, &cyImgSize, &cImgChannels, &bkgColor))
-1.                 return 0;

 /*invalidate the client area for later update*/

1.             InvalidateRect (hwnd, NULL, TRUE);",Useful
/*invalidate the client area for later update*/,"-3.             if (!LoadImageFile (hwnd, szImgPathName,
-2.                 &pbImage, &cxImgSize, &cyImgSize, &cImgChannels, &bkgColor))
-1.                 return 0;

 /*invalidate the client area for later update*/

1.             InvalidateRect (hwnd, NULL, TRUE);",Useful
/*invalidate the client area for later update*/,"-3.             if (!LoadImageFile (hwnd, szImgPathName,
-2.                 &pbImage, &cxImgSize, &cyImgSize, &cImgChannels, &bkgColor))
-1.                 return 0;

 /*invalidate the client area for later update*/

1.             InvalidateRect (hwnd, NULL, TRUE);",Useful
/*invalidate the client area for later update*/,"-3.             if (!LoadImageFile (hwnd, szImgPathName,
-2.                 &pbImage, &cxImgSize, &cyImgSize, &cImgChannels, &bkgColor))
-1.                 return 0;

 /*invalidate the client area for later update*/

1.             InvalidateRect (hwnd, NULL, TRUE);",Useful
/*Get the Height and Width of the child window*/,"-6. BOOL CenterAbout (HWND hwndChild, HWND hwndParent)
-5. {
-4.    RECT    rChild, rParent, rWorkArea;
-3.    int     wChild, hChild, wParent, hParent;
-2.    int     xNew, yNew;
-1.    BOOL  bResult;

 /*Get the Height and Width of the child window*/

1.    GetWindowRect (hwndChild, &rChild);
2.    wChild = rChild.right - rChild.left;
3.    hChild = rChild.bottom - rChild.top;",Useful
/*Get the Height and Width of the parent window*/,"-3.    GetWindowRect (hwndChild, &rChild);
-2.    wChild = rChild.right - rChild.left;
-1.    hChild = rChild.bottom - rChild.top;

 /*Get the Height and Width of the parent window*/

1.    GetWindowRect (hwndParent, &rParent);
2.    wParent = rParent.right - rParent.left;
3.    hParent = rParent.bottom - rParent.top;",Useful
/*system parameter to query or set*/,"-1.    bResult = SystemParametersInfo(

 /*system parameter to query or set*/

1.       sizeof(RECT),
2.       &rWorkArea,
3.       0);
4.    if (!bResult) {
5.       rWorkArea.left = rWorkArea.top = 0;
6.       rWorkArea.right = GetSystemMetrics(SM_CXSCREEN);
7.       rWorkArea.bottom = GetSystemMetrics(SM_CYSCREEN);
8.    }",Useful
"/*Calculate new X position, then adjust for workarea*/","-8.       sizeof(RECT),
-7.       &rWorkArea,
-6.       0);
-5.    if (!bResult) {
-4.       rWorkArea.left = rWorkArea.top = 0;
-3.       rWorkArea.right = GetSystemMetrics(SM_CXSCREEN);
-2.       rWorkArea.bottom = GetSystemMetrics(SM_CYSCREEN);
-1.    }

 /*Calculate new X position, then adjust for workarea*/

1.    xNew = rParent.left + ((wParent - wChild) /2);
2.    if (xNew < rWorkArea.left) {
3.       xNew = rWorkArea.left;
4.    } else if ((xNew+wChild) > rWorkArea.right) {
5.       xNew = rWorkArea.right - wChild;
6.    }",Useful
"/*Calculate new Y position, then adjust for workarea*/","-6.    xNew = rParent.left + ((wParent - wChild) /2);
-5.    if (xNew < rWorkArea.left) {
-4.       xNew = rWorkArea.left;
-3.    } else if ((xNew+wChild) > rWorkArea.right) {
-2.       xNew = rWorkArea.right - wChild;
-1.    }

 /*Calculate new Y position, then adjust for workarea*/

1.    yNew = rParent.top  + ((hParent - hChild) /2);
2.    if (yNew < rWorkArea.top) {
3.       yNew = rWorkArea.top;
4.    } else if ((yNew+hChild) > rWorkArea.bottom) {
5.       yNew = rWorkArea.bottom - hChild;
6.    }",Useful
/*first cycle: count number of files in directory for memory allocation*/,"-5.     strcpy (szImgPathName, pstrPathName);
-4.     strcpy (szImgFileName, strrchr (pstrPathName, '\\') + 1);
-3.     strcpy (szImgFindName, szImgPathName);
-2.     *(strrchr (szImgFindName, '\\') + 1) = '\0';
-1.     strcat (szImgFindName, ""*.png"");

 /*first cycle: count number of files in directory for memory allocation*/

1.     *pFileCount = 0;
2.     hFind = FindFirstFile(szImgFindName, &finddata);
3.     bOk = (hFind != (HANDLE) -1);
4.     while (bOk)
5.     {
6.         *pFileCount += 1;
7.         bOk = FindNextFile(hFind, &finddata);
8.     }
9.     FindClose(hFind);",Useful
/*allocation memory for file-list*/,"-9.     *pFileCount = 0;
-8.     hFind = FindFirstFile(szImgFindName, &finddata);
-7.     bOk = (hFind != (HANDLE) -1);
-6.     while (bOk)
-5.     {
-4.         *pFileCount += 1;
-3.         bOk = FindNextFile(hFind, &finddata);
-2.     }
-1.     FindClose(hFind);

 /*allocation memory for file-list*/

1.     *ppFileList = (TCHAR *) malloc (*pFileCount * MAX_PATH);",Useful
/*second cycle: read directory and store filenames in file-list*/,"-1.     *ppFileList = (TCHAR *) malloc (*pFileCount * MAX_PATH);

 /*second cycle: read directory and store filenames in file-list*/

1.     hFind = FindFirstFile(szImgFindName, &finddata);
2.     bOk = (hFind != (HANDLE) -1);
3.     i = 0;
4.     ii = 0;
5.     while (bOk)
6.     {
7.         strcpy (*ppFileList + ii, szImgPathName);
8.         strcpy (strrchr(*ppFileList + ii, '\\') + 1, finddata.cFileName);
9.         if (strcmp(pstrPathName, *ppFileList + ii) == 0)
10.             *pFileIndex = i;",Useful
/*finally we must sort the file-list*/,"-10.     {
-9.         strcpy (*ppFileList + ii, szImgPathName);
-8.         strcpy (strrchr(*ppFileList + ii, '\\') + 1, finddata.cFileName);
-7.         if (strcmp(pstrPathName, *ppFileList + ii) == 0)
-6.             *pFileIndex = i;
-5.         ii += MAX_PATH;
-4.         i++;
-3.         bOk = FindNextFile(hFind, &finddata);
-2.     }
-1.     FindClose(hFind);

 /*finally we must sort the file-list*/

1.     for (i = 0; i < *pFileCount - 1; i++)
2.     {
3.         ii = i * MAX_PATH;
4.         for (j = i+1; j < *pFileCount; j++)
5.         {
6.             jj = j * MAX_PATH;
7.             if (strcmp (*ppFileList + ii, *ppFileList + jj) > 0)
8.             {
9.                 strcpy (szTmp, *ppFileList + jj);
10.                 strcpy (*ppFileList + jj, *ppFileList + ii);",Useful
/*check if this was the current image that we moved*/,"-10.     {
-9.         ii = i * MAX_PATH;
-8.         for (j = i+1; j < *pFileCount; j++)
-7.         {
-6.             jj = j * MAX_PATH;
-5.             if (strcmp (*ppFileList + ii, *ppFileList + jj) > 0)
-4.             {
-3.                 strcpy (szTmp, *ppFileList + jj);
-2.                 strcpy (*ppFileList + jj, *ppFileList + ii);
-1.                 strcpy (*ppFileList + ii, szTmp);

 /*check if this was the current image that we moved*/

1.                 if (*pFileIndex == i)
2.                     *pFileIndex = j;
3.                 else
4.                     if (*pFileIndex == j)
5.                         *pFileIndex = i;
6.             }
7.         }
8.     }
9.     return TRUE;
10. }",Useful
"/*if there's an existing PNG, free the memory*/","-5. BOOL LoadImageFile (HWND hwnd, PTSTR pstrPathName,
-4.                 png_byte **ppbImage, int *pxImgSize, int *pyImgSize,
-3.                 int *piChannels, png_color *pBkgColor)
-2. {
-1.     static TCHAR szTmp [MAX_PATH];

 /*if there's an existing PNG, free the memory*/

1.     if (*ppbImage)
2.     {
3.         free (*ppbImage);
4.         *ppbImage = NULL;
5.     }",Useful
/*first fill bitmap with gray and image border*/,"-9.     pbmih = (BITMAPINFOHEADER *) pDib;
-8.     pbmih->biSize = sizeof(BITMAPINFOHEADER);
-7.     pbmih->biWidth = cxWinSize;
-6.     pbmih->biHeight = -((long) cyWinSize);
-5.     pbmih->biPlanes = 1;
-4.     pbmih->biBitCount = 24;
-3.     pbmih->biCompression = 0;
-2.     pDiData = pDib + sizeof(BITMAPINFOHEADER);
-1.     *ppDiData = pDiData;

 /*first fill bitmap with gray and image border*/

1.     InitBitmap (pDiData, cxWinSize, cyWinSize);",Useful
/*initialize the background with gray*/,"-4. BOOL InitBitmap (BYTE *pDiData, int cxWinSize, int cyWinSize)
-3. {
-2.     BYTE *dst;
-1.     int x, y, col;

 /*initialize the background with gray*/

1.     dst = pDiData;
2.     for (y = 0; y < cyWinSize; y++)
3.     {
4.         col = 0;
5.         for (x = 0; x < cxWinSize; x++)
6.         {",Useful
/*rows start on 4 byte boundaries*/,"-5.             *dst++ = 127;
-4.             *dst++ = 127;
-3.             *dst++ = 127;
-2.             col += 3;
-1.         }

 /*rows start on 4 byte boundaries*/

1.         while ((col % 4) != 0)
2.         {
3.             dst++;
4.             col++;
5.         }
6.     }
7.     return TRUE;
8. }
9. /*--------------
10.  *  FillBitmap",Useful
"/*the following two are mathematically the same, but the first
         * has side-effects because of rounding*/","
        /* the following two are mathematically the same, but the first
         * has side-effects because of rounding



 /*the following two are mathematically the same, but the first
         * has side-effects because of rounding*/

1.          */",Useful
/*check for image larger than window*/,"-2.         cxImgPos = (cxWinSize - cxImgSize) / 2;
-1.         cyImgPos = (cyWinSize - cyImgSize) / 2;

 /*check for image larger than window*/

1.         if (cxImgPos < MARGIN)
2.             cxImgPos = MARGIN;
3.         if (cyImgPos < MARGIN)
4.             cyImgPos = MARGIN;",Useful
"/*png_free might call png_error and may certainly call
       * png_get_mem_ptr, so fake a temporary png_struct to support this.*/","-4. png_destroy_png_struct(png_structrp png_ptr)
-3. {
-2.    if (png_ptr != NULL)
-1.    {
      /* png_free might call png_error and may certainly call
       * png_get_mem_ptr, so fake a temporary png_struct to support this.

 /*png_free might call png_error and may certainly call
       * png_get_mem_ptr, so fake a temporary png_struct to support this.*/

1.        */
2.       png_struct dummy_struct = *png_ptr;
3.       memset(png_ptr, 0, (sizeof *png_ptr));
4.       png_free(&dummy_struct, png_ptr);
5. #     ifdef PNG_SETJMP_SUPPORTED",Useful
"/*Allocate memory.  For reasonable files, size should never exceed
 * 64K.  However, zlib may allocate more than 64K if you don't tell
 * it not to.  See zconf.h and png.h for more information.  zlib does
 * need to allocate exactly 64K, so whatever you call here must
 * have the ability to do that.*/","-4.          png_free_jmpbuf(&dummy_struct);
-3. #     endif
-2.    }
-1. }
/* Allocate memory.  For reasonable files, size should never exceed
 * 64K.  However, zlib may allocate more than 64K if you don't tell
 * it not to.  See zconf.h and png.h for more information.  zlib does
 * need to allocate exactly 64K, so whatever you call here must
 * have the ability to do that.

 /*Allocate memory.  For reasonable files, size should never exceed
 * 64K.  However, zlib may allocate more than 64K if you don't tell
 * it not to.  See zconf.h and png.h for more information.  zlib does
 * need to allocate exactly 64K, so whatever you call here must
 * have the ability to do that.*/

1.  */
2. PNG_FUNCTION(png_voidp,PNGAPI
3. png_calloc,(png_const_structrp png_ptr, png_alloc_size_t size),PNG_ALLOCATED)
4. {
5.    png_voidp ret;
6.    ret = png_malloc(png_ptr, size);
7.    if (ret != NULL)
8.       memset(ret, 0, size);
9.    return ret;
10. }",Useful
"/*png_malloc_base, an internal function added at libpng 1.6.0, does the work of
 * allocating memory, taking into account limits and PNG_USER_MEM_SUPPORTED.
 * Checking and error handling must happen outside this routine; it returns NULL
 * if the allocation cannot be done (for any reason.)*/","-10.  */
-9. PNG_FUNCTION(png_voidp,PNGAPI
-8. png_calloc,(png_const_structrp png_ptr, png_alloc_size_t size),PNG_ALLOCATED)
-7. {
-6.    png_voidp ret;
-5.    ret = png_malloc(png_ptr, size);
-4.    if (ret != NULL)
-3.       memset(ret, 0, size);
-2.    return ret;
-1. }
/* png_malloc_base, an internal function added at libpng 1.6.0, does the work of
 * allocating memory, taking into account limits and PNG_USER_MEM_SUPPORTED.
 * Checking and error handling must happen outside this routine; it returns NULL
 * if the allocation cannot be done (for any reason.)

 /*png_malloc_base, an internal function added at libpng 1.6.0, does the work of
 * allocating memory, taking into account limits and PNG_USER_MEM_SUPPORTED.
 * Checking and error handling must happen outside this routine; it returns NULL
 * if the allocation cannot be done (for any reason.)*/

1.  */",Useful
"/*Moved to png_malloc_base from png_malloc_default in 1.6.0; the DOS
    * allocators have also been removed in 1.6.0, so any 16-bit system now has
    * to implement a user memory handler.  This checks to be sure it isn't
    * called with big numbers.*/","-3. png_malloc_base,(png_const_structrp png_ptr, png_alloc_size_t size),
-2.     PNG_ALLOCATED)
-1. {
   /* Moved to png_malloc_base from png_malloc_default in 1.6.0; the DOS
    * allocators have also been removed in 1.6.0, so any 16-bit system now has
    * to implement a user memory handler.  This checks to be sure it isn't
    * called with big numbers.

 /*Moved to png_malloc_base from png_malloc_default in 1.6.0; the DOS
    * allocators have also been removed in 1.6.0, so any 16-bit system now has
    * to implement a user memory handler.  This checks to be sure it isn't
    * called with big numbers.*/

1.     */
2. #ifndef PNG_USER_MEM_SUPPORTED
3.    PNG_UNUSED(png_ptr)
4. #endif",Useful
"/*This is really here only to work round a spurious warning in GCC 4.6 and 4.7
 * that arises because of the checks in png_realloc_array that are repeated in
 * png_malloc_array.*/","-6.    }
-5.    else
-4.       return NULL;
-3. }
-2. #if defined(PNG_TEXT_SUPPORTED) || defined(PNG_sPLT_SUPPORTED) ||\
-1.    defined(PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED)
/* This is really here only to work round a spurious warning in GCC 4.6 and 4.7
 * that arises because of the checks in png_realloc_array that are repeated in
 * png_malloc_array.

 /*This is really here only to work round a spurious warning in GCC 4.6 and 4.7
 * that arises because of the checks in png_realloc_array that are repeated in
 * png_malloc_array.*/

1.  */
2. static png_voidp
3. png_malloc_array_checked(png_const_structrp png_ptr, int nelements,
4.     size_t element_size)
5. {",Useful
/*These are internal errors:*/,"-3. png_realloc_array,(png_const_structrp png_ptr, png_const_voidp old_array,
-2.     int old_elements, int add_elements, size_t element_size),PNG_ALLOCATED)
-1. {

 /*These are internal errors:*/

1.    if (add_elements <= 0 || element_size == 0 || old_elements < 0 ||
2.       (old_array == NULL && old_elements > 0))
3.       png_error(png_ptr, ""internal error: array realloc"");",Useful
"/*Check for overflow on the elements count (so the caller does not have to
    * check.)*/","-3.    if (add_elements <= 0 || element_size == 0 || old_elements < 0 ||
-2.       (old_array == NULL && old_elements > 0))
-1.       png_error(png_ptr, ""internal error: array realloc"");
   /* Check for overflow on the elements count (so the caller does not have to
    * check.)

 /*Check for overflow on the elements count (so the caller does not have to
    * check.)*/

1.     */
2.    if (add_elements <= INT_MAX - old_elements)
3.    {
4.       png_voidp new_array = png_malloc_array_checked(png_ptr,
5.           old_elements+add_elements, element_size);
6.       if (new_array != NULL)
7.       {",Useful
"/*Because png_malloc_array worked the size calculations below cannot
          * overflow.*/","-6.    if (add_elements <= INT_MAX - old_elements)
-5.    {
-4.       png_voidp new_array = png_malloc_array_checked(png_ptr,
-3.           old_elements+add_elements, element_size);
-2.       if (new_array != NULL)
-1.       {
         /* Because png_malloc_array worked the size calculations below cannot
          * overflow.

 /*Because png_malloc_array worked the size calculations below cannot
          * overflow.*/

1.           */
2.          if (old_elements > 0)
3.             memcpy(new_array, old_array, element_size*(unsigned)old_elements);
4.          memset((char*)new_array + element_size*(unsigned)old_elements, 0,
5.              element_size*(unsigned)add_elements);
6.          return new_array;
7.       }
8.    }",Useful
"/*Various functions that have different error handling are derived from this.
 * png_malloc always exists, but if PNG_USER_MEM_SUPPORTED is defined a separate
 * function png_malloc_default is also provided.*/","
/* Various functions that have different error handling are derived from this.
 * png_malloc always exists, but if PNG_USER_MEM_SUPPORTED is defined a separate
 * function png_malloc_default is also provided.



 /*Various functions that have different error handling are derived from this.
 * png_malloc always exists, but if PNG_USER_MEM_SUPPORTED is defined a separate
 * function png_malloc_default is also provided.*/

1.  */
2. PNG_FUNCTION(png_voidp,PNGAPI
3. png_malloc,(png_const_structrp png_ptr, png_alloc_size_t size),PNG_ALLOCATED)
4. {
5.    png_voidp ret;
6.    if (png_ptr == NULL)
7.       return NULL;
8.    ret = png_malloc_base(png_ptr, size);
9.    if (ret == NULL)",Useful
/*Passing 'NULL' here bypasses the application provided memory handler.*/,"-10.    return ret;
-9. }
-8. #ifdef PNG_USER_MEM_SUPPORTED
-7. PNG_FUNCTION(png_voidp,PNGAPI
-6. png_malloc_default,(png_const_structrp png_ptr, png_alloc_size_t size),
-5.     PNG_ALLOCATED PNG_DEPRECATED)
-4. {
-3.    png_voidp ret;
-2.    if (png_ptr == NULL)
-1.       return NULL;

 /*Passing 'NULL' here bypasses the application provided memory handler.*/

 ",Useful
"/*This function was added at libpng version 1.2.3.  The png_malloc_warn()
 * function will issue a png_warning and return NULL instead of issuing a
 * png_error, if it fails to allocate the requested memory.*/","/* This function was added at libpng version 1.2.3.  The png_malloc_warn()
 * function will issue a png_warning and return NULL instead of issuing a
 * png_error, if it fails to allocate the requested memory.

 /*This function was added at libpng version 1.2.3.  The png_malloc_warn()
 * function will issue a png_warning and return NULL instead of issuing a
 * png_error, if it fails to allocate the requested memory.*/

1.  */
2. PNG_FUNCTION(png_voidp,PNGAPI
3. png_malloc_warn,(png_const_structrp png_ptr, png_alloc_size_t size),
4.     PNG_ALLOCATED)
5. {
6.    if (png_ptr != NULL)
7.    {
8.       png_voidp ret = png_malloc_base(png_ptr, size);
9.       if (ret != NULL)
10.          return ret;",Useful
"/*Free a pointer allocated by png_malloc().  If ptr is NULL, return
 * without taking any action.*/","-10. {
-9.    if (png_ptr != NULL)
-8.    {
-7.       png_voidp ret = png_malloc_base(png_ptr, size);
-6.       if (ret != NULL)
-5.          return ret;
-4.       png_warning(png_ptr, ""Out of memory"");
-3.    }
-2.    return NULL;
-1. }
/* Free a pointer allocated by png_malloc().  If ptr is NULL, return
 * without taking any action.

 /*Free a pointer allocated by png_malloc().  If ptr is NULL, return
 * without taking any action.*/

1.  */
2. void PNGAPI
3. png_free(png_const_structrp png_ptr, png_voidp ptr)
4. {
5.    if (png_ptr == NULL || ptr == NULL)
6.       return;
7. #ifdef PNG_USER_MEM_SUPPORTED
8.    if (png_ptr->free_fn != NULL)
9.       png_ptr->free_fn(png_constcast(png_structrp,png_ptr), ptr);
10.    else",Useful
"/*This function is called when the application wants to use another method
 * of allocating and freeing memory.*/","-3.    free(ptr);
-2. }
-1. #ifdef PNG_USER_MEM_SUPPORTED
/* This function is called when the application wants to use another method
 * of allocating and freeing memory.

 /*This function is called when the application wants to use another method
 * of allocating and freeing memory.*/

1.  */
2. void PNGAPI
3. png_set_mem_fn(png_structrp png_ptr, png_voidp mem_ptr, png_malloc_ptr
4.   malloc_fn, png_free_ptr free_fn)
5. {
6.    if (png_ptr != NULL)
7.    {
8.       png_ptr->mem_ptr = mem_ptr;
9.       png_ptr->malloc_fn = malloc_fn;
10.       png_ptr->free_fn = free_fn;",Useful
"/*This function returns a pointer to the mem_ptr associated with the user
 * functions.  The application should free any memory associated with this
 * pointer before png_write_destroy and png_read_destroy are called.*/","-10. png_set_mem_fn(png_structrp png_ptr, png_voidp mem_ptr, png_malloc_ptr
-9.   malloc_fn, png_free_ptr free_fn)
-8. {
-7.    if (png_ptr != NULL)
-6.    {
-5.       png_ptr->mem_ptr = mem_ptr;
-4.       png_ptr->malloc_fn = malloc_fn;
-3.       png_ptr->free_fn = free_fn;
-2.    }
-1. }
/* This function returns a pointer to the mem_ptr associated with the user
 * functions.  The application should free any memory associated with this
 * pointer before png_write_destroy and png_read_destroy are called.

 /*This function returns a pointer to the mem_ptr associated with the user
 * functions.  The application should free any memory associated with this
 * pointer before png_write_destroy and png_read_destroy are called.*/

1.  */
2. png_voidp PNGAPI
3. png_get_mem_ptr(png_const_structrp png_ptr)
4. {
5.    if (png_ptr == NULL)
6.       return NULL;
7.    return png_ptr->mem_ptr;
8. }",Useful
"/*Define the following to use this test against your installed libpng, rather
 * than the one being built here:*/","-10. #include <stddef.h>
-9. #include <stdlib.h>
-8. #include <string.h>
-7. #include <stdio.h>
-6. #include <errno.h>
-5. #include <ctype.h>
-4. #include <math.h>
-3. #if defined(HAVE_CONFIG_H) && !defined(PNG_NO_CONFIG_H)
-2. #  include <config.h>
-1. #endif
/* Define the following to use this test against your installed libpng, rather
 * than the one being built here:

 /*Define the following to use this test against your installed libpng, rather
 * than the one being built here:*/

1.  */
2. #ifdef PNG_FREESTANDING_TESTS
3. #  include <png.h>
4. #else
5. #  include ""../../png.h""
6. #endif",Useful
"/*1.6.1 added support for the configure test harness, which uses 77 to indicate
 * a skipped test, in earlier versions we need to succeed on a skipped test, so:*/","-5. #ifdef PNG_FREESTANDING_TESTS
-4. #  include <png.h>
-3. #else
-2. #  include ""../../png.h""
-1. #endif
/* 1.6.1 added support for the configure test harness, which uses 77 to indicate
 * a skipped test, in earlier versions we need to succeed on a skipped test, so:

 /*1.6.1 added support for the configure test harness, which uses 77 to indicate
 * a skipped test, in earlier versions we need to succeed on a skipped test, so:*/

1.  */
2. #if PNG_LIBPNG_VER >= 10601 && defined(HAVE_CONFIG_H)
3. #  define SKIP 77
4. #else
5. #  define SKIP 0
6. #endif",Useful
"/*KNOWN ISSUES
 *
 * These defines switch on alternate algorithms for format conversions to match
 * the current libpng implementation; they are set to allow pngstest to pass
 * even though libpng is producing answers that are not as correct as they
 * should be.*/","-1. #include ""../tools/sRGB.h""
/* KNOWN ISSUES
 *
 * These defines switch on alternate algorithms for format conversions to match
 * the current libpng implementation; they are set to allow pngstest to pass
 * even though libpng is producing answers that are not as correct as they
 * should be.

 /*KNOWN ISSUES
 *
 * These defines switch on alternate algorithms for format conversions to match
 * the current libpng implementation; they are set to allow pngstest to pass
 * even though libpng is producing answers that are not as correct as they
 * should be.*/

1.  */
2. #define ALLOW_UNUSED_GPC 0",Useful
"/*If true include unused static GPC functions and declare an external array
    * of them to hide the fact that they are unused.  This is for development
    * use while testing the correct function to use to take into account libpng
    * misbehavior, such as using a simple power law to correct sRGB to linear.*/","-1. #define ALLOW_UNUSED_GPC 0
   /* If true include unused static GPC functions and declare an external array
    * of them to hide the fact that they are unused.  This is for development
    * use while testing the correct function to use to take into account libpng
    * misbehavior, such as using a simple power law to correct sRGB to linear.

 /*If true include unused static GPC functions and declare an external array
    * of them to hide the fact that they are unused.  This is for development
    * use while testing the correct function to use to take into account libpng
    * misbehavior, such as using a simple power law to correct sRGB to linear.*/

1.     */",Useful
"/*During parallel runs of pngstest each temporary file needs a unique name,
 * this is used to permit uniqueness using a command line argument which can be
 * up to 22 characters long.*/","/* During parallel runs of pngstest each temporary file needs a unique name,
 * this is used to permit uniqueness using a command line argument which can be
 * up to 22 characters long.

 /*During parallel runs of pngstest each temporary file needs a unique name,
 * this is used to permit uniqueness using a command line argument which can be
 * up to 22 characters long.*/

1.  */
2. static char tmpf[23] = ""TMP"";",Useful
"/*Generate random bytes.  This uses a boring repeatable algorithm and it
 * is implemented here so that it gives the same set of numbers on every
 * architecture.  It's a linear congruential generator (Knuth or Sedgewick
 * ""Algorithms"") but it comes from the 'feedback taps' table in Horowitz and
 * Hill, ""The Art of Electronics"".*/","-1. static char tmpf[23] = ""TMP"";
/* Generate random bytes.  This uses a boring repeatable algorithm and it
 * is implemented here so that it gives the same set of numbers on every
 * architecture.  It's a linear congruential generator (Knuth or Sedgewick
 * ""Algorithms"") but it comes from the 'feedback taps' table in Horowitz and
 * Hill, ""The Art of Electronics"".

 /*Generate random bytes.  This uses a boring repeatable algorithm and it
 * is implemented here so that it gives the same set of numbers on every
 * architecture.  It's a linear congruential generator (Knuth or Sedgewick
 * ""Algorithms"") but it comes from the 'feedback taps' table in Horowitz and
 * Hill, ""The Art of Electronics"".*/

1.  */
2. static void
3. make_random_bytes(png_uint_32* seed, void* pv, size_t size)
4. {
5.    png_uint_32 u0 = seed[0], u1 = seed[1];
6.    png_bytep bytes = voidcast(png_bytep, pv);",Useful
"/*There are thirty three bits, the next bit in the sequence is bit-33 XOR
    * bit-20.  The top 1 bit is in u1, the bottom 32 are in u0.*/","-10.  * is implemented here so that it gives the same set of numbers on every
-9.  * architecture.  It's a linear congruential generator (Knuth or Sedgewick
-8.  * ""Algorithms"") but it comes from the 'feedback taps' table in Horowitz and
-7.  * Hill, ""The Art of Electronics"".
-6.  */
-5. static void
-4. make_random_bytes(png_uint_32* seed, void* pv, size_t size)
-3. {
-2.    png_uint_32 u0 = seed[0], u1 = seed[1];
-1.    png_bytep bytes = voidcast(png_bytep, pv);
   /* There are thirty three bits, the next bit in the sequence is bit-33 XOR
    * bit-20.  The top 1 bit is in u1, the bottom 32 are in u0.

 /*There are thirty three bits, the next bit in the sequence is bit-33 XOR
    * bit-20.  The top 1 bit is in u1, the bottom 32 are in u0.*/

1.     */
2.    size_t i;
3.    for (i=0; i<size; ++i)
4.    {",Useful
/*First generate 8 new bits then shift them in at the end.*/,"-3.    size_t i;
-2.    for (i=0; i<size; ++i)
-1.    {

 /*First generate 8 new bits then shift them in at the end.*/

1.       png_uint_32 u = ((u0 >> (20-8)) ^ ((u1 << 7) | (u0 >> (32-7)))) & 0xff;
2.       u1 <<= 8;
3.       u1 |= u0 >> 24;
4.       u0 <<= 8;
5.       u0 |= u;
6.       *bytes++ = (png_byte)u;
7.    }
8.    seed[0] = u0;
9.    seed[1] = u1;
10. }",Useful
"/*Math support - neither Cygwin nor Visual Studio have C99 support and we need
 * a predictable rounding function, so make one here:*/","-10. reseed(void)
-9. {
-8.    color_seed[0] = 0x12345678U;
-7.    color_seed[1] = 0x9abcdefU;
-6. }
-5. static void
-4. random_color(png_colorp color)
-3. {
-2.    make_random_bytes(color_seed, color, sizeof *color);
-1. }
/* Math support - neither Cygwin nor Visual Studio have C99 support and we need
 * a predictable rounding function, so make one here:

 /*Math support - neither Cygwin nor Visual Studio have C99 support and we need
 * a predictable rounding function, so make one here:*/

1.  */
2. static double
3. closestinteger(double x)
4. {
5.    return floor(x + .5);
6. }",Useful
/*Cast support: remove GCC whines.*/,"-5. static double
-4. closestinteger(double x)
-3. {
-2.    return floor(x + .5);
-1. }

 /*Cast support: remove GCC whines.*/

1. static png_byte
2. u8d(double d)
3. {
4.    d = closestinteger(d);
5.    return (png_byte)d;
6. }
7. static png_uint_16
8. u16d(double d)
9. {
10.    d = closestinteger(d);",Useful
"/*sRGB support: use exact calculations rounded to the nearest int, see the
 * fesetround() call in main().  sRGB_to_d optimizes the 8 to 16-bit conversion.*/","-10. {
-9.    d = closestinteger(d);
-8.    return (png_byte)d;
-7. }
-6. static png_uint_16
-5. u16d(double d)
-4. {
-3.    d = closestinteger(d);
-2.    return (png_uint_16)d;
-1. }
/* sRGB support: use exact calculations rounded to the nearest int, see the
 * fesetround() call in main().  sRGB_to_d optimizes the 8 to 16-bit conversion.

 /*sRGB support: use exact calculations rounded to the nearest int, see the
 * fesetround() call in main().  sRGB_to_d optimizes the 8 to 16-bit conversion.*/

1.  */
2. static double sRGB_to_d[256];
3. static double g22_to_d[256];
4. static void
5. init_sRGB_to_d(void)
6. {
7.    int i;
8.    sRGB_to_d[0] = 0;
9.    for (i=1; i<255; ++i)
10.       sRGB_to_d[i] = linear_from_sRGB(i/255.);",Useful
"/*The error that results from using a 2.2 power law in place of the correct
 * sRGB transform, given an 8-bit value which might be either sRGB or power-law.*/","/* The error that results from using a 2.2 power law in place of the correct
 * sRGB transform, given an 8-bit value which might be either sRGB or power-law.

 /*The error that results from using a 2.2 power law in place of the correct
 * sRGB transform, given an 8-bit value which might be either sRGB or power-law.*/

1.  */
2. static int
3. power_law_error8(int value)
4. {
5.    if (value > 0 && value < 255)
6.    {
7.       double vd = value / 255.;
8.       double e = fabs(
9.          pow(sRGB_to_d[value], 1/2.2) - sRGB_from_linear(pow(vd, 2.2)));",Useful
/*Always allow an extra 1 here for rounding errors*/,"-10.  * sRGB transform, given an 8-bit value which might be either sRGB or power-law.
-9.  */
-8. static int
-7. power_law_error8(int value)
-6. {
-5.    if (value > 0 && value < 255)
-4.    {
-3.       double vd = value / 255.;
-2.       double e = fabs(
-1.          pow(sRGB_to_d[value], 1/2.2) - sRGB_from_linear(pow(vd, 2.2)));

 /*Always allow an extra 1 here for rounding errors*/

1.       e = 1+floor(255 * e);
2.       return (int)e;
3.    }
4.    return 0;
5. }",Useful
/*Always allow an extra 1 here for rounding errors*/,"-10.  * sRGB transform, given an 8-bit value which might be either sRGB or power-law.
-9.  */
-8. static int
-7. power_law_error8(int value)
-6. {
-5.    if (value > 0 && value < 255)
-4.    {
-3.       double vd = value / 255.;
-2.       double e = fabs(
-1.          pow(sRGB_to_d[value], 1/2.2) - sRGB_from_linear(pow(vd, 2.2)));

 /*Always allow an extra 1 here for rounding errors*/

1.       e = 1+floor(255 * e);
2.       return (int)e;
3.    }
4.    return 0;
5. }",Useful
"/*""multiple_algorithms"" in this case means that a color-map has been
    * involved somewhere, so we can deduce that the values were forced to 8-bit
    * (like the via_linear case for 8-bit.)*/","-10.       return 1;
-9.    return 0;
-8. }
-7. static int
-6. compare_16bit(int v1, int v2, int error_limit, int multiple_algorithms)
-5. {
-4.    int e = abs(v1-v2);
-3.    int ev1, ev2;
-2.    if (e <= error_limit)
-1.       return 1;
   /* ""multiple_algorithms"" in this case means that a color-map has been
    * involved somewhere, so we can deduce that the values were forced to 8-bit
    * (like the via_linear case for 8-bit.)

 /*""multiple_algorithms"" in this case means that a color-map has been
    * involved somewhere, so we can deduce that the values were forced to 8-bit
    * (like the via_linear case for 8-bit.)*/

1.     */
2.    if (!multiple_algorithms)
3.       return 0;
4.    ev1 = power_law_error16(v1);
5.    if (e <= ev1)
6.       return 1;
7.    ev2 = power_law_error16(v2);
8.    if (e <= ev2)
9.       return 1;
10.    return 0;",Useful
/*else delete temporary files*/,"-1. #define VERBOSE 8

 /*else delete temporary files*/

1. #define KEEP_GOING 32
2. #define ACCUMULATE 64
3. #define FAST_WRITE 128
4. #define sRGB_16BIT 256",Useful
/*do not reseed on each new file*/,"-4. #define KEEP_GOING 32
-3. #define ACCUMULATE 64
-2. #define FAST_WRITE 128
-1. #define sRGB_16BIT 256

 /*do not reseed on each new file*/

 ",Useful
"/*do not ignore the gamma+background_rgb_to_gray
                          * libpng warning.*/","-5. #define KEEP_GOING 32
-4. #define ACCUMULATE 64
-3. #define FAST_WRITE 128
-2. #define sRGB_16BIT 256

 /*do not ignore the gamma+background_rgb_to_gray
                          * libpng warning.*/

1. static void
2. print_opts(png_uint_32 opts)
3. {
4.    if (opts & USE_FILE)
5.       printf("" --file"");
6.    if (opts & USE_STDIO)
7.       printf("" --stdio"");
8.    if (!(opts & STRICT))
9.       printf("" --nostrict"");
10.    if (opts & VERBOSE)",Useful
/*else on by default*/,"-5.       printf("" --slow"");
-4.    if (opts & sRGB_16BIT)
-3.       printf("" --sRGB-16bit"");
-2.    if (opts & NO_RESEED)
-1.       printf("" --noreseed"");

 /*else on by default*/

1.    if (opts & GBG_ERROR)
2.       printf("" --fault-gbg-warning"");
3. #endif
4. }",Useful
"/*A name table for all the formats - defines the format of the '+' arguments to
 * pngstest.*/","
/* A name table for all the formats - defines the format of the '+' arguments to
 * pngstest.



 /*A name table for all the formats - defines the format of the '+' arguments to
 * pngstest.*/

1.  */
2. #define FORMAT_COUNT 64
3. #define FORMAT_MASK 0x3f
4. static PNG_CONST char * PNG_CONST format_names[FORMAT_COUNT] =
5. {
6.    ""sRGB-gray"",
7.    ""sRGB-gray+alpha"",
8.    ""sRGB-rgb"",
9.    ""sRGB-rgb+alpha"",
10.    ""linear-gray"",",Useful
/*Decode an argument to a format number.*/,"-10.    ""alpha+linear-bgr"",
-9.    ""color-mapped-sRGB-gray"",
-8.    ""color-mapped-alpha+sRGB-gray"",
-7.    ""color-mapped-sRGB-bgr"",
-6.    ""color-mapped-alpha+sRGB-bgr"",
-5.    ""color-mapped-linear-gray"",
-4.    ""color-mapped-alpha+linear-gray"",
-3.    ""color-mapped-linear-bgr"",
-2.    ""color-mapped-alpha+linear-bgr"",
-1. };

 /*Decode an argument to a format number.*/

1. static png_uint_32
2. formatof(const char *arg)
3. {
4.    char *ep;
5.    unsigned long format = strtoul(arg, &ep, 0);
6.    if (ep > arg && *ep == 0 && format < FORMAT_COUNT)
7.       return (png_uint_32)format;
8.    else for (format=0; format < FORMAT_COUNT; ++format)
9.    {
10.       if (strcmp(format_names[format], arg) == 0)",Useful
"/*set everything, including flags that are pointless*/","-10. static int format_isset(format_list *pf, png_uint_32 format)
-9. {
-8.    return format < FORMAT_COUNT &&
-7.       (pf->bits[format >> 5] & (((png_uint_32)1) << (format & 31))) != 0;
-6. }
-5. static void format_default(format_list *pf, int redundant)
-4. {
-3.    if (redundant)
-2.    {
-1.       int i;

 /*set everything, including flags that are pointless*/

1.       for (i=0; i<FORMAT_SET_COUNT; ++i)
2.          pf->bits[i] = ~(png_uint_32)0;
3.    }
4.    else
5.    {
6.       png_uint_32 f;
7.       for (f=0; f<FORMAT_COUNT; ++f)
8.       {",Useful
/*HACK: fixed value*/,"-3.             if ((f & PNG_FORMAT_FLAG_COLOR) == 0 &&
-2.                (f & PNG_FORMAT_FLAG_BGR) != 0)
-1. #        else

 /*HACK: fixed value*/

1. #        endif
2.             continue;",Useful
/*HACK: fixed value*/,"-3.             if ((f & PNG_FORMAT_FLAG_COLOR) == 0 &&
-2.                (f & PNG_FORMAT_FLAG_BGR) != 0)
-1. #        else

 /*HACK: fixed value*/

1. #        endif
2.             continue;",Useful
"/*The super-class of a png_image, contains the decoded image plus the input
 * data necessary to re-read the file with a different format.*/","
/* The super-class of a png_image, contains the decoded image plus the input
 * data necessary to re-read the file with a different format.



 /*The super-class of a png_image, contains the decoded image plus the input
 * data necessary to re-read the file with a different format.*/

1.  */
2. typedef struct
3. {
4.    png_image   image;
5.    png_uint_32 opts;
6.    const char *file_name;
7.    int         stride_extra;
8.    FILE       *input_file;
9.    png_voidp   input_memory;
10.    png_size_t  input_memory_size;",Useful
/*Initializer: also sets the permitted error limit for 16-bit operations.*/,"-10.    png_voidp   input_memory;
-9.    png_size_t  input_memory_size;
-8.    png_bytep   buffer;
-7.    ptrdiff_t   stride;
-6.    png_size_t  bufsize;
-5.    png_size_t  allocsize;
-4.    char        tmpfile_name[32];
-3.    png_uint_16 colormap[256*4];
-2. }
-1. Image;

 /*Initializer: also sets the permitted error limit for 16-bit operations.*/

1. static void
2. newimage(Image *image)
3. {
4.    memset(image, 0, sizeof *image);
5. }",Useful
/*Reset the image to be read again - only needs to rewind the FILE* at present.*/,"-5. static void
-4. newimage(Image *image)
-3. {
-2.    memset(image, 0, sizeof *image);
-1. }
/* Reset the image to be read again - only needs to rewind the FILE* at present.

 /*Reset the image to be read again - only needs to rewind the FILE* at present.*/

1.  */
2. static void
3. resetimage(Image *image)
4. {
5.    if (image->input_file != NULL)
6.       rewind(image->input_file);
7. }",Useful
"/*Free the image buffer; the buffer is re-used on a re-read, this is just for
 * cleanup.*/","-6. static void
-5. resetimage(Image *image)
-4. {
-3.    if (image->input_file != NULL)
-2.       rewind(image->input_file);
-1. }
/* Free the image buffer; the buffer is re-used on a re-read, this is just for
 * cleanup.

 /*Free the image buffer; the buffer is re-used on a re-read, this is just for
 * cleanup.*/

1.  */
2. static void
3. freebuffer(Image *image)
4. {
5.    if (image->buffer) free(image->buffer);
6.    image->buffer = NULL;
7.    image->bufsize = 0;
8.    image->allocsize = 0;
9. }
10. /* Delete function; cleans out all the allocated data and the temporary file in",Useful
"/*Delete function; cleans out all the allocated data and the temporary file in
 * the image.*/","-10.  * cleanup.
-9.  */
-8. static void
-7. freebuffer(Image *image)
-6. {
-5.    if (image->buffer) free(image->buffer);
-4.    image->buffer = NULL;
-3.    image->bufsize = 0;
-2.    image->allocsize = 0;
-1. }
/* Delete function; cleans out all the allocated data and the temporary file in
 * the image.

 /*Delete function; cleans out all the allocated data and the temporary file in
 * the image.*/

1.  */
2. static void
3. freeimage(Image *image)
4. {
5.    freebuffer(image);
6.    png_image_free(&image->image);
7.    if (image->input_file != NULL)
8.    {
9.       fclose(image->input_file);
10.       image->input_file = NULL;",Useful
"/*This is actually a re-initializer; allows an image structure to be re-used by
 * freeing everything that relates to an old image.*/","-10.       free(image->input_memory);
-9.       image->input_memory = NULL;
-8.       image->input_memory_size = 0;
-7.    }
-6.    if (image->tmpfile_name[0] != 0 && (image->opts & KEEP_TMPFILES) == 0)
-5.    {
-4.       (void)remove(image->tmpfile_name);
-3.       image->tmpfile_name[0] = 0;
-2.    }
-1. }
/* This is actually a re-initializer; allows an image structure to be re-used by
 * freeing everything that relates to an old image.

 /*This is actually a re-initializer; allows an image structure to be re-used by
 * freeing everything that relates to an old image.*/

1.  */
2. static void initimage(Image *image, png_uint_32 opts, const char *file_name,
3.    int stride_extra)
4. {
5.    freeimage(image);
6.    memset(&image->image, 0, sizeof image->image);
7.    image->opts = opts;
8.    image->file_name = file_name;
9.    image->stride_extra = stride_extra;
10. }",Useful
"/*Make sure the image buffer is big enough; allows re-use of the buffer if the
 * image is re-read.*/","-10.  */
-9. static void initimage(Image *image, png_uint_32 opts, const char *file_name,
-8.    int stride_extra)
-7. {
-6.    freeimage(image);
-5.    memset(&image->image, 0, sizeof image->image);
-4.    image->opts = opts;
-3.    image->file_name = file_name;
-2.    image->stride_extra = stride_extra;
-1. }
/* Make sure the image buffer is big enough; allows re-use of the buffer if the
 * image is re-read.

 /*Make sure the image buffer is big enough; allows re-use of the buffer if the
 * image is re-read.*/

1.  */
2. #define BUFFER_INIT8 73
3. static void
4. allocbuffer(Image *image)
5. {
6.    png_size_t size = PNG_IMAGE_BUFFER_SIZE(image->image, image->stride);
7.    if (size+32 > image->bufsize)
8.    {
9.       freebuffer(image);
10.       image->buffer = voidcast(png_bytep, malloc(size+32));",Useful
/*Make sure 16 bytes match the given byte.*/,"-10.             ""simpletest: out of memory allocating %lu(+32) byte buffer\n"",
-9.             (unsigned long)size);
-8.          exit(1);
-7.       }
-6.       image->bufsize = size+32;
-5.    }
-4.    memset(image->buffer, 95, image->bufsize);
-3.    memset(image->buffer+16, BUFFER_INIT8, size);
-2.    image->allocsize = size;
-1. }

 /*Make sure 16 bytes match the given byte.*/

1. static int
2. check16(png_const_bytep bp, int b)
3. {
4.    int i = 16;
5.    do
6.       if (*bp != b) return 1;
7.    while (--i);
8.    return 0;
9. }",Useful
/*Check for overwrite in the image buffer.*/,"-9. static int
-8. check16(png_const_bytep bp, int b)
-7. {
-6.    int i = 16;
-5.    do
-4.       if (*bp != b) return 1;
-3.    while (--i);
-2.    return 0;
-1. }

 /*Check for overwrite in the image buffer.*/

1. static void
2. checkbuffer(Image *image, const char *arg)
3. {
4.    if (check16(image->buffer, 95))
5.    {
6.       fflush(stdout);
7.       fprintf(stderr, ""%s: overwrite at start of image buffer\n"", arg);
8.       exit(1);
9.    }
10.    if (check16(image->buffer+16+image->allocsize, 95))",Useful
"/*Log a terminal error, also frees the libpng part of the image if necessary.*/","
/* Log a terminal error, also frees the libpng part of the image if necessary.



 /*Log a terminal error, also frees the libpng part of the image if necessary.*/

1.  */
2. static int
3. logerror(Image *image, const char *a1, const char *a2, const char *a3)
4. {
5.    fflush(stdout);
6.    if (image->image.warning_or_error)
7.       fprintf(stderr, ""%s%s%s: %s\n"", a1, a2, a3, image->image.message);
8.    else
9.       fprintf(stderr, ""%s%s%s\n"", a1, a2, a3);
10.    if (image->image.opaque != NULL)",Useful
"/*Log an error and close a file (just a utility to do both things in one
 * function call.)*/","-10.    else
-9.       fprintf(stderr, ""%s%s%s\n"", a1, a2, a3);
-8.    if (image->image.opaque != NULL)
-7.    {
-6.       fprintf(stderr, ""%s: image opaque pointer non-NULL on error\n"",
-5.          image->file_name);
-4.       png_image_free(&image->image);
-3.    }
-2.    return 0;
-1. }
/* Log an error and close a file (just a utility to do both things in one
 * function call.)

 /*Log an error and close a file (just a utility to do both things in one
 * function call.)*/

1.  */
2. static int
3. logclose(Image *image, FILE *f, const char *name, const char *operation)
4. {
5.    int e = errno;
6.    fclose(f);
7.    return logerror(image, name, operation, strerror(e));
8. }
9. /* Make sure the png_image has been freed - validates that libpng is doing what
10.  * the spec says and freeing the image.",Useful
"/*Make sure the png_image has been freed - validates that libpng is doing what
 * the spec says and freeing the image.*/","-7. static int
-6. logclose(Image *image, FILE *f, const char *name, const char *operation)
-5. {
-4.    int e = errno;
-3.    fclose(f);
-2.    return logerror(image, name, operation, strerror(e));
-1. }
/* Make sure the png_image has been freed - validates that libpng is doing what
 * the spec says and freeing the image.

 /*Make sure the png_image has been freed - validates that libpng is doing what
 * the spec says and freeing the image.*/

1.  */
2. static int
3. checkopaque(Image *image)
4. {
5.    if (image->image.opaque != NULL)
6.    {
7.       png_image_free(&image->image);
8.       return logerror(image, image->file_name, "": opaque not NULL"", """");
9.    }
10.    /* Separate out the gamma+background_rgb_to_gray warning because it may",Useful
"/*Separate out the gamma+background_rgb_to_gray warning because it may
    * produce opaque component errors:*/","-10.  * the spec says and freeing the image.
-9.  */
-8. static int
-7. checkopaque(Image *image)
-6. {
-5.    if (image->image.opaque != NULL)
-4.    {
-3.       png_image_free(&image->image);
-2.       return logerror(image, image->file_name, "": opaque not NULL"", """");
-1.    }
   /* Separate out the gamma+background_rgb_to_gray warning because it may
    * produce opaque component errors:

 /*Separate out the gamma+background_rgb_to_gray warning because it may
    * produce opaque component errors:*/

1.     */
2.    else if (image->image.warning_or_error != 0 &&
3.             (strcmp(image->image.message,
4.                ""libpng does not support gamma+background+rgb_to_gray"") == 0 ?
5.                   (image->opts & GBG_ERROR) != 0 : (image->opts & STRICT) != 0))
6.       return logerror(image, image->file_name, (image->opts & GBG_ERROR) != 0 ?
7.                       "" --fault-gbg-warning"" : "" --strict"", """");
8.    else
9.       return 1;
10. }",Useful
"/*Compare the pixels of two images, which should be the same but aren't.  The
 * images must have been checked for a size match.*/","
/* Compare the pixels of two images, which should be the same but aren't.  The
 * images must have been checked for a size match.



 /*Compare the pixels of two images, which should be the same but aren't.  The
 * images must have been checked for a size match.*/

1.  */
2. typedef struct
3. {",Useful
"/*The components, for grayscale images the gray value is in 'g' and if alpha
    * is not present 'a' is set to 255 or 65535 according to format.*/","-2. typedef struct
-1. {
   /* The components, for grayscale images the gray value is in 'g' and if alpha
    * is not present 'a' is set to 255 or 65535 according to format.

 /*The components, for grayscale images the gray value is in 'g' and if alpha
    * is not present 'a' is set to 255 or 65535 according to format.*/

1.     */
2.    int         r, g, b, a;
3. } Pixel;
4. typedef struct
5. {",Useful
"/*The background as the original sRGB 8-bit value converted to the final
    * integer format and as a double precision linear value in the range 0..1
    * for with partially transparent pixels.*/","-4.    int         r, g, b, a;
-3. } Pixel;
-2. typedef struct
-1. {
   /* The background as the original sRGB 8-bit value converted to the final
    * integer format and as a double precision linear value in the range 0..1
    * for with partially transparent pixels.

 /*The background as the original sRGB 8-bit value converted to the final
    * integer format and as a double precision linear value in the range 0..1
    * for with partially transparent pixels.*/

1.     */
2.    int ir, ig, ib;",Useful
"/*Read a Pixel from a buffer.  The code below stores the correct routine for
 * the format in a function pointer, these are the routines:*/","-2. #define BASE_FORMATS\
-1.    (PNG_FORMAT_FLAG_ALPHA|PNG_FORMAT_FLAG_COLOR|PNG_FORMAT_FLAG_LINEAR)
/* Read a Pixel from a buffer.  The code below stores the correct routine for
 * the format in a function pointer, these are the routines:

 /*Read a Pixel from a buffer.  The code below stores the correct routine for
 * the format in a function pointer, these are the routines:*/

1.  */
2. static void
3. gp_g8(Pixel *p, png_const_voidp pb)
4. {
5.    png_const_bytep pp = voidcast(png_const_bytep, pb);
6.    p->r = p->g = p->b = pp[0];
7.    p->a = 255;
8. }
9. static void
10. gp_ga8(Pixel *p, png_const_voidp pb)",Useful
"/*The color-map flag is irrelevant here - the caller of the function
    * returned must either pass the buffer or, for a color-mapped image, the
    * correct entry in the color-map.*/","-3. static void (*
-2. get_pixel(png_uint_32 format))(Pixel *p, png_const_voidp pb)
-1. {
   /* The color-map flag is irrelevant here - the caller of the function
    * returned must either pass the buffer or, for a color-mapped image, the
    * correct entry in the color-map.

 /*The color-map flag is irrelevant here - the caller of the function
    * returned must either pass the buffer or, for a color-mapped image, the
    * correct entry in the color-map.*/

1.     */
2.    if (format & PNG_FORMAT_FLAG_LINEAR)
3.    {
4.       if (format & PNG_FORMAT_FLAG_COLOR)
5.       {
6. #        ifdef PNG_FORMAT_BGR_SUPPORTED
7.             if (format & PNG_FORMAT_FLAG_BGR)
8.             {
9.                if (format & PNG_FORMAT_FLAG_ALPHA)
10.                {",Useful
/*bckg: composite on gray background*/,"-10.  *  8 G     .    .    .    .     lin  lin  lin  lin
-9.  *  8 GA    bckg .    bckc .     pre' pre  pre' pre
-8.  *  8 RGB   g8   g8   .    .     glin glin lin  lin
-7.  *  8 RGBA  g8b  g8   bckc .     gpr' gpre pre' pre
-6.  * 16 G     sRGB sRGB sRGB sRGB  .    .    .    .
-5.  * 16 GA    b16g unpg b16c unpc  A    .    A    .
-4.  * 16 RGB   sG   sG   sRGB sRGB  g16  g16  .    .
-3.  * 16 RGBA  gb16 sGp  cb16 sCp   g16  g16' A    .
-2.  *
-1.  *  8-bit to 8-bit:
 * bckg: composite on gray background

 /*bckg: composite on gray background*/

1.  * bckc: composite on color background
2.  * g8:   convert sRGB components to sRGB grayscale
3.  * g8b:  convert sRGB components to grayscale and composite on gray background
4.  *
5.  *  8-bit to 16-bit:
6.  * lin:  make sRGB components linear, alpha := 65535
7.  * pre:  make sRGB components linear and premultiply by alpha  (scale alpha)
8.  * pre': as 'pre' but alpha := 65535
9.  * glin: make sRGB components linear, convert to grayscale, alpha := 65535
10.  * gpre: make sRGB components grayscale and linear and premultiply by alpha",Useful
/*bckc: composite on color background*/,"-10.  *  8 GA    bckg .    bckc .     pre' pre  pre' pre
-9.  *  8 RGB   g8   g8   .    .     glin glin lin  lin
-8.  *  8 RGBA  g8b  g8   bckc .     gpr' gpre pre' pre
-7.  * 16 G     sRGB sRGB sRGB sRGB  .    .    .    .
-6.  * 16 GA    b16g unpg b16c unpc  A    .    A    .
-5.  * 16 RGB   sG   sG   sRGB sRGB  g16  g16  .    .
-4.  * 16 RGBA  gb16 sGp  cb16 sCp   g16  g16' A    .
-3.  *
-2.  *  8-bit to 8-bit:
-1.  * bckg: composite on gray background
 * bckc: composite on color background

 /*bckc: composite on color background*/

1.  * g8:   convert sRGB components to sRGB grayscale
2.  * g8b:  convert sRGB components to grayscale and composite on gray background
3.  *
4.  *  8-bit to 16-bit:
5.  * lin:  make sRGB components linear, alpha := 65535
6.  * pre:  make sRGB components linear and premultiply by alpha  (scale alpha)
7.  * pre': as 'pre' but alpha := 65535
8.  * glin: make sRGB components linear, convert to grayscale, alpha := 65535
9.  * gpre: make sRGB components grayscale and linear and premultiply by alpha
10.  * gpr': as 'gpre' but alpha := 65535",Useful
/*g8: convert sRGB components to sRGB grayscale*/,"-10.    }
-9.    else
-8.    {
-7.       double a = in->a / 255.;
-6.       out->r = sRGB(sRGB_to_d[in->r] * a + back->dr * (1-a));
-5.       out->g = sRGB(sRGB_to_d[in->g] * a + back->dg * (1-a));
-4.       out->b = sRGB(sRGB_to_d[in->b] * a + back->db * (1-a));
-3.    }
-2.    out->a = 255;
-1. }

 /*g8: convert sRGB components to sRGB grayscale*/

1. static void
2. gpc_g8(Pixel *out, const Pixel *in, const Background *back)
3. {
4.    (void)back;
5.    if (in->r == in->g && in->g == in->b)
6.       out->r = out->g = out->b = in->g;
7.    else
8.       out->r = out->g = out->b =
9.          sRGB(YfromRGB(sRGB_to_d[in->r], sRGB_to_d[in->g], sRGB_to_d[in->b]));
10.    out->a = in->a;",Useful
/*g8b: convert sRGB components to grayscale and composite on gray background*/,"-10. gpc_g8(Pixel *out, const Pixel *in, const Background *back)
-9. {
-8.    (void)back;
-7.    if (in->r == in->g && in->g == in->b)
-6.       out->r = out->g = out->b = in->g;
-5.    else
-4.       out->r = out->g = out->b =
-3.          sRGB(YfromRGB(sRGB_to_d[in->r], sRGB_to_d[in->g], sRGB_to_d[in->b]));
-2.    out->a = in->a;
-1. }

 /*g8b: convert sRGB components to grayscale and composite on gray background*/

1. static void
2. gpc_g8b(Pixel *out, const Pixel *in, const Background *back)
3. {
4.    if (in->a <= 0)
5.       out->r = out->g = out->b = back->ig;
6.    else if (in->a >= 255)
7.    {
8.       if (in->r == in->g && in->g == in->b)
9.          out->r = out->g = out->b = in->g;
10.       else",Useful
"/*lin: make sRGB components linear, alpha := 65535*/","-10.    }
-9.    else
-8.    {
-7.       double a = in->a/255.;
-6.       out->r = out->g = out->b = sRGB(a * YfromRGB(sRGB_to_d[in->r],
-5.          sRGB_to_d[in->g], sRGB_to_d[in->b]) + back->dg * (1-a));
-4.    }
-3.    out->a = 255;
-2. }

 /*lin: make sRGB components linear, alpha := 65535*/

1. static void
2. gpc_lin(Pixel *out, const Pixel *in, const Background *back)
3. {
4.    (void)back;
5.    out->r = ilinear(in->r);
6.    if (in->g == in->r)
7.    {
8.       out->g = out->r;
9.       if (in->b == in->r)
10.          out->b = out->r;",Useful
/*pre: make sRGB components linear and premultiply by alpha (scale alpha)*/,"-10.       out->g = ilinear(in->g);
-9.       if (in->b == in->r)
-8.          out->b = out->r;
-7.       else if (in->b == in->g)
-6.          out->b = out->g;
-5.       else
-4.          out->b = ilinear(in->b);
-3.    }
-2.    out->a = 65535;
-1. }

 /*pre: make sRGB components linear and premultiply by alpha (scale alpha)*/

1. static void
2. gpc_pre(Pixel *out, const Pixel *in, const Background *back)
3. {
4.    (void)back;
5.    out->r = ilineara(in->r, in->a);
6.    if (in->g == in->r)
7.    {
8.       out->g = out->r;
9.       if (in->b == in->r)
10.          out->b = out->r;",Useful
"/*glin: make sRGB components linear, convert to grayscale, alpha := 65535*/","-10.  *  8-bit to 8-bit:
-9.  * bckg: composite on gray background
-8.  * bckc: composite on color background
-7.  * g8:   convert sRGB components to sRGB grayscale
-6.  * g8b:  convert sRGB components to grayscale and composite on gray background
-5.  *
-4.  *  8-bit to 16-bit:
-3.  * lin:  make sRGB components linear, alpha := 65535
-2.  * pre:  make sRGB components linear and premultiply by alpha  (scale alpha)
-1.  * pre': as 'pre' but alpha := 65535
 * glin: make sRGB components linear, convert to grayscale, alpha := 65535

 /*glin: make sRGB components linear, convert to grayscale, alpha := 65535*/

1.  * gpre: make sRGB components grayscale and linear and premultiply by alpha
2.  * gpr': as 'gpre' but alpha := 65535
3.  *
4.  *  16-bit to 8-bit:
5.  * sRGB: convert linear components to sRGB, alpha := 255
6.  * unpg: unpremultiply gray component and convert to sRGB (scale alpha)
7.  * unpc: unpremultiply color components and convert to sRGB (scale alpha)
8.  * b16g: composite linear onto gray background and convert the result to sRGB
9.  * b16c: composite linear onto color background and convert the result to sRGB
10.  * sG:   convert linear RGB to sRGB grayscale",Useful
/*gpre: make sRGB components grayscale and linear and premultiply by alpha*/,"-10.  * bckg: composite on gray background
-9.  * bckc: composite on color background
-8.  * g8:   convert sRGB components to sRGB grayscale
-7.  * g8b:  convert sRGB components to grayscale and composite on gray background
-6.  *
-5.  *  8-bit to 16-bit:
-4.  * lin:  make sRGB components linear, alpha := 65535
-3.  * pre:  make sRGB components linear and premultiply by alpha  (scale alpha)
-2.  * pre': as 'pre' but alpha := 65535
-1.  * glin: make sRGB components linear, convert to grayscale, alpha := 65535
 * gpre: make sRGB components grayscale and linear and premultiply by alpha

 /*gpre: make sRGB components grayscale and linear and premultiply by alpha*/

1.  * gpr': as 'gpre' but alpha := 65535
2.  *
3.  *  16-bit to 8-bit:
4.  * sRGB: convert linear components to sRGB, alpha := 255
5.  * unpg: unpremultiply gray component and convert to sRGB (scale alpha)
6.  * unpc: unpremultiply color components and convert to sRGB (scale alpha)
7.  * b16g: composite linear onto gray background and convert the result to sRGB
8.  * b16c: composite linear onto color background and convert the result to sRGB
9.  * sG:   convert linear RGB to sRGB grayscale
10.  * sGp:  unpremultiply RGB then convert to sRGB grayscale",Useful
"/*Lin: make gAMA 45455 components linear, alpha := 65535*/","-10. {
-9.    (void)back;
-8.    if (in->r == in->g && in->g == in->b)
-7.       out->r = out->g = out->b = ilineara(in->g, in->a);
-6.    else
-5.       out->r = out->g = out->b = u16d(in->a * 257 *
-4.          YfromRGB(sRGB_to_d[in->r], sRGB_to_d[in->g], sRGB_to_d[in->b]));
-3.    out->a = 65535;
-2. }

 /*Lin: make gAMA 45455 components linear, alpha := 65535*/

1. static void
2. gpc_Lin(Pixel *out, const Pixel *in, const Background *back)
3. {
4.    (void)back;
5.    out->r = ilinear_g22(in->r);
6.    if (in->g == in->r)
7.    {
8.       out->g = out->r;
9.       if (in->b == in->r)
10.          out->b = out->r;",Useful
"/*Glin: make gAMA 45455 components linear, convert to grayscale, alpha := 65535*/","-10.          out->b = out->r;
-9.       else if (in->b == in->g)
-8.          out->b = out->g;
-7.       else
-6.          out->b = ilineara_g22(in->b, in->a);
-5.    }
-4.    out->a = 65535;
-3. }
-2. #endif
-1. #if ALLOW_UNUSED_GPC
/* Glin: make gAMA 45455 components linear, convert to grayscale, alpha := 65535

 /*Glin: make gAMA 45455 components linear, convert to grayscale, alpha := 65535*/

1.  */
2. static void
3. gpc_Glin(Pixel *out, const Pixel *in, const Background *back)
4. {
5.    (void)back;
6.    if (in->r == in->g && in->g == in->b)
7.       out->r = out->g = out->b = ilinear_g22(in->g);
8.    else
9.       out->r = out->g = out->b = u16d(65535 *
10.          YfromRGB(g22_to_d[in->r], g22_to_d[in->g], g22_to_d[in->b]));",Useful
"/*Gpre: make gAMA 45455 components grayscale and linear and premultiply by
 * alpha.*/","-10.    (void)back;
-9.    if (in->r == in->g && in->g == in->b)
-8.       out->r = out->g = out->b = ilinear_g22(in->g);
-7.    else
-6.       out->r = out->g = out->b = u16d(65535 *
-5.          YfromRGB(g22_to_d[in->r], g22_to_d[in->g], g22_to_d[in->b]));
-4.    out->a = 65535;
-3. }
-2. #endif
-1. #if ALLOW_UNUSED_GPC
/* Gpre: make gAMA 45455 components grayscale and linear and premultiply by
 * alpha.

 /*Gpre: make gAMA 45455 components grayscale and linear and premultiply by
 * alpha.*/

1.  */
2. static void
3. gpc_Gpre(Pixel *out, const Pixel *in, const Background *back)
4. {
5.    (void)back;
6.    if (in->r == in->g && in->g == in->b)
7.       out->r = out->g = out->b = ilineara_g22(in->g, in->a);
8.    else
9.       out->r = out->g = out->b = u16d(in->a * 257 *
10.          YfromRGB(g22_to_d[in->r], g22_to_d[in->g], g22_to_d[in->b]));",Useful
"/*sRGB: convert linear components to sRGB, alpha := 255*/","-10.  *
-9.  *  8-bit to 16-bit:
-8.  * lin:  make sRGB components linear, alpha := 65535
-7.  * pre:  make sRGB components linear and premultiply by alpha  (scale alpha)
-6.  * pre': as 'pre' but alpha := 65535
-5.  * glin: make sRGB components linear, convert to grayscale, alpha := 65535
-4.  * gpre: make sRGB components grayscale and linear and premultiply by alpha
-3.  * gpr': as 'gpre' but alpha := 65535
-2.  *
-1.  *  16-bit to 8-bit:
 * sRGB: convert linear components to sRGB, alpha := 255

 /*sRGB: convert linear components to sRGB, alpha := 255*/

1.  * unpg: unpremultiply gray component and convert to sRGB (scale alpha)
2.  * unpc: unpremultiply color components and convert to sRGB (scale alpha)
3.  * b16g: composite linear onto gray background and convert the result to sRGB
4.  * b16c: composite linear onto color background and convert the result to sRGB
5.  * sG:   convert linear RGB to sRGB grayscale
6.  * sGp:  unpremultiply RGB then convert to sRGB grayscale
7.  * sCp:  unpremultiply RGB then convert to sRGB
8.  * gb16: composite linear onto background and convert to sRGB grayscale
9.  *       (order doesn't matter, the composite and grayscale operations permute)
10.  * cb16: composite linear onto background and convert to sRGB",Useful
/*unpg: unpremultiply gray component and convert to sRGB (scale alpha)*/,"-10.  *  8-bit to 16-bit:
-9.  * lin:  make sRGB components linear, alpha := 65535
-8.  * pre:  make sRGB components linear and premultiply by alpha  (scale alpha)
-7.  * pre': as 'pre' but alpha := 65535
-6.  * glin: make sRGB components linear, convert to grayscale, alpha := 65535
-5.  * gpre: make sRGB components grayscale and linear and premultiply by alpha
-4.  * gpr': as 'gpre' but alpha := 65535
-3.  *
-2.  *  16-bit to 8-bit:
-1.  * sRGB: convert linear components to sRGB, alpha := 255
 * unpg: unpremultiply gray component and convert to sRGB (scale alpha)

 /*unpg: unpremultiply gray component and convert to sRGB (scale alpha)*/

1.  * unpc: unpremultiply color components and convert to sRGB (scale alpha)
2.  * b16g: composite linear onto gray background and convert the result to sRGB
3.  * b16c: composite linear onto color background and convert the result to sRGB
4.  * sG:   convert linear RGB to sRGB grayscale
5.  * sGp:  unpremultiply RGB then convert to sRGB grayscale
6.  * sCp:  unpremultiply RGB then convert to sRGB
7.  * gb16: composite linear onto background and convert to sRGB grayscale
8.  *       (order doesn't matter, the composite and grayscale operations permute)
9.  * cb16: composite linear onto background and convert to sRGB
10.  *",Useful
/*unpc: unpremultiply color components and convert to sRGB (scale alpha)*/,"-10.  * lin:  make sRGB components linear, alpha := 65535
-9.  * pre:  make sRGB components linear and premultiply by alpha  (scale alpha)
-8.  * pre': as 'pre' but alpha := 65535
-7.  * glin: make sRGB components linear, convert to grayscale, alpha := 65535
-6.  * gpre: make sRGB components grayscale and linear and premultiply by alpha
-5.  * gpr': as 'gpre' but alpha := 65535
-4.  *
-3.  *  16-bit to 8-bit:
-2.  * sRGB: convert linear components to sRGB, alpha := 255
-1.  * unpg: unpremultiply gray component and convert to sRGB (scale alpha)
 * unpc: unpremultiply color components and convert to sRGB (scale alpha)

 /*unpc: unpremultiply color components and convert to sRGB (scale alpha)*/

1.  * b16g: composite linear onto gray background and convert the result to sRGB
2.  * b16c: composite linear onto color background and convert the result to sRGB
3.  * sG:   convert linear RGB to sRGB grayscale
4.  * sGp:  unpremultiply RGB then convert to sRGB grayscale
5.  * sCp:  unpremultiply RGB then convert to sRGB
6.  * gb16: composite linear onto background and convert to sRGB grayscale
7.  *       (order doesn't matter, the composite and grayscale operations permute)
8.  * cb16: composite linear onto background and convert to sRGB
9.  *
10.  *  16-bit to 16-bit:",Useful
/*b16g: composite linear onto gray background and convert the result to sRGB*/,"-10.  * pre:  make sRGB components linear and premultiply by alpha  (scale alpha)
-9.  * pre': as 'pre' but alpha := 65535
-8.  * glin: make sRGB components linear, convert to grayscale, alpha := 65535
-7.  * gpre: make sRGB components grayscale and linear and premultiply by alpha
-6.  * gpr': as 'gpre' but alpha := 65535
-5.  *
-4.  *  16-bit to 8-bit:
-3.  * sRGB: convert linear components to sRGB, alpha := 255
-2.  * unpg: unpremultiply gray component and convert to sRGB (scale alpha)
-1.  * unpc: unpremultiply color components and convert to sRGB (scale alpha)
 * b16g: composite linear onto gray background and convert the result to sRGB

 /*b16g: composite linear onto gray background and convert the result to sRGB*/

1.  * b16c: composite linear onto color background and convert the result to sRGB
2.  * sG:   convert linear RGB to sRGB grayscale
3.  * sGp:  unpremultiply RGB then convert to sRGB grayscale
4.  * sCp:  unpremultiply RGB then convert to sRGB
5.  * gb16: composite linear onto background and convert to sRGB grayscale
6.  *       (order doesn't matter, the composite and grayscale operations permute)
7.  * cb16: composite linear onto background and convert to sRGB
8.  *
9.  *  16-bit to 16-bit:
10.  * A:    set alpha to 65535",Useful
/*b16c: composite linear onto color background and convert the result to sRGB*/,"-10.  * pre': as 'pre' but alpha := 65535
-9.  * glin: make sRGB components linear, convert to grayscale, alpha := 65535
-8.  * gpre: make sRGB components grayscale and linear and premultiply by alpha
-7.  * gpr': as 'gpre' but alpha := 65535
-6.  *
-5.  *  16-bit to 8-bit:
-4.  * sRGB: convert linear components to sRGB, alpha := 255
-3.  * unpg: unpremultiply gray component and convert to sRGB (scale alpha)
-2.  * unpc: unpremultiply color components and convert to sRGB (scale alpha)
-1.  * b16g: composite linear onto gray background and convert the result to sRGB
 * b16c: composite linear onto color background and convert the result to sRGB

 /*b16c: composite linear onto color background and convert the result to sRGB*/

1.  * sG:   convert linear RGB to sRGB grayscale
2.  * sGp:  unpremultiply RGB then convert to sRGB grayscale
3.  * sCp:  unpremultiply RGB then convert to sRGB
4.  * gb16: composite linear onto background and convert to sRGB grayscale
5.  *       (order doesn't matter, the composite and grayscale operations permute)
6.  * cb16: composite linear onto background and convert to sRGB
7.  *
8.  *  16-bit to 16-bit:
9.  * A:    set alpha to 65535
10.  * g16:  convert linear RGB to linear grayscale (alpha := 65535)",Useful
/*sG: convert linear RGB to sRGB grayscale*/,"-10.    {
-9.       double a = in->a/65535.;
-8.       double a1 = 1-a;
-7.       a /= 65535;
-6.       out->r = sRGB(in->r * a + back->dr * a1);
-5.       out->g = sRGB(in->g * a + back->dg * a1);
-4.       out->b = sRGB(in->b * a + back->db * a1);
-3.    }
-2.    out->a = 255;
-1. }

 /*sG: convert linear RGB to sRGB grayscale*/

1. static void
2. gpc_sG(Pixel *out, const Pixel *in, const Background *back)
3. {
4.    (void)back;
5.    out->r = out->g = out->b = sRGB(YfromRGBint(in->r, in->g, in->b)/65535);
6.    out->a = 255;
7. }",Useful
/*sGp: unpremultiply RGB then convert to sRGB grayscale*/,"-7. static void
-6. gpc_sG(Pixel *out, const Pixel *in, const Background *back)
-5. {
-4.    (void)back;
-3.    out->r = out->g = out->b = sRGB(YfromRGBint(in->r, in->g, in->b)/65535);
-2.    out->a = 255;
-1. }

 /*sGp: unpremultiply RGB then convert to sRGB grayscale*/

1. static void
2. gpc_sGp(Pixel *out, const Pixel *in, const Background *back)
3. {
4.    (void)back;
5.    if (in->a <= 128)
6.    {
7.       out->r = out->g = out->b = 255;
8.       out->a = 0;
9.    }
10.    else",Useful
/*gb16: composite linear onto background and convert to sRGB grayscale*/,"-10.  *
-9.  *  16-bit to 8-bit:
-8.  * sRGB: convert linear components to sRGB, alpha := 255
-7.  * unpg: unpremultiply gray component and convert to sRGB (scale alpha)
-6.  * unpc: unpremultiply color components and convert to sRGB (scale alpha)
-5.  * b16g: composite linear onto gray background and convert the result to sRGB
-4.  * b16c: composite linear onto color background and convert the result to sRGB
-3.  * sG:   convert linear RGB to sRGB grayscale
-2.  * sGp:  unpremultiply RGB then convert to sRGB grayscale
-1.  * sCp:  unpremultiply RGB then convert to sRGB
 * gb16: composite linear onto background and convert to sRGB grayscale

 /*gb16: composite linear onto background and convert to sRGB grayscale*/

1.  *       (order doesn't matter, the composite and grayscale operations permute)
2.  * cb16: composite linear onto background and convert to sRGB
3.  *
4.  *  16-bit to 16-bit:
5.  * A:    set alpha to 65535
6.  * g16:  convert linear RGB to linear grayscale (alpha := 65535)
7.  * g16': as 'g16' but alpha is unchanged
8.  */",Useful
"/*(order doesn't matter, the composite and grayscale operations permute)*/","-10.  *  16-bit to 8-bit:
-9.  * sRGB: convert linear components to sRGB, alpha := 255
-8.  * unpg: unpremultiply gray component and convert to sRGB (scale alpha)
-7.  * unpc: unpremultiply color components and convert to sRGB (scale alpha)
-6.  * b16g: composite linear onto gray background and convert the result to sRGB
-5.  * b16c: composite linear onto color background and convert the result to sRGB
-4.  * sG:   convert linear RGB to sRGB grayscale
-3.  * sGp:  unpremultiply RGB then convert to sRGB grayscale
-2.  * sCp:  unpremultiply RGB then convert to sRGB
-1.  * gb16: composite linear onto background and convert to sRGB grayscale
 *       (order doesn't matter, the composite and grayscale operations permute)

 /*(order doesn't matter, the composite and grayscale operations permute)*/

1.  * cb16: composite linear onto background and convert to sRGB
2.  *
3.  *  16-bit to 16-bit:
4.  * A:    set alpha to 65535
5.  * g16:  convert linear RGB to linear grayscale (alpha := 65535)
6.  * g16': as 'g16' but alpha is unchanged
7.  */",Useful
/*cb16: composite linear onto background and convert to sRGB*/,"-10.  * sRGB: convert linear components to sRGB, alpha := 255
-9.  * unpg: unpremultiply gray component and convert to sRGB (scale alpha)
-8.  * unpc: unpremultiply color components and convert to sRGB (scale alpha)
-7.  * b16g: composite linear onto gray background and convert the result to sRGB
-6.  * b16c: composite linear onto color background and convert the result to sRGB
-5.  * sG:   convert linear RGB to sRGB grayscale
-4.  * sGp:  unpremultiply RGB then convert to sRGB grayscale
-3.  * sCp:  unpremultiply RGB then convert to sRGB
-2.  * gb16: composite linear onto background and convert to sRGB grayscale
-1.  *       (order doesn't matter, the composite and grayscale operations permute)
 * cb16: composite linear onto background and convert to sRGB

 /*cb16: composite linear onto background and convert to sRGB*/

1.  *
2.  *  16-bit to 16-bit:
3.  * A:    set alpha to 65535
4.  * g16:  convert linear RGB to linear grayscale (alpha := 65535)
5.  * g16': as 'g16' but alpha is unchanged
6.  */",Useful
/*g16:  convert linear RGB to linear grayscale (alpha := 65535)*/,"-10.  * b16c: composite linear onto color background and convert the result to sRGB
-9.  * sG:   convert linear RGB to sRGB grayscale
-8.  * sGp:  unpremultiply RGB then convert to sRGB grayscale
-7.  * sCp:  unpremultiply RGB then convert to sRGB
-6.  * gb16: composite linear onto background and convert to sRGB grayscale
-5.  *       (order doesn't matter, the composite and grayscale operations permute)
-4.  * cb16: composite linear onto background and convert to sRGB
-3.  *
-2.  *  16-bit to 16-bit:
-1.  * A:    set alpha to 65535
 * g16:  convert linear RGB to linear grayscale (alpha := 65535)

 /*g16:  convert linear RGB to linear grayscale (alpha := 65535)*/

1.  * g16': as 'g16' but alpha is unchanged
2.  */",Useful
/*Unused functions (to hide them from GCC unused function warnings)*/,"-8. static void
-7. gpc_g16q(Pixel *out, const Pixel *in, const Background *back)
-6. {
-5.    (void)back;
-4.    out->r = out->g = out->b = u16d(YfromRGBint(in->r, in->g, in->b));
-3.    out->a = in->a;
-2. }
-1. #if ALLOW_UNUSED_GPC

 /*Unused functions (to hide them from GCC unused function warnings)*/

1. void (* const gpc_unused[])
2.    (Pixel *out, const Pixel *in, const Background *back) =
3. {
4.    gpc_Pre, gpc_Preq, gpc_Glin, gpc_Gpre, gpc_Gprq, gpc_nop8, gpc_nop6
5. };
6. #endif
7. /*   OUT:    ----- 8-bit -----    ----- 16-bit -----
8.  *   IN     G    GA   RGB  RGBA  G    GA   RGB  RGBA
9.  *  8 G     .    .    .    .     lin  lin  lin  lin
10.  *  8 GA    bckg .    bckc .     pre' pre  pre' pre",Useful
"/*OUT:    ----- 8-bit -----    ----- 16-bit -----
 *   IN     G    GA   RGB  RGBA  G    GA   RGB  RGBA
 *  8 G     .    .    .    .     lin  lin  lin  lin
 *  8 GA    bckg .    bckc .     pre' pre  pre' pre
 *  8 RGB   g8   g8   .    .     glin glin lin  lin
 *  8 RGBA  g8b  g8   bckc .     gpr' gpre pre' pre
 * 16 G     sRGB sRGB sRGB sRGB  .    .    .    .
 * 16 GA    b16g unpg b16c unpc  A    .    A    .
 * 16 RGB   sG   sG   sRGB sRGB  g16  g16  .    .
 * 16 RGBA  gb16 sGp  cb16 sCp   g16  g16' A    .
 *
 * The matrix is held in an array indexed thus:
 *
 *   gpc_fn[out_format & BASE_FORMATS][in_format & BASE_FORMATS];*/","-6. void (* const gpc_unused[])
-5.    (Pixel *out, const Pixel *in, const Background *back) =
-4. {
-3.    gpc_Pre, gpc_Preq, gpc_Glin, gpc_Gpre, gpc_Gprq, gpc_nop8, gpc_nop6
-2. };
-1. #endif
/*   OUT:    ----- 8-bit -----    ----- 16-bit -----
 *   IN     G    GA   RGB  RGBA  G    GA   RGB  RGBA
 *  8 G     .    .    .    .     lin  lin  lin  lin
 *  8 GA    bckg .    bckc .     pre' pre  pre' pre
 *  8 RGB   g8   g8   .    .     glin glin lin  lin
 *  8 RGBA  g8b  g8   bckc .     gpr' gpre pre' pre
 * 16 G     sRGB sRGB sRGB sRGB  .    .    .    .
 * 16 GA    b16g unpg b16c unpc  A    .    A    .
 * 16 RGB   sG   sG   sRGB sRGB  g16  g16  .    .
 * 16 RGBA  gb16 sGp  cb16 sCp   g16  g16' A    .
 *
 * The matrix is held in an array indexed thus:
 *
 *   gpc_fn[out_format & BASE_FORMATS][in_format & BASE_FORMATS];

 /*OUT:    ----- 8-bit -----    ----- 16-bit -----
 *   IN     G    GA   RGB  RGBA  G    GA   RGB  RGBA
 *  8 G     .    .    .    .     lin  lin  lin  lin
 *  8 GA    bckg .    bckc .     pre' pre  pre' pre
 *  8 RGB   g8   g8   .    .     glin glin lin  lin
 *  8 RGBA  g8b  g8   bckc .     gpr' gpre pre' pre
 * 16 G     sRGB sRGB sRGB sRGB  .    .    .    .
 * 16 GA    b16g unpg b16c unpc  A    .    A    .
 * 16 RGB   sG   sG   sRGB sRGB  g16  g16  .    .
 * 16 RGBA  gb16 sGp  cb16 sCp   g16  g16' A    .
 *
 * The matrix is held in an array indexed thus:
 *
 *   gpc_fn[out_format & BASE_FORMATS][in_format & BASE_FORMATS];*/

 ",Useful
"/*This will produce a compile time error if the FORMAT_FLAG values don't
 * match the above matrix!*/","-10.  *  8 RGBA  g8b  g8   bckc .     gpr' gpre pre' pre
-9.  * 16 G     sRGB sRGB sRGB sRGB  .    .    .    .
-8.  * 16 GA    b16g unpg b16c unpc  A    .    A    .
-7.  * 16 RGB   sG   sG   sRGB sRGB  g16  g16  .    .
-6.  * 16 RGBA  gb16 sGp  cb16 sCp   g16  g16' A    .
-5.  *
-4.  * The matrix is held in an array indexed thus:
-3.  *
-2.  *   gpc_fn[out_format & BASE_FORMATS][in_format & BASE_FORMATS];
-1.  */
/* This will produce a compile time error if the FORMAT_FLAG values don't
 * match the above matrix!

 /*This will produce a compile time error if the FORMAT_FLAG values don't
 * match the above matrix!*/

 ",Useful
"/*The array is repeated for the cases where both the input and output are color
 * mapped because then different algorithms are used.*/","-9.    {gpc_noop,gpc_noop,gpc_noop,gpc_noop, gpc_Lin, gpc_Lin, gpc_Lin, gpc_Lin },
-8.    {gpc_bckg,gpc_noop,gpc_bckc,gpc_noop, gpc_preq,gpc_pre, gpc_preq,gpc_pre },
-7.    {gpc_g8,  gpc_g8,  gpc_noop,gpc_noop, gpc_glin,gpc_glin,gpc_lin, gpc_lin },
-6.    {gpc_g8b, gpc_g8,  gpc_bckc,gpc_noop, gpc_gprq,gpc_gpre,gpc_preq,gpc_pre },
-5.    {gpc_sRGB,gpc_sRGB,gpc_sRGB,gpc_sRGB, gpc_noop,gpc_noop,gpc_noop,gpc_noop},
-4.    {gpc_b16g,gpc_unpg,gpc_b16c,gpc_unpc, gpc_A,   gpc_noop,gpc_A,   gpc_noop},
-3.    {gpc_sG,  gpc_sG,  gpc_sRGB,gpc_sRGB, gpc_g16, gpc_g16, gpc_noop,gpc_noop},
-2.    {gpc_gb16,gpc_sGp, gpc_cb16,gpc_sCp,  gpc_g16, gpc_g16q,gpc_A,   gpc_noop}
-1. };
/* The array is repeated for the cases where both the input and output are color
 * mapped because then different algorithms are used.

 /*The array is repeated for the cases where both the input and output are color
 * mapped because then different algorithms are used.*/

 ",Useful
"/*The error arrays record the error in the same matrix; 64 entries, however
 * the different algorithms used in libpng for colormap and direct conversions
 * mean that four separate matrices are used (for each combination of
 * colormapped and direct.)
 *
 * In some cases the conversion between sRGB formats goes via a linear
 * intermediate; an sRGB to linear conversion (as above) is followed by a simple
 * linear to sRGB step with no other conversions.  This is done by a separate
 * error array from an arbitrary 'in' format to one of the four basic outputs
 * (since final output is always sRGB not colormapped).
 *
 * These arrays may be modified if the --accumulate flag is set during the run;
 * then instead of logging errors they are simply added in.
 *
 * The three entries are currently for transparent, partially transparent and
 * opaque input pixel values.  Notice that alpha should be exact in each case.
 *
 * Errors in alpha should only occur when converting from a direct format
 * to a colormapped format, when alpha is effectively smashed (so large
 * errors can occur.)  There should be no error in the '0' and 'opaque'
 * values.  The fourth entry in the array is used for the alpha error (and it
 * should always be zero for the 'via linear' case since this is never color
 * mapped.)
 *
 * Mapping to a colormap smashes the colors, it is necessary to have separate
 * values for these cases because they are much larger; it is very much
 * impossible to obtain a reasonable result, these are held in
 * gpc_error_to_colormap.*/","-10. /*out: G-8     GA-8     RGB-8    RGBA-8    G-16     GA-16   RGB-16  RGBA-16 */
-9.    {gpc_noop,gpc_noop,gpc_noop,gpc_noop, gpc_lin, gpc_lin, gpc_lin, gpc_lin },
-8.    {gpc_bckg,gpc_noop,gpc_bckc,gpc_noop, gpc_preq,gpc_pre, gpc_preq,gpc_pre },
-7.    {gpc_g8,  gpc_g8,  gpc_noop,gpc_noop, gpc_glin,gpc_glin,gpc_lin, gpc_lin },
-6.    {gpc_g8b, gpc_g8,  gpc_bckc,gpc_noop, gpc_gprq,gpc_gpre,gpc_preq,gpc_pre },
-5.    {gpc_sRGB,gpc_sRGB,gpc_sRGB,gpc_sRGB, gpc_noop,gpc_noop,gpc_noop,gpc_noop},
-4.    {gpc_b16g,gpc_unpg,gpc_b16c,gpc_unpc, gpc_A,   gpc_noop,gpc_A,   gpc_noop},
-3.    {gpc_sG,  gpc_sG,  gpc_sRGB,gpc_sRGB, gpc_g16, gpc_g16, gpc_noop,gpc_noop},
-2.    {gpc_gb16,gpc_sGp, gpc_cb16,gpc_sCp,  gpc_g16, gpc_g16q,gpc_A,   gpc_noop}
-1. };
/* The error arrays record the error in the same matrix; 64 entries, however
 * the different algorithms used in libpng for colormap and direct conversions
 * mean that four separate matrices are used (for each combination of
 * colormapped and direct.)
 *
 * In some cases the conversion between sRGB formats goes via a linear
 * intermediate; an sRGB to linear conversion (as above) is followed by a simple
 * linear to sRGB step with no other conversions.  This is done by a separate
 * error array from an arbitrary 'in' format to one of the four basic outputs
 * (since final output is always sRGB not colormapped).
 *
 * These arrays may be modified if the --accumulate flag is set during the run;
 * then instead of logging errors they are simply added in.
 *
 * The three entries are currently for transparent, partially transparent and
 * opaque input pixel values.  Notice that alpha should be exact in each case.
 *
 * Errors in alpha should only occur when converting from a direct format
 * to a colormapped format, when alpha is effectively smashed (so large
 * errors can occur.)  There should be no error in the '0' and 'opaque'
 * values.  The fourth entry in the array is used for the alpha error (and it
 * should always be zero for the 'via linear' case since this is never color
 * mapped.)
 *
 * Mapping to a colormap smashes the colors, it is necessary to have separate
 * values for these cases because they are much larger; it is very much
 * impossible to obtain a reasonable result, these are held in
 * gpc_error_to_colormap.

 /*The error arrays record the error in the same matrix; 64 entries, however
 * the different algorithms used in libpng for colormap and direct conversions
 * mean that four separate matrices are used (for each combination of
 * colormapped and direct.)
 *
 * In some cases the conversion between sRGB formats goes via a linear
 * intermediate; an sRGB to linear conversion (as above) is followed by a simple
 * linear to sRGB step with no other conversions.  This is done by a separate
 * error array from an arbitrary 'in' format to one of the four basic outputs
 * (since final output is always sRGB not colormapped).
 *
 * These arrays may be modified if the --accumulate flag is set during the run;
 * then instead of logging errors they are simply added in.
 *
 * The three entries are currently for transparent, partially transparent and
 * opaque input pixel values.  Notice that alpha should be exact in each case.
 *
 * Errors in alpha should only occur when converting from a direct format
 * to a colormapped format, when alpha is effectively smashed (so large
 * errors can occur.)  There should be no error in the '0' and 'opaque'
 * values.  The fourth entry in the array is used for the alpha error (and it
 * should always be zero for the 'via linear' case since this is never color
 * mapped.)
 *
 * Mapping to a colormap smashes the colors, it is necessary to have separate
 * values for these cases because they are much larger; it is very much
 * impossible to obtain a reasonable result, these are held in
 * gpc_error_to_colormap.*/

 ",Useful
"/*background' is the value passed to the gpc_ routines, it may be NULL if
    * it should not be used (*this* program has an error if it crashes as a
    * result!)*/","-5. typedef struct
-4. {

 /*background' is the value passed to the gpc_ routines, it may be NULL if
    * it should not be used (*this* program has an error if it crashes as a
    * result!)*/

1.     */
2.    Background        background_color;
3.    const Background* background;",Useful
"/*For 'via_linear' transforms the final, from linear, step, else NULL*/","-1.    void (*from_linear)(Pixel *out, const Pixel *in, const Background *back);

 /*For 'via_linear' transforms the final, from linear, step, else NULL*/

1.    png_uint_16 error[4];",Useful
"/*Three error values for transparent, partially transparent and opaque
       * input pixels (in turn).*/","-1.    png_uint_16 error[4];
      /* Three error values for transparent, partially transparent and opaque
       * input pixels (in turn).

 /*Three error values for transparent, partially transparent and opaque
       * input pixels (in turn).*/

1.        */
2.    png_uint_16 *error_ptr;",Useful
/*Where these are stored in the static array (for 'accumulate')*/,"-1.    png_uint_16 *error_ptr;

 /*Where these are stored in the static array (for 'accumulate')*/

1. }
2. Transform;",Useful
/*Return a 'transform' as above for the given format conversion.*/,"-2. }
-1. Transform;

 /*Return a 'transform' as above for the given format conversion.*/

1. static void
2. transform_from_formats(Transform *result, Image *in_image,
3.    const Image *out_image, png_const_colorp background, int via_linear)
4. {
5.    png_uint_32 in_format, out_format;
6.    png_uint_32 in_base, out_base;
7.    memset(result, 0, sizeof *result);",Useful
/*Store the original images for error messages*/,"-7. static void
-6. transform_from_formats(Transform *result, Image *in_image,
-5.    const Image *out_image, png_const_colorp background, int via_linear)
-4. {
-3.    png_uint_32 in_format, out_format;
-2.    png_uint_32 in_base, out_base;
-1.    memset(result, 0, sizeof *result);

 /*Store the original images for error messages*/

1.    result->in_image = in_image;
2.    result->out_image = out_image;
3.    in_format = in_image->image.format;
4.    out_format = out_image->image.format;
5.    if (in_format & PNG_FORMAT_FLAG_LINEAR)
6.       result->in_opaque = 65535;
7.    else
8.       result->in_opaque = 255;
9.    result->output_8bit = (out_format & PNG_FORMAT_FLAG_LINEAR) == 0;",Useful
/*set by caller if required*/,"-9.    result->in_image = in_image;
-8.    result->out_image = out_image;
-7.    in_format = in_image->image.format;
-6.    out_format = out_image->image.format;
-5.    if (in_format & PNG_FORMAT_FLAG_LINEAR)
-4.       result->in_opaque = 65535;
-3.    else
-2.       result->in_opaque = 255;
-1.    result->output_8bit = (out_format & PNG_FORMAT_FLAG_LINEAR) == 0;

 /*set by caller if required*/

1.    result->accumulate = (in_image->opts & ACCUMULATE) != 0;",Useful
/*Check for an error in this program:*/,"-6.    in_format &= BASE_FORMATS | PNG_FORMAT_FLAG_COLORMAP;
-5.    in_base = in_format & BASE_FORMATS;
-4.    out_format &= BASE_FORMATS | PNG_FORMAT_FLAG_COLORMAP;
-3.    out_base = out_format & BASE_FORMATS;
-2.    if (via_linear)
-1.    {

 /*Check for an error in this program:*/

1.       if (out_format & (PNG_FORMAT_FLAG_LINEAR|PNG_FORMAT_FLAG_COLORMAP))
2.       {
3.          fprintf(stderr, ""internal transform via linear error 0x%x->0x%x\n"",
4.             in_format, out_format);
5.          exit(1);
6.       }
7.       result->transform = gpc_fn[in_base][out_base | PNG_FORMAT_FLAG_LINEAR];
8.       result->from_linear = gpc_fn[out_base | PNG_FORMAT_FLAG_LINEAR][out_base];
9.       result->error_ptr = gpc_error_via_linear[in_format][out_format];
10.    }",Useful
"/*The input is not colormapped but the output is, the errors will
       * typically be large (only the grayscale-no-alpha case permits preserving
       * even 8-bit values.)*/","-10.          fprintf(stderr, ""internal transform via linear error 0x%x->0x%x\n"",
-9.             in_format, out_format);
-8.          exit(1);
-7.       }
-6.       result->transform = gpc_fn[in_base][out_base | PNG_FORMAT_FLAG_LINEAR];
-5.       result->from_linear = gpc_fn[out_base | PNG_FORMAT_FLAG_LINEAR][out_base];
-4.       result->error_ptr = gpc_error_via_linear[in_format][out_format];
-3.    }
-2.    else if (~in_format & out_format & PNG_FORMAT_FLAG_COLORMAP)
-1.    {
      /* The input is not colormapped but the output is, the errors will
       * typically be large (only the grayscale-no-alpha case permits preserving
       * even 8-bit values.)

 /*The input is not colormapped but the output is, the errors will
       * typically be large (only the grayscale-no-alpha case permits preserving
       * even 8-bit values.)*/

1.        */
2.       result->transform = gpc_fn[in_base][out_base];
3.       result->from_linear = NULL;
4.       result->error_ptr = gpc_error_to_colormap[in_base][out_base];
5.    }
6.    else
7.    {
8.       /* The caller handles the colormap->pixel value conversion, so the
9.        * transform function just gets a pixel value, however because libpng
10.        * currently contains a different implementation for mapping a colormap if",Useful
"/*The caller handles the colormap->pixel value conversion, so the
       * transform function just gets a pixel value, however because libpng
       * currently contains a different implementation for mapping a colormap if
       * both input and output are colormapped we need different conversion
       * functions to deal with errors in the libpng implementation.*/","-6.       result->transform = gpc_fn[in_base][out_base];
-5.       result->from_linear = NULL;
-4.       result->error_ptr = gpc_error_to_colormap[in_base][out_base];
-3.    }
-2.    else
-1.    {
      /* The caller handles the colormap->pixel value conversion, so the
       * transform function just gets a pixel value, however because libpng
       * currently contains a different implementation for mapping a colormap if
       * both input and output are colormapped we need different conversion
       * functions to deal with errors in the libpng implementation.

 /*The caller handles the colormap->pixel value conversion, so the
       * transform function just gets a pixel value, however because libpng
       * currently contains a different implementation for mapping a colormap if
       * both input and output are colormapped we need different conversion
       * functions to deal with errors in the libpng implementation.*/

1.        */
2.       if (in_format & out_format & PNG_FORMAT_FLAG_COLORMAP)
3.          result->transform = gpc_fn_colormapped[in_base][out_base];
4.       else
5.          result->transform = gpc_fn[in_base][out_base];
6.       result->from_linear = NULL;
7.       result->error_ptr = gpc_error[in_format][out_format];
8.    }
9.    /* Follow the libpng simplified API rules to work out what to pass to the gpc
10.     * routines as a background value, if one is not required pass NULL so that",Useful
"/*Follow the libpng simplified API rules to work out what to pass to the gpc
    * routines as a background value, if one is not required pass NULL so that
    * this program crashes in the even of a programming error.*/","-10.        * both input and output are colormapped we need different conversion
-9.        * functions to deal with errors in the libpng implementation.
-8.        */
-7.       if (in_format & out_format & PNG_FORMAT_FLAG_COLORMAP)
-6.          result->transform = gpc_fn_colormapped[in_base][out_base];
-5.       else
-4.          result->transform = gpc_fn[in_base][out_base];
-3.       result->from_linear = NULL;
-2.       result->error_ptr = gpc_error[in_format][out_format];
-1.    }
   /* Follow the libpng simplified API rules to work out what to pass to the gpc
    * routines as a background value, if one is not required pass NULL so that
    * this program crashes in the even of a programming error.

 /*Follow the libpng simplified API rules to work out what to pass to the gpc
    * routines as a background value, if one is not required pass NULL so that
    * this program crashes in the even of a programming error.*/

1.     */",Useful
/*default: not required*/,"-10.          result->transform = gpc_fn_colormapped[in_base][out_base];
-9.       else
-8.          result->transform = gpc_fn[in_base][out_base];
-7.       result->from_linear = NULL;
-6.       result->error_ptr = gpc_error[in_format][out_format];
-5.    }

 /*default: not required*/

 ",Useful
/*Rule 1: background only need be supplied if alpha is to be removed*/,"-10.       else
-9.          result->transform = gpc_fn[in_base][out_base];
-8.       result->from_linear = NULL;
-7.       result->error_ptr = gpc_error[in_format][out_format];
-6.    }

 /*Rule 1: background only need be supplied if alpha is to be removed*/

1.    if (in_format & ~out_format & PNG_FORMAT_FLAG_ALPHA)
2.    {",Useful
"/*The input value is 'NULL' to use the background and (otherwise) an sRGB
       * background color (to use a solid color).  The code above uses a fixed
       * byte value, BUFFER_INIT8, for buffer even for 16-bit output.  For
       * linear (16-bit) output the sRGB background color is ignored; the
       * composition is always on the background (so BUFFER_INIT8 * 257), except
       * that for the colormap (i.e. linear colormapped output) black is used.*/","-2.    if (in_format & ~out_format & PNG_FORMAT_FLAG_ALPHA)
-1.    {
      /* The input value is 'NULL' to use the background and (otherwise) an sRGB
       * background color (to use a solid color).  The code above uses a fixed
       * byte value, BUFFER_INIT8, for buffer even for 16-bit output.  For
       * linear (16-bit) output the sRGB background color is ignored; the
       * composition is always on the background (so BUFFER_INIT8 * 257), except
       * that for the colormap (i.e. linear colormapped output) black is used.

 /*The input value is 'NULL' to use the background and (otherwise) an sRGB
       * background color (to use a solid color).  The code above uses a fixed
       * byte value, BUFFER_INIT8, for buffer even for 16-bit output.  For
       * linear (16-bit) output the sRGB background color is ignored; the
       * composition is always on the background (so BUFFER_INIT8 * 257), except
       * that for the colormap (i.e. linear colormapped output) black is used.*/

1.        */
2.       result->background = &result->background_color;
3.       if (out_format & PNG_FORMAT_FLAG_LINEAR || via_linear)
4.       {
5.          if (out_format & PNG_FORMAT_FLAG_COLORMAP)
6.          {
7.             result->background_color.ir =
8.                result->background_color.ig =
9.                result->background_color.ib = 0;
10.             result->background_color.dr =",Useful
/*grayscale: libpng only looks at 'g'*/,"-4.                result->background_color.dr = sRGB_to_d[background->red];
-3.                result->background_color.dg = sRGB_to_d[background->green];
-2.                result->background_color.db = sRGB_to_d[background->blue];
-1.             }

 /*grayscale: libpng only looks at 'g'*/

1.             {
2.                result->background_color.ir =
3.                   result->background_color.ig =
4.                   result->background_color.ib = background->green;",Useful
"/*Else the output is colormapped and a background color must be
          * provided; if pngstest crashes then that is a bug in this program
          * (though libpng should png_error as well.)*/","-4.             result->background_color.dr =
-3.                result->background_color.dg =
-2.                result->background_color.db = sRGB_to_d[BUFFER_INIT8];
-1.          }
         /* Else the output is colormapped and a background color must be
          * provided; if pngstest crashes then that is a bug in this program
          * (though libpng should png_error as well.)

 /*Else the output is colormapped and a background color must be
          * provided; if pngstest crashes then that is a bug in this program
          * (though libpng should png_error as well.)*/

1.           */
2.          else
3.             result->background = NULL;
4.       }
5.    }
6.    if (result->background == NULL)
7.    {
8.       result->background_color.ir =
9.          result->background_color.ig =",Useful
"/*Compare two pixels.
 *
 * OLD error values:
static int error_to_linear = 811; * by experiment *
static int error_to_linear_grayscale = 424; * by experiment *
static int error_to_sRGB = 6; * by experiment *
static int error_to_sRGB_grayscale = 17; * libpng error by calculation +
                                            2 by experiment *
static int error_in_compose = 2; * by experiment *
static int error_in_premultiply = 1;
 *
 * The following is *just* the result of a round trip from 8-bit sRGB to linear
 * then back to 8-bit sRGB when it is done by libpng.  There are two problems:
 *
 * 1) libpng currently uses a 2.2 power law with no linear segment, this results
 * in instability in the low values and even with 16-bit precision sRGB(1) ends
 * up mapping to sRGB(0) as a result of rounding in the 16-bit representation.
 * This gives an error of 1 in the handling of value 1 only.
 *
 * 2) libpng currently uses an intermediate 8-bit linear value in gamma
 * correction of 8-bit values.  This results in many more errors, the worse of
 * which is mapping sRGB(14) to sRGB(0).
 *
 * The general 'error_via_linear' is more complex because of pre-multiplication,
 * this compounds the 8-bit errors according to the alpha value of the pixel.
 * As a result 256 values are pre-calculated for error_via_linear.*/","-10.       result->background_color.dr =
-9.          result->background_color.dg =
-8.          result->background_color.db = 1E30; /* not used */
-7.    }
-6.    /* Copy the error values into the Transform: */
-5.    result->error[0] = result->error_ptr[0];
-4.    result->error[1] = result->error_ptr[1];
-3.    result->error[2] = result->error_ptr[2];
-2.    result->error[3] = result->error_ptr[3];
-1. }
/* Compare two pixels.
 *
 * OLD error values:
static int error_to_linear = 811; * by experiment *
static int error_to_linear_grayscale = 424; * by experiment *
static int error_to_sRGB = 6; * by experiment *
static int error_to_sRGB_grayscale = 17; * libpng error by calculation +
                                            2 by experiment *
static int error_in_compose = 2; * by experiment *
static int error_in_premultiply = 1;
 *
 * The following is *just* the result of a round trip from 8-bit sRGB to linear
 * then back to 8-bit sRGB when it is done by libpng.  There are two problems:
 *
 * 1) libpng currently uses a 2.2 power law with no linear segment, this results
 * in instability in the low values and even with 16-bit precision sRGB(1) ends
 * up mapping to sRGB(0) as a result of rounding in the 16-bit representation.
 * This gives an error of 1 in the handling of value 1 only.
 *
 * 2) libpng currently uses an intermediate 8-bit linear value in gamma
 * correction of 8-bit values.  This results in many more errors, the worse of
 * which is mapping sRGB(14) to sRGB(0).
 *
 * The general 'error_via_linear' is more complex because of pre-multiplication,
 * this compounds the 8-bit errors according to the alpha value of the pixel.
 * As a result 256 values are pre-calculated for error_via_linear.

 /*Compare two pixels.
 *
 * OLD error values:
static int error_to_linear = 811; * by experiment *
static int error_to_linear_grayscale = 424; * by experiment *
static int error_to_sRGB = 6; * by experiment *
static int error_to_sRGB_grayscale = 17; * libpng error by calculation +
                                            2 by experiment *
static int error_in_compose = 2; * by experiment *
static int error_in_premultiply = 1;
 *
 * The following is *just* the result of a round trip from 8-bit sRGB to linear
 * then back to 8-bit sRGB when it is done by libpng.  There are two problems:
 *
 * 1) libpng currently uses a 2.2 power law with no linear segment, this results
 * in instability in the low values and even with 16-bit precision sRGB(1) ends
 * up mapping to sRGB(0) as a result of rounding in the 16-bit representation.
 * This gives an error of 1 in the handling of value 1 only.
 *
 * 2) libpng currently uses an intermediate 8-bit linear value in gamma
 * correction of 8-bit values.  This results in many more errors, the worse of
 * which is mapping sRGB(14) to sRGB(0).
 *
 * The general 'error_via_linear' is more complex because of pre-multiplication,
 * this compounds the 8-bit errors according to the alpha value of the pixel.
 * As a result 256 values are pre-calculated for error_via_linear.*/

 ",Useful
/*transparent pixel*/,"-6.    int         r, g, b, a;
-5. } Pixel;
-4. typedef struct
-3. {
-2.    /* The background as the original sRGB 8-bit value converted to the final
-1.     * integer format and as a double precision linear value in the range 0..1
    * for with partially transparent pixels.

 /*transparent pixel*/

1.     */
2.    int ir, ig, ib;",Useful
"/*16-bit values less than 128.5 get rounded to 8-bit 0 and so the worst
       * case error arises with 16-bit 128.5, work out what sRGB
       * (non-associated) value generates 128.5; any value less than this is
       * going to map to 0, so the worst error is floor(value).
       *
       * Note that errors are considerably higher (more than a factor of 2)
       * because libpng uses a simple power law for sRGB data at present.
       *
       * Add .1 for arithmetic errors inside libpng.*/","-2.    for (alpha=1; alpha<=255; ++alpha)
-1.    {
      /* 16-bit values less than 128.5 get rounded to 8-bit 0 and so the worst
       * case error arises with 16-bit 128.5, work out what sRGB
       * (non-associated) value generates 128.5; any value less than this is
       * going to map to 0, so the worst error is floor(value).
       *
       * Note that errors are considerably higher (more than a factor of 2)
       * because libpng uses a simple power law for sRGB data at present.
       *
       * Add .1 for arithmetic errors inside libpng.

 /*16-bit values less than 128.5 get rounded to 8-bit 0 and so the worst
       * case error arises with 16-bit 128.5, work out what sRGB
       * (non-associated) value generates 128.5; any value less than this is
       * going to map to 0, so the worst error is floor(value).
       *
       * Note that errors are considerably higher (more than a factor of 2)
       * because libpng uses a simple power law for sRGB data at present.
       *
       * Add .1 for arithmetic errors inside libpng.*/

1.        */",Useful
"/*And as a result the *read* format which did any background processing
       * was itself linear, so the background color information is also
       * linear.*/","-10.    print_pixel(pixel_in, in, in_format);
-9.    print_pixel(pixel_calc, calc, out_format);
-8.    print_pixel(pixel_out, out, out_format);
-7.    if (transform->is_palette)
-6.       sprintf(pixel_loc, ""palette: %lu"", (unsigned long)y);
-5.    else
-4.       sprintf(pixel_loc, ""%lu,%lu"", (unsigned long)x, (unsigned long)y);
-3.    if (transform->from_linear != NULL)
-2.    {
-1.       via_linear = "" (via linear)"";
      /* And as a result the *read* format which did any background processing
       * was itself linear, so the background color information is also
       * linear.

 /*And as a result the *read* format which did any background processing
       * was itself linear, so the background color information is also
       * linear.*/

1.        */
2.       back_format |= PNG_FORMAT_FLAG_LINEAR;
3.    }
4.    if (transform->background != NULL)
5.    {
6.       Pixel back;
7.       char pixel_back[64];
8.       back.r = transform->background->ir;
9.       back.g = transform->background->ig;
10.       back.b = transform->background->ib;",Useful
/*Eliminate the case where the input and output values match exactly.*/,"-10.    Pixel pixel_in, pixel_calc, pixel_out;
-9.    transform->in_gp(&pixel_in, in);
-8.    if (transform->from_linear == NULL)
-7.       transform->transform(&pixel_calc, &pixel_in, transform->background);
-6.    else
-5.    {
-4.       transform->transform(&pixel_out, &pixel_in, transform->background);
-3.       transform->from_linear(&pixel_calc, &pixel_out, NULL);
-2.    }
-1.    transform->out_gp(&pixel_out, out);

 /*Eliminate the case where the input and output values match exactly.*/

1.    if (pixel_calc.a == pixel_out.a && pixel_calc.r == pixel_out.r &&
2.       pixel_calc.g == pixel_out.g && pixel_calc.b == pixel_out.b)
3.       return 1;",Useful
"/*Eliminate the case where the output pixel is transparent and the output
    * is 8-bit - any component values are valid.  Don't check the input alpha
    * here to also skip the 16-bit small alpha cases.*/","-3.    if (pixel_calc.a == pixel_out.a && pixel_calc.r == pixel_out.r &&
-2.       pixel_calc.g == pixel_out.g && pixel_calc.b == pixel_out.b)
-1.       return 1;
   /* Eliminate the case where the output pixel is transparent and the output
    * is 8-bit - any component values are valid.  Don't check the input alpha
    * here to also skip the 16-bit small alpha cases.

 /*Eliminate the case where the output pixel is transparent and the output
    * is 8-bit - any component values are valid.  Don't check the input alpha
    * here to also skip the 16-bit small alpha cases.*/

1.     */
2.    if (transform->output_8bit && pixel_calc.a == 0 && pixel_out.a == 0)
3.       return 1;",Useful
"/*Check for alpha errors first; an alpha error can damage the components too
    * so avoid spurious checks on components if one is found.*/","-2.    if (transform->output_8bit && pixel_calc.a == 0 && pixel_out.a == 0)
-1.       return 1;
   /* Check for alpha errors first; an alpha error can damage the components too
    * so avoid spurious checks on components if one is found.

 /*Check for alpha errors first; an alpha error can damage the components too
    * so avoid spurious checks on components if one is found.*/

1.     */
2.    errmsg = NULL;
3.    {
4.       int err_a = abs(pixel_calc.a-pixel_out.a);
5.       if (err_a > transform->error[3])
6.       {",Useful
"/*Now if *either* of the output alphas are 0 but alpha is within tolerance
    * eliminate the 8-bit component comparison.*/","-6.          if (transform->accumulate)
-5.             transform->error[3] = (png_uint_16)err_a;
-4.          else
-3.             errmsg = ""alpha"";
-2.       }
-1.    }
   /* Now if *either* of the output alphas are 0 but alpha is within tolerance
    * eliminate the 8-bit component comparison.

 /*Now if *either* of the output alphas are 0 but alpha is within tolerance
    * eliminate the 8-bit component comparison.*/

1.     */
2.    if (errmsg == NULL && transform->output_8bit &&
3.       (pixel_calc.a == 0 || pixel_out.a == 0))
4.       return 1;",Useful
/*else just signal an alpha error*/,"-3.    if (errmsg == NULL && transform->output_8bit &&
-2.       (pixel_calc.a == 0 || pixel_out.a == 0))
-1.       return 1;

 /*else just signal an alpha error*/

1.    {
2.       int err_r = abs(pixel_calc.r - pixel_out.r);
3.       int err_g = abs(pixel_calc.g - pixel_out.g);
4.       int err_b = abs(pixel_calc.b - pixel_out.b);
5.       int limit;
6.       if ((err_r | err_g | err_b) == 0)",Useful
"/*Handle a component mis-match; log it, just return an error code, or
       * accumulate it.*/","
      /* Handle a component mis-match; log it, just return an error code, or
       * accumulate it.



 /*Handle a component mis-match; log it, just return an error code, or
       * accumulate it.*/

1.        */
2.       if (transform->accumulate)
3.       {
4.          transform->error[limit] = (png_uint_16)maxerr;",Useful
"/*Failure to match and not accumulating, so the error must be logged.*/","-2.       }
-1.    }

 /*Failure to match and not accumulating, so the error must be logged.*/

1.    return logpixel(transform, x, y, &pixel_in, &pixel_calc, &pixel_out, errmsg);
2. }
3. static png_byte
4. component_loc(png_byte loc[4], png_uint_32 format)
5. {
6.    /* Given a format return the number of channels and the location of
7.     * each channel.
8.     *
9.     * The mask 'loc' contains the component offset of the channels in the
10.     * following order.  Note that if 'format' is grayscale the entries 1-3 must",Useful
"/*Given a format return the number of channels and the location of
    * each channel.
    *
    * The mask 'loc' contains the component offset of the channels in the
    * following order.  Note that if 'format' is grayscale the entries 1-3 must
    * all contain the location of the gray channel.
    *
    * 0: alpha
    * 1: red or gray
    * 2: green or gray
    * 3: blue or gray*/","-5.    return logpixel(transform, x, y, &pixel_in, &pixel_calc, &pixel_out, errmsg);
-4. }
-3. static png_byte
-2. component_loc(png_byte loc[4], png_uint_32 format)
-1. {
   /* Given a format return the number of channels and the location of
    * each channel.
    *
    * The mask 'loc' contains the component offset of the channels in the
    * following order.  Note that if 'format' is grayscale the entries 1-3 must
    * all contain the location of the gray channel.
    *
    * 0: alpha
    * 1: red or gray
    * 2: green or gray
    * 3: blue or gray

 /*Given a format return the number of channels and the location of
    * each channel.
    *
    * The mask 'loc' contains the component offset of the channels in the
    * following order.  Note that if 'format' is grayscale the entries 1-3 must
    * all contain the location of the gray channel.
    *
    * 0: alpha
    * 1: red or gray
    * 2: green or gray
    * 3: blue or gray*/

1.     */
2.    png_byte channels;
3.    if (format & PNG_FORMAT_FLAG_COLOR)
4.    {
5.       channels = 3;
6.       loc[2] = 1;
7. #     ifdef PNG_FORMAT_BGR_SUPPORTED
8.          if (format & PNG_FORMAT_FLAG_BGR)
9.          {
10.             loc[1] = 2;",Useful
"/*Compare two images, the original 'a', which was written out then read back in
 * to * give image 'b'.  The formats may have been changed.*/","-2.    return channels;
-1. }
/* Compare two images, the original 'a', which was written out then read back in
 * to * give image 'b'.  The formats may have been changed.

 /*Compare two images, the original 'a', which was written out then read back in
 * to * give image 'b'.  The formats may have been changed.*/

1.  */
2. static int
3. compare_two_images(Image *a, Image *b, int via_linear,
4.    png_const_colorp background)
5. {
6.    ptrdiff_t stridea = a->stride;
7.    ptrdiff_t strideb = b->stride;
8.    png_const_bytep rowa = a->buffer+16;
9.    png_const_bytep rowb = b->buffer+16;
10.    const png_uint_32 width = a->image.width;",Useful
/*Find the first row and inter-row space.*/,"-1.    transform_from_formats(&tr, a, b, background, via_linear);

 /*Find the first row and inter-row space.*/

1.    if (!(formata & PNG_FORMAT_FLAG_COLORMAP) &&
2.       (formata & PNG_FORMAT_FLAG_LINEAR))
3.       stridea *= 2;
4.    if (!(formatb & PNG_FORMAT_FLAG_COLORMAP) &&
5.       (formatb & PNG_FORMAT_FLAG_LINEAR))
6.       strideb *= 2;
7.    if (stridea < 0) rowa += (height-1) * (-stridea);
8.    if (strideb < 0) rowb += (height-1) * (-strideb);
9.    /* First shortcut the two colormap case by comparing the image data; if it
10.     * matches then we expect the colormaps to match, although this is not",Useful
"/*First shortcut the two colormap case by comparing the image data; if it
    * matches then we expect the colormaps to match, although this is not
    * absolutely necessary for an image match.  If the colormaps fail to match
    * then there is a problem in libpng.*/","-8.    if (!(formata & PNG_FORMAT_FLAG_COLORMAP) &&
-7.       (formata & PNG_FORMAT_FLAG_LINEAR))
-6.       stridea *= 2;
-5.    if (!(formatb & PNG_FORMAT_FLAG_COLORMAP) &&
-4.       (formatb & PNG_FORMAT_FLAG_LINEAR))
-3.       strideb *= 2;
-2.    if (stridea < 0) rowa += (height-1) * (-stridea);
-1.    if (strideb < 0) rowb += (height-1) * (-strideb);
   /* First shortcut the two colormap case by comparing the image data; if it
    * matches then we expect the colormaps to match, although this is not
    * absolutely necessary for an image match.  If the colormaps fail to match
    * then there is a problem in libpng.

 /*First shortcut the two colormap case by comparing the image data; if it
    * matches then we expect the colormaps to match, although this is not
    * absolutely necessary for an image match.  If the colormaps fail to match
    * then there is a problem in libpng.*/

1.     */
2.    if (formata & formatb & PNG_FORMAT_FLAG_COLORMAP)
3.    {",Useful
"/*Do this the slow way to accumulate the 'in_use' flags, don't break out
       * of the loop until the end; this validates the color-mapped data to
       * ensure all pixels are valid color-map indexes.*/","-6.       png_const_bytep ppa, ppb;
-5.       int match;
-4.       png_byte in_use[256], amax = 0, bmax = 0;
-3.       memset(in_use, 0, sizeof in_use);
-2.       ppa = rowa;
-1.       ppb = rowb;
      /* Do this the slow way to accumulate the 'in_use' flags, don't break out
       * of the loop until the end; this validates the color-mapped data to
       * ensure all pixels are valid color-map indexes.

 /*Do this the slow way to accumulate the 'in_use' flags, don't break out
       * of the loop until the end; this validates the color-mapped data to
       * ensure all pixels are valid color-map indexes.*/

1.        */
2.       for (y=0, match=1; y<height && match; ++y, ppa += stridea, ppb += strideb)
3.       {
4.          png_uint_32 x;
5.          for (x=0; x<width; ++x)
6.          {
7.             png_byte bval = ppb[x];
8.             png_byte aval = ppa[x];
9.             if (bval > bmax)
10.                bmax = bval;",Useful
/*If the buffers match then the colormaps must too.*/,"-10.             png_byte aval = ppa[x];
-9.             if (bval > bmax)
-8.                bmax = bval;
-7.             if (bval != aval)
-6.                match = 0;
-5.             in_use[aval] = 1;
-4.             if (aval > amax)
-3.                amax = aval;
-2.          }
-1.       }

 /*If the buffers match then the colormaps must too.*/

1.       if (match)
2.       {",Useful
"/*Do the color-maps match, entry by entry?  Only check the 'in_use'
          * entries.  An error here should be logged as a color-map error.*/","-2.       if (match)
-1.       {
         /* Do the color-maps match, entry by entry?  Only check the 'in_use'
          * entries.  An error here should be logged as a color-map error.

 /*Do the color-maps match, entry by entry?  Only check the 'in_use'
          * entries.  An error here should be logged as a color-map error.*/

1.           */
2.          png_const_bytep a_cmap = (png_const_bytep)a->colormap;
3.          png_const_bytep b_cmap = (png_const_bytep)b->colormap;",Useful
"/*The colormap entries should be valid, but because libpng doesn't
             * do any checking at present the original image may contain invalid
             * pixel values.  These cause an error here (at present) unless
             * accumulating errors in which case the program just ignores them.*/","-4.          tr.is_palette = 1;
-3.          for (y=0; y<256; ++y, a_cmap += a_sample, b_cmap += b_sample)
-2.             if (in_use[y])
-1.          {
            /* The colormap entries should be valid, but because libpng doesn't
             * do any checking at present the original image may contain invalid
             * pixel values.  These cause an error here (at present) unless
             * accumulating errors in which case the program just ignores them.

 /*The colormap entries should be valid, but because libpng doesn't
             * do any checking at present the original image may contain invalid
             * pixel values.  These cause an error here (at present) unless
             * accumulating errors in which case the program just ignores them.*/

1.              */
2.             if (y >= a->image.colormap_entries)
3.             {
4.                if ((a->opts & ACCUMULATE) == 0)
5.                {
6.                   char pindex[9];
7.                   sprintf(pindex, ""%lu[%lu]"", (unsigned long)y,
8.                      (unsigned long)a->image.colormap_entries);
9.                   logerror(a, a->file_name, "": bad pixel index: "", pindex);
10.                }",Useful
"/*else the image buffers don't match pixel-wise so compare sample values
       * instead, but first validate that the pixel indexes are in range (but
       * only if not accumulating, when the error is ignored.)*/","-3.          }
-2.          return result;
-1.       }
      /* else the image buffers don't match pixel-wise so compare sample values
       * instead, but first validate that the pixel indexes are in range (but
       * only if not accumulating, when the error is ignored.)

 /*else the image buffers don't match pixel-wise so compare sample values
       * instead, but first validate that the pixel indexes are in range (but
       * only if not accumulating, when the error is ignored.)*/

1.        */
2.       else if ((a->opts & ACCUMULATE) == 0)
3.       {
4. #        ifdef __GNUC__",Useful
/*2^32: GCC sprintf warning*/,"-3.       else if ((a->opts & ACCUMULATE) == 0)
-2.       {
-1. #        ifdef __GNUC__

 /*2^32: GCC sprintf warning*/

1. #        else",Useful
/*2^8: real maximum value*/,"-1. #        else

 /*2^8: real maximum value*/

1. #        endif",Useful
"/*Check the original image first,
          * TODO: deal with input images with bad pixel values?*/","-1. #        endif
         /* Check the original image first,
          * TODO: deal with input images with bad pixel values?

 /*Check the original image first,
          * TODO: deal with input images with bad pixel values?*/

1.           */
2.          if (amax >= a->image.colormap_entries)
3.          {
4.             char pindex[3+2*BYTE_CHARS];
5.             sprintf(pindex, ""%d[%u]"", amax,",Useful
"/*We can directly compare pixel values without the need to use the read
    * or transform support (i.e. a memory compare) if:
    *
    * 1) The bit depth has not changed.
    * 2) RGB to grayscale has not been done (the reverse is ok; we just compare
    *    the three RGB values to the original grayscale.)
    * 3) An alpha channel has not been removed from an 8-bit format, or the
    *    8-bit alpha value of the pixel was 255 (opaque).
    *
    * If an alpha channel has been *added* then it must have the relevant opaque
    * value (255 or 65535).
    *
    * The fist two the tests (in the order given above) (using the boolean
    * equivalence !a && !b == !(a || b))*/","-4.             return logerror(b, b->file_name, "": bad pixel index: "", pindex);
-3.          }
-2.       }
-1.    }
   /* We can directly compare pixel values without the need to use the read
    * or transform support (i.e. a memory compare) if:
    *
    * 1) The bit depth has not changed.
    * 2) RGB to grayscale has not been done (the reverse is ok; we just compare
    *    the three RGB values to the original grayscale.)
    * 3) An alpha channel has not been removed from an 8-bit format, or the
    *    8-bit alpha value of the pixel was 255 (opaque).
    *
    * If an alpha channel has been *added* then it must have the relevant opaque
    * value (255 or 65535).
    *
    * The fist two the tests (in the order given above) (using the boolean
    * equivalence !a && !b == !(a || b))

 /*We can directly compare pixel values without the need to use the read
    * or transform support (i.e. a memory compare) if:
    *
    * 1) The bit depth has not changed.
    * 2) RGB to grayscale has not been done (the reverse is ok; we just compare
    *    the three RGB values to the original grayscale.)
    * 3) An alpha channel has not been removed from an 8-bit format, or the
    *    8-bit alpha value of the pixel was 255 (opaque).
    *
    * If an alpha channel has been *added* then it must have the relevant opaque
    * value (255 or 65535).
    *
    * The fist two the tests (in the order given above) (using the boolean
    * equivalence !a && !b == !(a || b))*/

1.     */
2.    if (!(((formata ^ formatb) & PNG_FORMAT_FLAG_LINEAR) |
3.       (formata & (formatb ^ PNG_FORMAT_FLAG_COLOR) & PNG_FORMAT_FLAG_COLOR)))
4.    {",Useful
/*Was an alpha channel changed?*/,"-10.     *
-9.     * If an alpha channel has been *added* then it must have the relevant opaque
-8.     * value (255 or 65535).
-7.     *
-6.     * The fist two the tests (in the order given above) (using the boolean
-5.     * equivalence !a && !b == !(a || b))
-4.     */
-3.    if (!(((formata ^ formatb) & PNG_FORMAT_FLAG_LINEAR) |
-2.       (formata & (formatb ^ PNG_FORMAT_FLAG_COLOR) & PNG_FORMAT_FLAG_COLOR)))
-1.    {

 /*Was an alpha channel changed?*/

1.       const png_uint_32 alpha_changed = (formata ^ formatb) &
2.          PNG_FORMAT_FLAG_ALPHA;",Useful
"/*Was an alpha channel removed?  (The third test.)  If so the direct
       * comparison is only possible if the input alpha is opaque.*/","-2.       const png_uint_32 alpha_changed = (formata ^ formatb) &
-1.          PNG_FORMAT_FLAG_ALPHA;
      /* Was an alpha channel removed?  (The third test.)  If so the direct
       * comparison is only possible if the input alpha is opaque.

 /*Was an alpha channel removed?  (The third test.)  If so the direct
       * comparison is only possible if the input alpha is opaque.*/

1.        */
2.       alpha_removed = (formata & alpha_changed) != 0;",Useful
/*Was an alpha channel added?*/,"-1.       alpha_removed = (formata & alpha_changed) != 0;

 /*Was an alpha channel added?*/

1.       alpha_added = (formatb & alpha_changed) != 0;",Useful
"/*The channels may have been moved between input and output, this finds
       * out how, recording the result in the btoa array, which says where in
       * 'a' to find each channel of 'b'.  If alpha was added then btoa[alpha]
       * ends up as 4 (and is not used.)*/","-1.       alpha_added = (formatb & alpha_changed) != 0;
      /* The channels may have been moved between input and output, this finds
       * out how, recording the result in the btoa array, which says where in
       * 'a' to find each channel of 'b'.  If alpha was added then btoa[alpha]
       * ends up as 4 (and is not used.)

 /*The channels may have been moved between input and output, this finds
       * out how, recording the result in the btoa array, which says where in
       * 'a' to find each channel of 'b'.  If alpha was added then btoa[alpha]
       * ends up as 4 (and is not used.)*/

1.        */
2.       {
3.          int i;
4.          png_byte aloc[4];
5.          png_byte bloc[4];
6.          /* The following are used only if the formats match, except that
7.           * 'bchannels' is a flag for matching formats.  btoa[x] says, for each
8.           * channel in b, where to find the corresponding value in a, for the
9.           * bchannels.  achannels may be different for a gray to rgb transform
10.           * (a will be 1 or 2, b will be 3 or 4 channels.)",Useful
"/*The following are used only if the formats match, except that
          * 'bchannels' is a flag for matching formats.  btoa[x] says, for each
          * channel in b, where to find the corresponding value in a, for the
          * bchannels.  achannels may be different for a gray to rgb transform
          * (a will be 1 or 2, b will be 3 or 4 channels.)*/","-4.       {
-3.          int i;
-2.          png_byte aloc[4];
-1.          png_byte bloc[4];
         /* The following are used only if the formats match, except that
          * 'bchannels' is a flag for matching formats.  btoa[x] says, for each
          * channel in b, where to find the corresponding value in a, for the
          * bchannels.  achannels may be different for a gray to rgb transform
          * (a will be 1 or 2, b will be 3 or 4 channels.)

 /*The following are used only if the formats match, except that
          * 'bchannels' is a flag for matching formats.  btoa[x] says, for each
          * channel in b, where to find the corresponding value in a, for the
          * bchannels.  achannels may be different for a gray to rgb transform
          * (a will be 1 or 2, b will be 3 or 4 channels.)*/

1.           */
2.          (void)component_loc(aloc, formata);
3.          bchannels = component_loc(bloc, formatb);",Useful
/*location of alpha channel in image b*/,"-1.          if (alpha_added)

 /*location of alpha channel in image b*/

1.          else",Useful
/*Won't match an image b channel*/,"-1.          else

 /*Won't match an image b channel*/

1.          if (alpha_removed)",Useful
/*location of alpha channel in image a*/,"-1.          if (alpha_removed)

 /*location of alpha channel in image a*/

1.          else
2.             alpha_removed = 4;
3.       }
4.    }
5.    else
6.    {",Useful
"/*Direct compare is not possible, cancel out all the corresponding local
       * variables.*/","-6.          else
-5.             alpha_removed = 4;
-4.       }
-3.    }
-2.    else
-1.    {
      /* Direct compare is not possible, cancel out all the corresponding local
       * variables.

 /*Direct compare is not possible, cancel out all the corresponding local
       * variables.*/

1.        */
2.       bchannels = 0;
3.       alpha_removed = alpha_added = 4;",Useful
"/*Check each 'b' channel against either the corresponding 'a'
             * channel or the opaque alpha value, as appropriate.  If
             * alpha_removed value is set (not 4) then also do this only if the
             * 'a' alpha channel (alpha_removed) is opaque; only relevant for
             * the 8-bit case.*/","-2.          if (bchannels)
-1.          {
            /* Check each 'b' channel against either the corresponding 'a'
             * channel or the opaque alpha value, as appropriate.  If
             * alpha_removed value is set (not 4) then also do this only if the
             * 'a' alpha channel (alpha_removed) is opaque; only relevant for
             * the 8-bit case.

 /*Check each 'b' channel against either the corresponding 'a'
             * channel or the opaque alpha value, as appropriate.  If
             * alpha_removed value is set (not 4) then also do this only if the
             * 'a' alpha channel (alpha_removed) is opaque; only relevant for
             * the 8-bit case.*/

1.              */",Useful
"/*If we get to here the fast match failed; do the slow match for this
          * pixel.*/","-3.                }
-2.             }
-1.          }
         /* If we get to here the fast match failed; do the slow match for this
          * pixel.

 /*If we get to here the fast match failed; do the slow match for this
          * pixel.*/

1.           */
2.          if (!cmppixel(&tr, psa, psb, x, y) && (a->opts & KEEP_GOING) == 0)",Useful
"/*Read the file; how the read gets done depends on which of input_file and
 * input_memory have been set.*/","-9.    if (a->opts & ACCUMULATE)
-8.    {
-7.       tr.error_ptr[0] = tr.error[0];
-6.       tr.error_ptr[1] = tr.error[1];
-5.       tr.error_ptr[2] = tr.error[2];
-4.       tr.error_ptr[3] = tr.error[3];
-3.    }
-2.    return 1;
-1. }
/* Read the file; how the read gets done depends on which of input_file and
 * input_memory have been set.

 /*Read the file; how the read gets done depends on which of input_file and
 * input_memory have been set.*/

1.  */
2. static int
3. read_file(Image *image, png_uint_32 format, png_const_colorp background)
4. {
5.    memset(&image->image, 0, sizeof image->image);
6.    image->image.version = PNG_IMAGE_VERSION;
7.    if (image->input_memory != NULL)
8.    {
9.       if (!png_image_begin_read_from_memory(&image->image, image->input_memory,
10.          image->input_memory_size))",Useful
"/*Have an initialized image with all the data we need plus, maybe, an
    * allocated file (myfile) or buffer (mybuffer) that need to be freed.*/","-2.    if (image->opts & sRGB_16BIT)
-1.       image->image.flags |= PNG_IMAGE_FLAG_16BIT_sRGB;
   /* Have an initialized image with all the data we need plus, maybe, an
    * allocated file (myfile) or buffer (mybuffer) that need to be freed.

 /*Have an initialized image with all the data we need plus, maybe, an
    * allocated file (myfile) or buffer (mybuffer) that need to be freed.*/

1.     */
2.    {
3.       int result;
4.       png_uint_32 image_format;",Useful
/*Print both original and output formats.*/,"-3.    {
-2.       int result;
-1.       png_uint_32 image_format;

 /*Print both original and output formats.*/

1.       image_format = image->image.format;
2.       if (image->opts & VERBOSE)
3.       {
4.          printf(""%s %lu x %lu %s -> %s"", image->file_name,
5.             (unsigned long)image->image.width,
6.             (unsigned long)image->image.height,
7.             format_names[image_format & FORMAT_MASK],
8.             (format & FORMAT_NO_CHANGE) != 0 || image->image.format == format
9.             ? ""no change"" : format_names[format & FORMAT_MASK]);
10.          if (background != NULL)",Useful
"/*NO_CHANGE' combined with the color-map flag forces the base format
       * flags to be set on read to ensure that the original representation is
       * not lost in the pass through a colormap format.*/","-10.             format_names[image_format & FORMAT_MASK],
-9.             (format & FORMAT_NO_CHANGE) != 0 || image->image.format == format
-8.             ? ""no change"" : format_names[format & FORMAT_MASK]);
-7.          if (background != NULL)
-6.             printf("" background(%d,%d,%d)\n"", background->red,
-5.                background->green, background->blue);
-4.          else
-3.             printf(""\n"");
-2.          fflush(stdout);
-1.       }
      /* 'NO_CHANGE' combined with the color-map flag forces the base format
       * flags to be set on read to ensure that the original representation is
       * not lost in the pass through a colormap format.

 /*NO_CHANGE' combined with the color-map flag forces the base format
       * flags to be set on read to ensure that the original representation is
       * not lost in the pass through a colormap format.*/

1.        */
2.       if ((format & FORMAT_NO_CHANGE) != 0)
3.       {
4.          if ((format & PNG_FORMAT_FLAG_COLORMAP) != 0 &&
5.             (image_format & PNG_FORMAT_FLAG_COLORMAP) != 0)
6.             format = (image_format & ~BASE_FORMATS) | (format & BASE_FORMATS);
7.          else
8.             format = image_format;
9.       }
10.       image->image.format = format;",Useful
"/*Reads from a filename, which must be in image->file_name, but uses
 * image->opts to choose the method.  The file is always read in its native
 * format (the one the simplified API suggests).*/","-10.       allocbuffer(image);
-9.       result = png_image_finish_read(&image->image, background,
-8.          image->buffer+16, (png_int_32)image->stride, image->colormap);
-7.       checkbuffer(image, image->file_name);
-6.       if (result)
-5.          return checkopaque(image);
-4.       else
-3.          return logerror(image, image->file_name, "": image read failed"", """");
-2.    }
-1. }
/* Reads from a filename, which must be in image->file_name, but uses
 * image->opts to choose the method.  The file is always read in its native
 * format (the one the simplified API suggests).

 /*Reads from a filename, which must be in image->file_name, but uses
 * image->opts to choose the method.  The file is always read in its native
 * format (the one the simplified API suggests).*/

1.  */
2. static int
3. read_one_file(Image *image)
4. {
5.    if (!(image->opts & USE_FILE) || (image->opts & USE_STDIO))
6.    {",Useful
"/*cb is the length of the file as a (long) and
                      * this is greater than the maximum amount of
                      * memory that can be requested from malloc.*/","-10.                               "": read failed: "");
-9.                         }
-8.                      }
-7.                      else
-6.                         return logclose(image, f, image->file_name,
-5.                            "": out of memory: "");
-4.                   }
-3.                   else
-2.                      return logclose(image, f, image->file_name,
-1.                         "": file too big for this architecture: "");
                     /* cb is the length of the file as a (long) and
                      * this is greater than the maximum amount of
                      * memory that can be requested from malloc.

 /*cb is the length of the file as a (long) and
                      * this is greater than the maximum amount of
                      * memory that can be requested from malloc.*/

1.                       */
2.                }
3.                else if (cb == 0)
4.                   return logclose(image, f, image->file_name,
5.                      "": zero length: "");
6.                else
7.                   return logclose(image, f, image->file_name,
8.                      "": tell failed: "");
9.             }
10.             else",Useful
"/*Experimental. Coverity says tmpfile() is insecure because it
       * generates predictable names.
       *
       * It is possible to satisfy Coverity by using mkstemp(); however,
       * any platform supporting mkstemp() undoubtedly has a secure tmpfile()
       * implementation as well, and doesn't need the fix.  Note that
       * the fix won't work on platforms that don't support mkstemp().
       *
       * https://www.securecoding.cert.org/confluence/display/c/
       * FIO21-C.+Do+not+create+temporary+files+in+shared+directories
       * says that most historic implementations of tmpfile() provide
       * only a limited number of possible temporary file names
       * (usually 26) before file names are recycled. That article also
       * provides a secure solution that unfortunately depends upon mkstemp().*/","* FIO21-C.+Do+not+create+temporary+files+in+shared+directories
       * says that most historic implementations of tmpfile() provide
       * only a limited number of possible temporary file names
       * (usually 26) before file names are recycled. That article also
       * provides a secure solution that unfortunately depends upon mkstemp().

 /*Experimental. Coverity says tmpfile() is insecure because it
       * generates predictable names.
       *
       * It is possible to satisfy Coverity by using mkstemp(); however,
       * any platform supporting mkstemp() undoubtedly has a secure tmpfile()
       * implementation as well, and doesn't need the fix.  Note that
       * the fix won't work on platforms that don't support mkstemp().
       *
       * https://www.securecoding.cert.org/confluence/display/c/
       * FIO21-C.+Do+not+create+temporary+files+in+shared+directories
       * says that most historic implementations of tmpfile() provide
       * only a limited number of possible temporary file names
       * (usually 26) before file names are recycled. That article also
       * provides a secure solution that unfortunately depends upon mkstemp().*/

1.        */
2.       char tmpfile[] = ""pngstest-XXXXXX"";
3.       int filedes;
4.       FILE *f;
5.       umask(0177);
6.       filedes = mkstemp(tmpfile);
7.       if (filedes < 0)
8.         f = NULL;
9.       else
10.       {",Useful
"/*output' has an initialized temporary image, read this back in and compare
    * this against the original: there should be no change since the original
    * format was written unmodified unless 'convert_to_8bit' was specified.
    * However, if the original image was color-mapped, a simple read will zap
    * the linear, color and maybe alpha flags, this will cause spurious failures
    * under some circumstances.*/","-10.             }
-9.             else
-8.                return logerror(image, ""memory"", "": write failed"", """");
-7.          }
-6.          else
-5.             return logerror(image, ""memory"", "": out of memory"", """");
-4.       }
-3.       else
-2.          return logerror(image, ""memory"", "": get size:"", """");
-1.    }
   /* 'output' has an initialized temporary image, read this back in and compare
    * this against the original: there should be no change since the original
    * format was written unmodified unless 'convert_to_8bit' was specified.
    * However, if the original image was color-mapped, a simple read will zap
    * the linear, color and maybe alpha flags, this will cause spurious failures
    * under some circumstances.

 /*output' has an initialized temporary image, read this back in and compare
    * this against the original: there should be no change since the original
    * format was written unmodified unless 'convert_to_8bit' was specified.
    * However, if the original image was color-mapped, a simple read will zap
    * the linear, color and maybe alpha flags, this will cause spurious failures
    * under some circumstances.*/

1.     */
2.    if (read_file(output, image->image.format | FORMAT_NO_CHANGE, NULL))
3.    {
4.       png_uint_32 original_format = image->image.format;
5.       if (convert_to_8bit)
6.          original_format &= ~PNG_FORMAT_FLAG_LINEAR;
7.       if ((output->image.format & BASE_FORMATS) !=
8.          (original_format & BASE_FORMATS))
9.          return logerror(image, image->file_name, "": format changed on read: "",
10.             output->file_name);",Useful
"/*Copy the original data, stealing it from 'image'*/","-10.    else
-9.       return logerror(output, output->tmpfile_name,
-8.          "": read of new file failed"", """");
-7. }
-6. #endif
-5. static int
-4. testimage(Image *image, png_uint_32 opts, format_list *pf)
-3. {
-2.    int result;
-1.    Image copy;

 /*Copy the original data, stealing it from 'image'*/

1.    checkopaque(image);
2.    copy = *image;
3.    copy.opts = opts;
4.    copy.buffer = NULL;
5.    copy.bufsize = 0;
6.    copy.allocsize = 0;
7.    image->input_file = NULL;
8.    image->input_memory = NULL;
9.    image->input_memory_size = 0;
10.    image->tmpfile_name[0] = 0;",Useful
"/*Use the low bit of 'counter' to indicate whether or not to do alpha
       * removal with a background color or by composting onto the image; this
       * step gets skipped if it isn't relevant*/","-10.    copy.allocsize = 0;
-9.    image->input_file = NULL;
-8.    image->input_memory = NULL;
-7.    image->input_memory_size = 0;
-6.    image->tmpfile_name[0] = 0;
-5.    {
-4.       png_uint_32 counter;
-3.       Image output;
-2.       newimage(&output);
-1.       result = 1;
      /* Use the low bit of 'counter' to indicate whether or not to do alpha
       * removal with a background color or by composting onto the image; this
       * step gets skipped if it isn't relevant

 /*Use the low bit of 'counter' to indicate whether or not to do alpha
       * removal with a background color or by composting onto the image; this
       * step gets skipped if it isn't relevant*/

1.        */
2.       for (counter=0; counter<2*FORMAT_COUNT; ++counter)
3.          if (format_isset(pf, counter >> 1))
4.       {
5.          png_uint_32 format = counter >> 1;
6.          png_color background_color;
7.          png_colorp background = NULL;
8.          /* If there is a format change that removes the alpha channel then
9.           * the background is relevant.  If the output is 8-bit color-mapped
10.           * then a background color *must* be provided, otherwise there are",Useful
"/*If there is a format change that removes the alpha channel then
          * the background is relevant.  If the output is 8-bit color-mapped
          * then a background color *must* be provided, otherwise there are
          * two tests to do - one with a color, the other with NULL.  The
          * NULL test happens second.*/","-6.       for (counter=0; counter<2*FORMAT_COUNT; ++counter)
-5.          if (format_isset(pf, counter >> 1))
-4.       {
-3.          png_uint_32 format = counter >> 1;
-2.          png_color background_color;
-1.          png_colorp background = NULL;
         /* If there is a format change that removes the alpha channel then
          * the background is relevant.  If the output is 8-bit color-mapped
          * then a background color *must* be provided, otherwise there are
          * two tests to do - one with a color, the other with NULL.  The
          * NULL test happens second.

 /*If there is a format change that removes the alpha channel then
          * the background is relevant.  If the output is 8-bit color-mapped
          * then a background color *must* be provided, otherwise there are
          * two tests to do - one with a color, the other with NULL.  The
          * NULL test happens second.*/

1.           */
2.          if ((counter & 1) == 0)
3.          {
4.             if ((format & PNG_FORMAT_FLAG_ALPHA) == 0 &&
5.                (image->image.format & PNG_FORMAT_FLAG_ALPHA) != 0)
6.             {",Useful
"/*Alpha/transparency will be removed, the background is
                * relevant: make it a color the first time*/","-10.           * the background is relevant.  If the output is 8-bit color-mapped
-9.           * then a background color *must* be provided, otherwise there are
-8.           * two tests to do - one with a color, the other with NULL.  The
-7.           * NULL test happens second.
-6.           */
-5.          if ((counter & 1) == 0)
-4.          {
-3.             if ((format & PNG_FORMAT_FLAG_ALPHA) == 0 &&
-2.                (image->image.format & PNG_FORMAT_FLAG_ALPHA) != 0)
-1.             {
               /* Alpha/transparency will be removed, the background is
                * relevant: make it a color the first time

 /*Alpha/transparency will be removed, the background is
                * relevant: make it a color the first time*/

1.                 */
2.                random_color(&background_color);
3.                background = &background_color;",Useful
"/*BUT if the output is to a color-mapped 8-bit format then
                * the background must always be a color, so increment 'counter'
                * to skip the NULL test.*/","-2.                random_color(&background_color);
-1.                background = &background_color;
               /* BUT if the output is to a color-mapped 8-bit format then
                * the background must always be a color, so increment 'counter'
                * to skip the NULL test.

 /*BUT if the output is to a color-mapped 8-bit format then
                * the background must always be a color, so increment 'counter'
                * to skip the NULL test.*/

1.                 */
2.                if ((format & PNG_FORMAT_FLAG_COLORMAP) != 0 &&
3.                   (format & PNG_FORMAT_FLAG_LINEAR) == 0)
4.                   ++counter;
5.             }",Useful
"/*Otherwise an alpha channel is not being eliminated, just leave
             * background NULL and skip the (counter & 1) NULL test.*/","-4.                if ((format & PNG_FORMAT_FLAG_COLORMAP) != 0 &&
-3.                   (format & PNG_FORMAT_FLAG_LINEAR) == 0)
-2.                   ++counter;
-1.             }
            /* Otherwise an alpha channel is not being eliminated, just leave
             * background NULL and skip the (counter & 1) NULL test.

 /*Otherwise an alpha channel is not being eliminated, just leave
             * background NULL and skip the (counter & 1) NULL test.*/

1.              */
2.             else
3.                ++counter;
4.          }",Useful
/*else just use NULL for background*/,"-3.             else
-2.                ++counter;
-1.          }

 /*else just use NULL for background*/

1.          resetimage(&copy);",Useful
/*Make sure the file just read matches the original file.*/,"-3.          result = read_file(&copy, format, background);
-2.          if (!result)
-1.             break;

 /*Make sure the file just read matches the original file.*/

 ",Useful
"/*Write the *copy* just made to a new file to make sure the write
             * side works ok.  Check the conversion to sRGB if the copy is
             * linear.*/","-3.          if (!result)
-2.             break;
-1. #        ifdef PNG_SIMPLIFIED_WRITE_SUPPORTED
            /* Write the *copy* just made to a new file to make sure the write
             * side works ok.  Check the conversion to sRGB if the copy is
             * linear.

 /*Write the *copy* just made to a new file to make sure the write
             * side works ok.  Check the conversion to sRGB if the copy is
             * linear.*/

1.              */
2.             output.opts = opts;",Useful
"/*Validate against the original too; the background is needed here
             * as well so that compare_two_images knows what color was used.*/","-2.             if (!result)
-1.                break;
            /* Validate against the original too; the background is needed here
             * as well so that compare_two_images knows what color was used.

 /*Validate against the original too; the background is needed here
             * as well so that compare_two_images knows what color was used.*/

1.              */
2.             result = compare_two_images(image, &output, 0, background);
3.             if (!result)
4.                break;
5.             if ((format & PNG_FORMAT_FLAG_LINEAR) != 0 &&
6.                (format & PNG_FORMAT_FLAG_COLORMAP) == 0)
7.             {",Useful
"/*output' is linear, convert to the corresponding sRGB format.*/","-6.             result = compare_two_images(image, &output, 0, background);
-5.             if (!result)
-4.                break;
-3.             if ((format & PNG_FORMAT_FLAG_LINEAR) != 0 &&
-2.                (format & PNG_FORMAT_FLAG_COLORMAP) == 0)
-1.             {
               /* 'output' is linear, convert to the corresponding sRGB format.

 /*output' is linear, convert to the corresponding sRGB format.*/

1.                 */
2.                output.opts = opts;",Useful
"/*This may involve a conversion via linear; in the ideal world
                * this would round-trip correctly, but libpng 1.5.7 is not the
                * ideal world so allow a drift (error_via_linear).
                *
                * 'image' has an alpha channel but 'output' does not then there
                * will a strip-alpha-channel operation (because 'output' is
                * linear), handle this by composing on black when doing the
                * comparison.*/","-2.                if (!result)
-1.                   break;
               /* This may involve a conversion via linear; in the ideal world
                * this would round-trip correctly, but libpng 1.5.7 is not the
                * ideal world so allow a drift (error_via_linear).
                *
                * 'image' has an alpha channel but 'output' does not then there
                * will a strip-alpha-channel operation (because 'output' is
                * linear), handle this by composing on black when doing the
                * comparison.

 /*This may involve a conversion via linear; in the ideal world
                * this would round-trip correctly, but libpng 1.5.7 is not the
                * ideal world so allow a drift (error_via_linear).
                *
                * 'image' has an alpha channel but 'output' does not then there
                * will a strip-alpha-channel operation (because 'output' is
                * linear), handle this by composing on black when doing the
                * comparison.*/

1.                 */",Useful
/*ensure that the random numbers don't depend on file order*/,"-10.    freeimage(&copy);
-9.    return result;
-8. }
-7. static int
-6. test_one_file(const char *file_name, format_list *formats, png_uint_32 opts,
-5.    int stride_extra, int log_pass)
-4. {
-3.    int result;
-2.    Image image;
-1.    if (!(opts & NO_RESEED))

 /*ensure that the random numbers don't depend on file order*/

1.    newimage(&image);
2.    initimage(&image, opts, file_name, stride_extra);
3.    result = read_one_file(&image);
4.    if (result)
5.       result = testimage(&image, opts, formats);
6.    freeimage(&image);",Useful
/*Ensure that stderr is flushed into any log file*/,"-6.    newimage(&image);
-5.    initimage(&image, opts, file_name, stride_extra);
-4.    result = read_one_file(&image);
-3.    if (result)
-2.       result = testimage(&image, opts, formats);
-1.    freeimage(&image);

 /*Ensure that stderr is flushed into any log file*/

1.    fflush(stderr);
2.    if (log_pass)
3.    {
4.       if (result)
5.          printf(""PASS:"");
6.       else
7.          printf(""FAIL:"");
8. #     ifndef PNG_SIMPLIFIED_WRITE_SUPPORTED
9.          printf("" (no write)"");
10. #     endif",Useful
"/*Loop reading files, use a static buffer to simplify this and just
             * stop if the name gets to long.*/","-10.          exit(99);
-9.       }
-8.       else
-7.       {
-6.          if (format_is_initial(&formats))
-5.             format_default(&formats, redundant);
-4.          if (arg[0] == '-')
-3.          {
-2.             const int term = (arg[1] == '0' ? 0 : '\n');
-1.             unsigned int ich = 0;
            /* Loop reading files, use a static buffer to simplify this and just
             * stop if the name gets to long.

 /*Loop reading files, use a static buffer to simplify this and just
             * stop if the name gets to long.*/

1.              */
2.             static char buffer[4096];
3.             do
4.             {
5.                int ch = getchar();",Useful
"/*Don't allow '\0' in file names, and terminate with '\n' or,
                * for -0, just '\0' (use -print0 to find to make this work!)*/","-4.             static char buffer[4096];
-3.             do
-2.             {
-1.                int ch = getchar();
               /* Don't allow '\0' in file names, and terminate with '\n' or,
                * for -0, just '\0' (use -print0 to find to make this work!)

 /*Don't allow '\0' in file names, and terminate with '\n' or,
                * for -0, just '\0' (use -print0 to find to make this work!)*/

1.                 */
2.                if (ch == EOF || ch == term || ch == 0)
3.                {
4.                   buffer[ich] = 0;
5.                   if (ich > 0 && !test_one_file(buffer, &formats, opts,
6.                      stride_extra, log_pass))
7.                      retval = 1;
8.                   if (ch == EOF)
9.                      break;
10.                   ich = 0;",Useful
"/*Define the following to use this test against your installed libpng, rather
 * than the one being built here:*/","-10.  * NOTES:
-9.  *   This is a C program that is intended to be linked against libpng.  It
-8.  *   allows the libpng unknown handling code to be tested by interpreting
-7.  *   arguments to save or discard combinations of chunks.  The program is
-6.  *   currently just a minimal validation for the built-in libpng facilities.
-5.  */
-4. #include <stdlib.h>
-3. #include <string.h>
-2. #include <stdio.h>
-1. #include <setjmp.h>
/* Define the following to use this test against your installed libpng, rather
 * than the one being built here:

 /*Define the following to use this test against your installed libpng, rather
 * than the one being built here:*/

1.  */
2. #ifdef PNG_FREESTANDING_TESTS
3. #  include <png.h>
4. #else
5. #  include ""../../png.h""
6. #endif",Useful
"/*1.6.1 added support for the configure test harness, which uses 77 to indicate
 * a skipped test, in earlier versions we need to succeed on a skipped test, so:*/","-5. #ifdef PNG_FREESTANDING_TESTS
-4. #  include <png.h>
-3. #else
-2. #  include ""../../png.h""
-1. #endif
/* 1.6.1 added support for the configure test harness, which uses 77 to indicate
 * a skipped test, in earlier versions we need to succeed on a skipped test, so:

 /*1.6.1 added support for the configure test harness, which uses 77 to indicate
 * a skipped test, in earlier versions we need to succeed on a skipped test, so:*/

1.  */
2. #if PNG_LIBPNG_VER >= 10601 && defined(HAVE_CONFIG_H)
3. #  define SKIP 77
4. #else
5. #  define SKIP 0
6. #endif",Useful
"/*Since this program tests the ability to change the unknown chunk handling
 * these must be defined:*/","-5. #if PNG_LIBPNG_VER >= 10601 && defined(HAVE_CONFIG_H)
-4. #  define SKIP 77
-3. #else
-2. #  define SKIP 0
-1. #endif
/* Since this program tests the ability to change the unknown chunk handling
 * these must be defined:

 /*Since this program tests the ability to change the unknown chunk handling
 * these must be defined:*/

1.  */
2. #if defined(PNG_SET_UNKNOWN_CHUNKS_SUPPORTED) &&\
3.    defined(PNG_STDIO_SUPPORTED) &&\
4.    defined(PNG_READ_SUPPORTED)",Useful
"/*One of these must be defined to allow us to find out what happened.  It is
 * still useful to set unknown chunk handling without either of these in order
 * to cause *known* chunks to be discarded.  This can be a significant
 * efficiency gain, but it can't really be tested here.*/","-3. #if defined(PNG_SET_UNKNOWN_CHUNKS_SUPPORTED) &&\
-2.    defined(PNG_STDIO_SUPPORTED) &&\
-1.    defined(PNG_READ_SUPPORTED)
/* One of these must be defined to allow us to find out what happened.  It is
 * still useful to set unknown chunk handling without either of these in order
 * to cause *known* chunks to be discarded.  This can be a significant
 * efficiency gain, but it can't really be tested here.

 /*One of these must be defined to allow us to find out what happened.  It is
 * still useful to set unknown chunk handling without either of these in order
 * to cause *known* chunks to be discarded.  This can be a significant
 * efficiency gain, but it can't really be tested here.*/

1.  */
2. #if defined(PNG_READ_USER_CHUNKS_SUPPORTED) ||\
3.    defined(PNG_SAVE_UNKNOWN_CHUNKS_SUPPORTED)
4. #if PNG_LIBPNG_VER < 10500",Useful
/*These are needed too for the default build:*/,"-10.    (((yIn)<<PNG_PASS_ROW_SHIFT(pass))+PNG_PASS_START_ROW(pass))
-9. #define PNG_COL_FROM_PASS_COL(xIn, pass) \
-8.    (((xIn)<<PNG_PASS_COL_SHIFT(pass))+PNG_PASS_START_COL(pass))
-7. #define PNG_PASS_MASK(pass,off) ( \
-6.    ((0x110145AFU>>(((7-(off))-(pass))<<2)) & 0xFU) | \
-5.    ((0x01145AF0U>>(((7-(off))-(pass))<<2)) & 0xF0U))
-4. #define PNG_ROW_IN_INTERLACE_PASS(y, pass) \
-3.    ((PNG_PASS_MASK(pass,0) >> ((y)&7)) & 1)
-2. #define PNG_COL_IN_INTERLACE_PASS(x, pass) \
-1.    ((PNG_PASS_MASK(pass,1) >> ((x)&7)) & 1)

 /*These are needed too for the default build:*/

1. #define PNG_WRITE_16BIT_SUPPORTED
2. #define PNG_READ_16BIT_SUPPORTED",Useful
"/*Unused formal parameter errors are removed using the following macro which is
 * expected to have no bad effects on performance.*/","
/* Unused formal parameter errors are removed using the following macro which is
 * expected to have no bad effects on performance.



 /*Unused formal parameter errors are removed using the following macro which is
 * expected to have no bad effects on performance.*/

1.  */
2. #ifndef UNUSED
3. #  if defined(__GNUC__) || defined(_MSC_VER)
4. #     define UNUSED(param) (void)param;
5. #  else
6. #     define UNUSED(param)
7. #  endif
8. #endif",Useful
/*Chunk set by the '-1' option*/,"-10. #define PNG_INFO_vpAg 0x02000000U
-9. #define ABSENT  0
-8. #define START   1
-7. #define END     2
-6. static struct
-5. {
-4.    char        name[5];
-3.    png_uint_32 flag;
-2.    png_uint_32 tag;

 /*Chunk set by the '-1' option*/

 ",Useful
"/*This is a mess but it seems to be the only way to do it - there is no way
    * to check for a definition outside a #if.*/","-2.    { ""PLTE"", PNG_INFO_PLTE, png_PLTE, 0, 0, ABSENT, 0 },

 /*This is a mess but it seems to be the only way to do it - there is no way
    * to check for a definition outside a #if.*/

1.     */
2.    { ""bKGD"", PNG_INFO_bKGD, png_bKGD,
3. #     ifdef PNG_READ_bKGD_SUPPORTED
4.          0,
5. #     else
6.          1,
7. #     endif
8.       1,  START, 0 },
9.    { ""cHRM"", PNG_INFO_cHRM, png_cHRM,
10. #     ifdef PNG_READ_cHRM_SUPPORTED",Useful
"/*During initialization and if this is a single command line argument set
    * exit now - there is only one test, otherwise longjmp to do the next test.*/","-10.       fprintf(stderr, ""%s(%s): png_destroy_read_struct error\n"", d->file,
-9.          d->test);
-8.       exit(1);
-7.    }
-6. }
-5. PNG_FUNCTION(void, display_exit, (display *d), static PNG_NORETURN)
-4. {
-3.    ++(d->error_count);
-2.    if (d->png_ptr != NULL)
-1.       clean_display(d);
   /* During initialization and if this is a single command line argument set
    * exit now - there is only one test, otherwise longjmp to do the next test.

 /*During initialization and if this is a single command line argument set
    * exit now - there is only one test, otherwise longjmp to do the next test.*/

1.     */
2.    if (d->test == init || d->test == cmd)
3.       exit(1);
4.    longjmp(d->error_return, 1);
5. }
6. static int
7. display_rc(const display *d, int strict)
8. {
9.    return d->error_count + (strict ? d->warning_count : 0);
10. }",Useful
/*Map the text chunks back into the flags*/,"-10. warning(png_structp png_ptr, const char *message)
-9. {
-8.    display *d = (display*)png_get_error_ptr(png_ptr);
-7.    fprintf(stderr, ""%s(%s): libpng warning: %s\n"", d->file, d->test, message);
-6.    ++(d->warning_count);
-5. }
-4. static png_uint_32
-3. get_valid(display *d, png_infop info_ptr)
-2. {
-1.    png_uint_32 flags = png_get_valid(d->png_ptr, info_ptr, (png_uint_32)~0);

 /*Map the text chunks back into the flags*/

1.    {
2.       png_textp text;
3.       png_uint_32 ntext = png_get_text(d->png_ptr, info_ptr, &text, NULL);
4.       while (ntext > 0) switch (text[--ntext].compression)
5.       {
6.          case -1:
7.             flags |= PNG_INFO_tEXt;
8.             break;
9.          case 0:
10.             flags |= PNG_INFO_zTXt;",Useful
"/*This function mimics the behavior of png_set_keep_unknown_chunks by
    * returning '0' to keep the chunk and '1' to discard it.*/","-10.                d->test, text[ntext].compression);
-9.             display_exit(d);
-8.       }
-7.    }
-6.    return flags;
-5. }
-4. #ifdef PNG_READ_USER_CHUNKS_SUPPORTED
-3. static int PNGCBAPI
-2. read_callback(png_structp pp, png_unknown_chunkp pc)
-1. {
   /* This function mimics the behavior of png_set_keep_unknown_chunks by
    * returning '0' to keep the chunk and '1' to discard it.

 /*This function mimics the behavior of png_set_keep_unknown_chunks by
    * returning '0' to keep the chunk and '1' to discard it.*/

1.     */
2.    display *d = voidcast(display*, png_get_user_chunk_ptr(pp));
3.    int chunk = findb(pc->name);
4.    int keep, discard;",Useful
"/*See the comments in png.h - use the default for unknown chunks,
          * do not keep known chunks.*/","-6.       keep = d->keep;
-5.    else
-4.    {
-3.       keep = chunk_info[chunk].keep;
-2.       if (keep == PNG_HANDLE_CHUNK_AS_DEFAULT)
-1.       {
         /* See the comments in png.h - use the default for unknown chunks,
          * do not keep known chunks.

 /*See the comments in png.h - use the default for unknown chunks,
          * do not keep known chunks.*/

1.           */
2.          if (chunk_info[chunk].unknown)
3.             keep = d->keep;
4.          else
5.             keep = PNG_HANDLE_CHUNK_NEVER;
6.       }
7.    }
8.    switch (keep)
9.    {
10.       default:",Useful
"/*Also store information about this chunk in the display, the relevant flag
    * is set if the chunk is to be kept ('not handled'.)*/","-2.          break;
-1.    }
   /* Also store information about this chunk in the display, the relevant flag
    * is set if the chunk is to be kept ('not handled'.)

 /*Also store information about this chunk in the display, the relevant flag
    * is set if the chunk is to be kept ('not handled'.)*/

1.     */",Useful
"/*However if there is no support to store unknown chunks don't ask libpng to
    * do it; there will be an png_error.*/","-7.    {
-6.       png_uint_32 flag = chunk_info[chunk].flag;
-5.       if (pc->location & PNG_AFTER_IDAT)
-4.          d->after_IDAT |= flag;
-3.       else
-2.          d->before_IDAT |= flag;
-1.    }
   /* However if there is no support to store unknown chunks don't ask libpng to
    * do it; there will be an png_error.

 /*However if there is no support to store unknown chunks don't ask libpng to
    * do it; there will be an png_error.*/

1.     */
2. #  ifdef PNG_SAVE_UNKNOWN_CHUNKS_SUPPORTED
3.       return discard;
4. #  else",Useful
"/*Chunks not known to pngunknown must be validated here; since they
          * must also be unknown to libpng the 'display->keep' behavior should
          * have been used.*/","-8.    png_uint_32 flags = 0;
-7.    UNUSED(after_IDAT)
-6.    {
-5.       png_unknown_chunkp unknown;
-4.       int num_unknown = png_get_unknown_chunks(d->png_ptr, info_ptr, &unknown);
-3.       while (--num_unknown >= 0)
-2.       {
-1.          int chunk = findb(unknown[num_unknown].name);
         /* Chunks not known to pngunknown must be validated here; since they
          * must also be unknown to libpng the 'display->keep' behavior should
          * have been used.

 /*Chunks not known to pngunknown must be validated here; since they
          * must also be unknown to libpng the 'display->keep' behavior should
          * have been used.*/

1.           */
2.          if (chunk < 0) switch (d->keep)
3.          {",Useful
/*Otherwise this will return the cached values set by any user callback*/,"-2. static png_uint_32
-1. get_unknown(display *d, png_infop info_ptr, int after_IDAT)

 /*Otherwise this will return the cached values set by any user callback*/

1. {
2.    UNUSED(info_ptr);
3.    if (after_IDAT)
4.       return d->after_IDAT;
5.    else
6.       return d->before_IDAT;
7. }
8. #  ifndef PNG_READ_USER_CHUNKS_SUPPORTED
9.       /* The #defines above should mean this is never reached, it's just here as
10.        * a check to ensure the logic is correct.",Useful
"/*The #defines above should mean this is never reached, it's just here as
       * a check to ensure the logic is correct.*/","-8. {
-7.    UNUSED(info_ptr);
-6.    if (after_IDAT)
-5.       return d->after_IDAT;
-4.    else
-3.       return d->before_IDAT;
-2. }
-1. #  ifndef PNG_READ_USER_CHUNKS_SUPPORTED
      /* The #defines above should mean this is never reached, it's just here as
       * a check to ensure the logic is correct.

 /*The #defines above should mean this is never reached, it's just here as
       * a check to ensure the logic is correct.*/

1.        */
2. #     error No store support and no user chunk support, this will not work",Useful
"/*Some of these errors are permanently fatal and cause an exit here, others
    * are per-test and cause an error return.*/","-7.    display *d, int set_callback)
-6. {
-5.    int i, npasses, ipass;
-4.    png_uint_32 height;
-3.    d->keep = PNG_HANDLE_CHUNK_AS_DEFAULT;
-2.    d->before_IDAT = 0;
-1.    d->after_IDAT = 0;
   /* Some of these errors are permanently fatal and cause an exit here, others
    * are per-test and cause an error return.

 /*Some of these errors are permanently fatal and cause an exit here, others
    * are per-test and cause an error return.*/

1.     */
2.    d->png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING, d, error,
3.       warning);
4.    if (d->png_ptr == NULL)
5.    {
6.       fprintf(stderr, ""%s(%s): could not allocate png struct\n"", d->file,
7.          d->test);",Useful
"/*Terminate here, this error is not test specific.*/","-6.    d->png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING, d, error,
-5.       warning);
-4.    if (d->png_ptr == NULL)
-3.    {
-2.       fprintf(stderr, ""%s(%s): could not allocate png struct\n"", d->file,
-1.          d->test);

 /*Terminate here, this error is not test specific.*/

1.       exit(1);
2.    }
3.    d->info_ptr = png_create_info_struct(d->png_ptr);
4.    d->end_ptr = png_create_info_struct(d->png_ptr);
5.    if (d->info_ptr == NULL || d->end_ptr == NULL)
6.    {
7.       fprintf(stderr, ""%s(%s): could not allocate png info\n"", d->file,
8.          d->test);
9.       clean_display(d);
10.       exit(1);",Useful
"/*Handle each argument in turn; multiple settings are possible for the same
    * chunk and multiple calls will occur (the last one should override all
    * preceding ones).*/","-5.       if (set_callback)
-4.          png_set_read_user_chunk_fn(d->png_ptr, d, read_callback);
-3. #  else
-2.       UNUSED(set_callback)
-1. #  endif
   /* Handle each argument in turn; multiple settings are possible for the same
    * chunk and multiple calls will occur (the last one should override all
    * preceding ones).

 /*Handle each argument in turn; multiple settings are possible for the same
    * chunk and multiple calls will occur (the last one should override all
    * preceding ones).*/

1.     */
2.    for (i=0; i<argc; ++i)
3.    {
4.       const char *equals = strchr(argv[i], '=');
5.       if (equals != NULL)
6.       {
7.          int chunk, option;
8.          if (strcmp(equals+1, ""default"") == 0)
9.             option = PNG_HANDLE_CHUNK_AS_DEFAULT;
10.          else if (strcmp(equals+1, ""discard"") == 0)",Useful
"/*These #if tests have the effect of skipping the arguments
                   * if SAVE support is unavailable - we can't do a useful test
                   * in this case, so we just check the arguments!  This could
                   * be improved in the future by using the read callback.*/","-3.                chunk = find(argv[i]);
-2.                if (chunk >= 0)
-1.                {
                  /* These #if tests have the effect of skipping the arguments
                   * if SAVE support is unavailable - we can't do a useful test
                   * in this case, so we just check the arguments!  This could
                   * be improved in the future by using the read callback.

 /*These #if tests have the effect of skipping the arguments
                   * if SAVE support is unavailable - we can't do a useful test
                   * in this case, so we just check the arguments!  This could
                   * be improved in the future by using the read callback.*/

1.                    */
2. #                 if PNG_LIBPNG_VER >= 10700 &&\
3.                      !defined(PNG_SAVE_UNKNOWN_CHUNKS_SUPPORTED)
4.                      if (option < PNG_HANDLE_CHUNK_IF_SAFE)",Useful
"/*Skip the image data, if IDAT is not being handled then don't do this
    * because it will cause a CRC error.*/","-4.          fprintf(stderr, ""%s(%s): invalid interlace type\n"", d->file, d->test);
-3.          clean_display(d);
-2.          exit(1);
-1.    }
   /* Skip the image data, if IDAT is not being handled then don't do this
    * because it will cause a CRC error.

 /*Skip the image data, if IDAT is not being handled then don't do this
    * because it will cause a CRC error.*/

1.     */",Useful
"/*chunk was processed, it won't have been saved because that is
             * caught below when checking for inconsistent processing.*/","-4.       {
-3.          type = ""KNOWN"";
-2.          if (flag & known)
-1.          {
            /* chunk was processed, it won't have been saved because that is
             * caught below when checking for inconsistent processing.

 /*chunk was processed, it won't have been saved because that is
             * caught below when checking for inconsistent processing.*/

1.              */
2.             if (keep != PNG_HANDLE_CHUNK_AS_DEFAULT)
3.                errorx = ""!DEFAULT: known chunk processed"";
4.          }",Useful
"/*If IDAT is being handled as unknown the image read is skipped and all the
    * IDATs after the first end up in the end info struct, so in this case add
    * IDAT to the list of unknowns.  (Do this after 'check' above sets the
    * chunk_info 'keep' fields.)
    *
    * Note that the flag setting has to be in the 'known' field to avoid
    * triggering the consistency check below and the flag must only be set if
    * there are multiple IDATs, so if the check above did find an unknown IDAT
    * after IDAT.*/","-10. static void
-9. perform_one_test(FILE *fp, int argc, const char **argv,
-8.    png_uint_32 *default_flags, display *d, int set_callback)
-7. {
-6.    int def;
-5.    png_uint_32 flags[2][4];
-4.    rewind(fp);
-3.    clear_keep();
-2.    memcpy(flags[0], default_flags, sizeof flags[0]);
-1.    def = check(fp, argc, argv, flags[1], d, set_callback);
   /* If IDAT is being handled as unknown the image read is skipped and all the
    * IDATs after the first end up in the end info struct, so in this case add
    * IDAT to the list of unknowns.  (Do this after 'check' above sets the
    * chunk_info 'keep' fields.)
    *
    * Note that the flag setting has to be in the 'known' field to avoid
    * triggering the consistency check below and the flag must only be set if
    * there are multiple IDATs, so if the check above did find an unknown IDAT
    * after IDAT.

 /*If IDAT is being handled as unknown the image read is skipped and all the
    * IDATs after the first end up in the end info struct, so in this case add
    * IDAT to the list of unknowns.  (Do this after 'check' above sets the
    * chunk_info 'keep' fields.)
    *
    * Note that the flag setting has to be in the 'known' field to avoid
    * triggering the consistency check below and the flag must only be set if
    * there are multiple IDATs, so if the check above did find an unknown IDAT
    * after IDAT.*/

1.     */",Useful
"/*Chunks should either be known or unknown, never both and this should apply
    * whether the chunk is before or after the IDAT (actually, the app can
    * probably change this by swapping the handling after the image, but this
    * test does not do that.)*/","-2.        (flags[1][3] & PNG_INFO_IDAT) != 0)
-1.       flags[0][2] |= PNG_INFO_IDAT;
   /* Chunks should either be known or unknown, never both and this should apply
    * whether the chunk is before or after the IDAT (actually, the app can
    * probably change this by swapping the handling after the image, but this
    * test does not do that.)

 /*Chunks should either be known or unknown, never both and this should apply
    * whether the chunk is before or after the IDAT (actually, the app can
    * probably change this by swapping the handling after the image, but this
    * test does not do that.)*/

1.     */
2.    check_error(d, (flags[0][0]|flags[0][2]) & (flags[0][1]|flags[0][3]),
3.       ""chunk handled inconsistently in count tests"");
4.    check_error(d, (flags[1][0]|flags[1][2]) & (flags[1][1]|flags[1][3]),
5.       ""chunk handled inconsistently in option tests"");",Useful
"/*Now find out what happened to each chunk before and after the IDAT and
    * determine if the behavior was correct.  First some basic sanity checks,
    * any known chunk should be known in the original count, any unknown chunk
    * should be either known or unknown in the original.*/","-4.    check_error(d, (flags[0][0]|flags[0][2]) & (flags[0][1]|flags[0][3]),
-3.       ""chunk handled inconsistently in count tests"");
-2.    check_error(d, (flags[1][0]|flags[1][2]) & (flags[1][1]|flags[1][3]),
-1.       ""chunk handled inconsistently in option tests"");
   /* Now find out what happened to each chunk before and after the IDAT and
    * determine if the behavior was correct.  First some basic sanity checks,
    * any known chunk should be known in the original count, any unknown chunk
    * should be either known or unknown in the original.

 /*Now find out what happened to each chunk before and after the IDAT and
    * determine if the behavior was correct.  First some basic sanity checks,
    * any known chunk should be known in the original count, any unknown chunk
    * should be either known or unknown in the original.*/

1.     */
2.    {
3.       png_uint_32 test;
4.       test = flags[1][0] & ~flags[0][0];
5.       check_error(d, test, ""new known chunk before IDAT"");
6.       test = flags[1][1] & ~(flags[0][0] | flags[0][1]);
7.       check_error(d, test, ""new unknown chunk before IDAT"");
8.       test = flags[1][2] & ~flags[0][2];
9.       check_error(d, test, ""new known chunk after IDAT"");
10.       test = flags[1][3] & ~(flags[0][2] | flags[0][3]);",Useful
"/*Now each chunk in the original list should have been handled according to
    * the options set for that chunk, regardless of whether libpng knows about
    * it or not.*/","-10.       png_uint_32 test;
-9.       test = flags[1][0] & ~flags[0][0];
-8.       check_error(d, test, ""new known chunk before IDAT"");
-7.       test = flags[1][1] & ~(flags[0][0] | flags[0][1]);
-6.       check_error(d, test, ""new unknown chunk before IDAT"");
-5.       test = flags[1][2] & ~flags[0][2];
-4.       check_error(d, test, ""new known chunk after IDAT"");
-3.       test = flags[1][3] & ~(flags[0][2] | flags[0][3]);
-2.       check_error(d, test, ""new unknown chunk after IDAT"");
-1.    }
   /* Now each chunk in the original list should have been handled according to
    * the options set for that chunk, regardless of whether libpng knows about
    * it or not.

 /*Now each chunk in the original list should have been handled according to
    * the options set for that chunk, regardless of whether libpng knows about
    * it or not.*/

1.     */
2.    check_handling(d, def, flags[0][0] | flags[0][1], flags[1][0], flags[1][1],
3.       ""before IDAT"", set_callback);
4.    check_handling(d, def, flags[0][2] | flags[0][3], flags[1][2], flags[1][3],
5.       ""after IDAT"", set_callback);
6. }
7. static void
8. perform_one_test_safe(FILE *fp, int argc, const char **argv,
9.    png_uint_32 *default_flags, display *d, const char *test)
10. {",Useful
"/*A file name is required, but there should be no other arguments if
    * --default was specified.*/","-10.       else if (strcmp(*argv, ""--touch"") == 0)
-9.       {
-8.          if (argc > 1)
-7.             touch_file = *++argv, --argc;
-6.          else
-5.             usage(d.program, ""--touch: missing file name"");
-4.       }
-3.       else
-2.          break;
-1.    }
   /* A file name is required, but there should be no other arguments if
    * --default was specified.

 /*A file name is required, but there should be no other arguments if
    * --default was specified.*/

1.     */
2.    if (argc <= 0)
3.       usage(d.program, ""missing test file"");",Useful
"/*GCC BUG: if (default_tests && argc != 1) triggers some weird GCC argc
    * optimization which causes warnings with -Wstrict-overflow!*/","-2.    if (argc <= 0)
-1.       usage(d.program, ""missing test file"");
   /* GCC BUG: if (default_tests && argc != 1) triggers some weird GCC argc
    * optimization which causes warnings with -Wstrict-overflow!

 /*GCC BUG: if (default_tests && argc != 1) triggers some weird GCC argc
    * optimization which causes warnings with -Wstrict-overflow!*/

1.     */
2.    else if (default_tests) if (argc != 1)
3.       usage(d.program, ""extra arguments"");",Useful
/*The name of the test file is the last argument; remove it.*/,"-2.    else if (default_tests) if (argc != 1)
-1.       usage(d.program, ""extra arguments"");

 /*The name of the test file is the last argument; remove it.*/

1.    d.file = argv[--argc];
2.    fp = fopen(d.file, ""rb"");
3.    if (fp == NULL)
4.    {
5.       perror(d.file);
6.       exit(99);
7.    }
8.    /* First find all the chunks, known and unknown, in the test file, a failure
9.     * here aborts the whole test.
10.     *",Useful
"/*First find all the chunks, known and unknown, in the test file, a failure
    * here aborts the whole test.
    *
    * If 'save' is supported then the normal saving method should happen,
    * otherwise if 'read' is supported then the read callback will do the
    * same thing.  If both are supported the 'read' callback won't be
    * instantiated by default.  If 'save' is *not* supported then a user
    * callback is required even though we can call png_get_unknown_chunks.*/","-7.    d.file = argv[--argc];
-6.    fp = fopen(d.file, ""rb"");
-5.    if (fp == NULL)
-4.    {
-3.       perror(d.file);
-2.       exit(99);
-1.    }
   /* First find all the chunks, known and unknown, in the test file, a failure
    * here aborts the whole test.
    *
    * If 'save' is supported then the normal saving method should happen,
    * otherwise if 'read' is supported then the read callback will do the
    * same thing.  If both are supported the 'read' callback won't be
    * instantiated by default.  If 'save' is *not* supported then a user
    * callback is required even though we can call png_get_unknown_chunks.

 /*First find all the chunks, known and unknown, in the test file, a failure
    * here aborts the whole test.
    *
    * If 'save' is supported then the normal saving method should happen,
    * otherwise if 'read' is supported then the read callback will do the
    * same thing.  If both are supported the 'read' callback won't be
    * instantiated by default.  If 'save' is *not* supported then a user
    * callback is required even though we can call png_get_unknown_chunks.*/

1.     */
2.    if (check(fp, 1, &count_argv, default_flags, &d,
3. #     ifdef PNG_SAVE_UNKNOWN_CHUNKS_SUPPORTED
4.          0
5. #     else
6.          1
7. #     endif
8.       ) != PNG_HANDLE_CHUNK_ALWAYS)
9.    {
10.       fprintf(stderr, ""%s: %s: internal error\n"", d.program, d.file);",Useful
"/*Set the exit_test pointer here so we can continue after a libpng error.
       * NOTE: this leaks memory because the png_struct data from the failing
       * test is never freed.*/","-10.          perform_one_test(fp, argc, argv, default_flags, &d, 0);
-9. #     endif
-8. #     ifdef PNG_READ_USER_CHUNKS_SUPPORTED
-7.          perform_one_test(fp, argc, argv, default_flags, &d, 1);
-6. #     endif
-5.       d.test = init;
-4.    }
-3.    else
-2.    {
-1.       const char **test = standard_tests;
      /* Set the exit_test pointer here so we can continue after a libpng error.
       * NOTE: this leaks memory because the png_struct data from the failing
       * test is never freed.

 /*Set the exit_test pointer here so we can continue after a libpng error.
       * NOTE: this leaks memory because the png_struct data from the failing
       * test is never freed.*/

1.        */
2.       while (*test)
3.       {
4.          const char *this_test = *test++;
5.          const char **next = test;
6.          int count = display_rc(&d, strict), new_count;
7.          const char *result;
8.          int arg_count = 0;
9.          while (*next) ++next, ++arg_count;
10.          perform_one_test_safe(fp, arg_count, test, default_flags, &d,",Useful
"/*Success, touch the success file if appropriate*/","-10.             result = ""PASS"";
-9.          else
-8.             result = ""FAIL"";
-7.          printf(""%s: %s %s\n"", result, d.program, this_test);
-6.          test = next+1;
-5.       }
-4.    }
-3.    fclose(fp);
-2.    if (display_rc(&d, strict) == 0)
-1.    {

 /*Success, touch the success file if appropriate*/

1.       if (touch_file != NULL)
2.       {
3.          FILE *fsuccess = fopen(touch_file, ""wt"");
4.          if (fsuccess != NULL)
5.          {
6.             int err = 0;
7.             fprintf(fsuccess, ""PNG unknown tests succeeded\n"");
8.             fflush(fsuccess);
9.             err = ferror(fsuccess);
10.             if (fclose(fsuccess) || err)",Useful
"/*Create a PNG structure for reading, and allocate any memory needed.*/","-10.  * and license in png.h
-9.  *
-8.  * This file contains routines that an application calls directly to
-7.  * read a PNG file or stream.
-6.  */
-5. #include ""pngpriv.h""
-4. #if defined(PNG_SIMPLIFIED_READ_SUPPORTED) && defined(PNG_STDIO_SUPPORTED)
-3. #  include <errno.h>
-2. #endif
-1. #ifdef PNG_READ_SUPPORTED

 /*Create a PNG structure for reading, and allocate any memory needed.*/

1. PNG_FUNCTION(png_structp,PNGAPI
2. png_create_read_struct,(png_const_charp user_png_ver, png_voidp error_ptr,
3.     png_error_ptr error_fn, png_error_ptr warn_fn),PNG_ALLOCATED)
4. {
5. #ifndef PNG_USER_MEM_SUPPORTED
6.    png_structp png_ptr = png_create_png_struct(user_png_ver, error_ptr,
7.         error_fn, warn_fn, NULL, NULL, NULL);
8. #else
9.    return png_create_read_struct_2(user_png_ver, error_ptr, error_fn,
10.         warn_fn, NULL, NULL, NULL);",Useful
"/*Alternate create PNG structure for reading, and allocate any memory
 * needed.*/","-10. png_create_read_struct,(png_const_charp user_png_ver, png_voidp error_ptr,
-9.     png_error_ptr error_fn, png_error_ptr warn_fn),PNG_ALLOCATED)
-8. {
-7. #ifndef PNG_USER_MEM_SUPPORTED
-6.    png_structp png_ptr = png_create_png_struct(user_png_ver, error_ptr,
-5.         error_fn, warn_fn, NULL, NULL, NULL);
-4. #else
-3.    return png_create_read_struct_2(user_png_ver, error_ptr, error_fn,
-2.         warn_fn, NULL, NULL, NULL);
-1. }
/* Alternate create PNG structure for reading, and allocate any memory
 * needed.

 /*Alternate create PNG structure for reading, and allocate any memory
 * needed.*/

1.  */
2. PNG_FUNCTION(png_structp,PNGAPI
3. png_create_read_struct_2,(png_const_charp user_png_ver, png_voidp error_ptr,
4.     png_error_ptr error_fn, png_error_ptr warn_fn, png_voidp mem_ptr,
5.     png_malloc_ptr malloc_fn, png_free_ptr free_fn),PNG_ALLOCATED)
6. {
7.    png_structp png_ptr = png_create_png_struct(user_png_ver, error_ptr,
8.        error_fn, warn_fn, mem_ptr, malloc_fn, free_fn);",Useful
"/*Added in libpng-1.6.0; this can be used to detect a read structure if
       * required (it will be zero in a write structure.)*/","-3.    if (png_ptr != NULL)
-2.    {
-1.       png_ptr->mode = PNG_IS_READ_STRUCT;
      /* Added in libpng-1.6.0; this can be used to detect a read structure if
       * required (it will be zero in a write structure.)

 /*Added in libpng-1.6.0; this can be used to detect a read structure if
       * required (it will be zero in a write structure.)*/

1.        */
2. #     ifdef PNG_SEQUENTIAL_READ_SUPPORTED
3.          png_ptr->IDAT_read_size = PNG_IDAT_READ_SIZE;
4. #     endif
5. #     ifdef PNG_BENIGN_READ_ERRORS_SUPPORTED
6.          png_ptr->flags |= PNG_FLAG_BENIGN_ERRORS_WARN;",Useful
"/*In stable builds only warn if an application error can be completely
          * handled.*/","-5. #     ifdef PNG_SEQUENTIAL_READ_SUPPORTED
-4.          png_ptr->IDAT_read_size = PNG_IDAT_READ_SIZE;
-3. #     endif
-2. #     ifdef PNG_BENIGN_READ_ERRORS_SUPPORTED
-1.          png_ptr->flags |= PNG_FLAG_BENIGN_ERRORS_WARN;
         /* In stable builds only warn if an application error can be completely
          * handled.

 /*In stable builds only warn if an application error can be completely
          * handled.*/

1.           */
2. #        if PNG_RELEASE_BUILD
3.             png_ptr->flags |= PNG_FLAG_APP_WARNINGS_WARN;
4. #        endif
5. #     endif",Useful
"/*TODO: delay this, it can be done in png_init_io (if the app doesn't
       * do it itself) avoiding setting the default function if it is not
       * required.*/","-4. #        if PNG_RELEASE_BUILD
-3.             png_ptr->flags |= PNG_FLAG_APP_WARNINGS_WARN;
-2. #        endif
-1. #     endif
      /* TODO: delay this, it can be done in png_init_io (if the app doesn't
       * do it itself) avoiding setting the default function if it is not
       * required.

 /*TODO: delay this, it can be done in png_init_io (if the app doesn't
       * do it itself) avoiding setting the default function if it is not
       * required.*/

1.        */
2.       png_set_read_fn(png_ptr, NULL, NULL);
3.    }
4.    return png_ptr;
5. }
6. #ifdef PNG_SEQUENTIAL_READ_SUPPORTED
7. /* Read the information before the actual image data.  This has been
8.  * changed in v0.90 to allow reading a file that already has the magic
9.  * bytes read from the stream.  You can tell libpng how many bytes have
10.  * been read from the beginning of the stream (up to the maximum of 8)",Useful
"/*Read the information before the actual image data.  This has been
 * changed in v0.90 to allow reading a file that already has the magic
 * bytes read from the stream.  You can tell libpng how many bytes have
 * been read from the beginning of the stream (up to the maximum of 8)
 * via png_set_sig_bytes(), and we will only check the remaining bytes
 * here.  The application can then have access to the signature bytes we
 * read if it is determined that this isn't a valid PNG file.*/","-5.       png_set_read_fn(png_ptr, NULL, NULL);
-4.    }
-3.    return png_ptr;
-2. }
-1. #ifdef PNG_SEQUENTIAL_READ_SUPPORTED
/* Read the information before the actual image data.  This has been
 * changed in v0.90 to allow reading a file that already has the magic
 * bytes read from the stream.  You can tell libpng how many bytes have
 * been read from the beginning of the stream (up to the maximum of 8)
 * via png_set_sig_bytes(), and we will only check the remaining bytes
 * here.  The application can then have access to the signature bytes we
 * read if it is determined that this isn't a valid PNG file.

 /*Read the information before the actual image data.  This has been
 * changed in v0.90 to allow reading a file that already has the magic
 * bytes read from the stream.  You can tell libpng how many bytes have
 * been read from the beginning of the stream (up to the maximum of 8)
 * via png_set_sig_bytes(), and we will only check the remaining bytes
 * here.  The application can then have access to the signature bytes we
 * read if it is determined that this isn't a valid PNG file.*/

1.  */
2. void PNGAPI
3. png_read_info(png_structrp png_ptr, png_inforp info_ptr)
4. {
5. #ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED
6.    int keep;
7. #endif
8.    png_debug(1, ""in png_read_info"");
9.    if (png_ptr == NULL || info_ptr == NULL)
10.       return;",Useful
"/*IDAT logic needs to happen here to simplify getting the two flags
       * right.*/","-5.    png_read_sig(png_ptr, info_ptr);
-4.    for (;;)
-3.    {
-2.       png_uint_32 length = png_read_chunk_header(png_ptr);
-1.       png_uint_32 chunk_name = png_ptr->chunk_name;
      /* IDAT logic needs to happen here to simplify getting the two flags
       * right.

 /*IDAT logic needs to happen here to simplify getting the two flags
       * right.*/

1.        */
2.       if (chunk_name == png_IDAT)
3.       {
4.          if ((png_ptr->mode & PNG_HAVE_IHDR) == 0)
5.             png_chunk_error(png_ptr, ""Missing IHDR before IDAT"");
6.          else if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE &&
7.              (png_ptr->mode & PNG_HAVE_PLTE) == 0)
8.             png_chunk_error(png_ptr, ""Missing PLTE before IDAT"");
9.          else if ((png_ptr->mode & PNG_AFTER_IDAT) != 0)
10.             png_chunk_benign_error(png_ptr, ""Too many IDATs found"");",Useful
"/*This should be a binary subdivision search or a hash for
       * matching the chunk name rather than a linear search.*/","-10.             png_chunk_error(png_ptr, ""Missing PLTE before IDAT"");
-9.          else if ((png_ptr->mode & PNG_AFTER_IDAT) != 0)
-8.             png_chunk_benign_error(png_ptr, ""Too many IDATs found"");
-7.          png_ptr->mode |= PNG_HAVE_IDAT;
-6.       }
-5.       else if ((png_ptr->mode & PNG_HAVE_IDAT) != 0)
-4.       {
-3.          png_ptr->mode |= PNG_HAVE_CHUNK_AFTER_IDAT;
-2.          png_ptr->mode |= PNG_AFTER_IDAT;
-1.       }
      /* This should be a binary subdivision search or a hash for
       * matching the chunk name rather than a linear search.

 /*This should be a binary subdivision search or a hash for
       * matching the chunk name rather than a linear search.*/

1.        */
2.       if (chunk_name == png_IHDR)
3.          png_handle_IHDR(png_ptr, info_ptr, length);
4.       else if (chunk_name == png_IEND)
5.          png_handle_IEND(png_ptr, info_ptr, length);
6. #ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED
7.       else if ((keep = png_chunk_unknown_handling(png_ptr, chunk_name)) != 0)
8.       {
9.          png_handle_unknown(png_ptr, info_ptr, length, keep);
10.          if (chunk_name == png_PLTE)",Useful
/*Optional call to update the users info_ptr structure*/,"-10. #ifdef PNG_READ_iTXt_SUPPORTED
-9.       else if (chunk_name == png_iTXt)
-8.          png_handle_iTXt(png_ptr, info_ptr, length);
-7. #endif
-6.       else
-5.          png_handle_unknown(png_ptr, info_ptr, length,
-4.              PNG_HANDLE_CHUNK_AS_DEFAULT);
-3.    }
-2. }

 /*Optional call to update the users info_ptr structure*/

1. void PNGAPI
2. png_read_update_info(png_structrp png_ptr, png_inforp info_ptr)
3. {
4.    png_debug(1, ""in png_read_update_info"");
5.    if (png_ptr != NULL)
6.    {
7.       if ((png_ptr->flags & PNG_FLAG_ROW_INIT) == 0)
8.       {
9.          png_read_start_row(png_ptr);
10. #        ifdef PNG_READ_TRANSFORMS_SUPPORTED",Useful
/*New in 1.6.0 this avoids the bug of doing the initializations twice*/,"-10.    {
-9.       if ((png_ptr->flags & PNG_FLAG_ROW_INIT) == 0)
-8.       {
-7.          png_read_start_row(png_ptr);
-6. #        ifdef PNG_READ_TRANSFORMS_SUPPORTED
-5.             png_read_transform_info(png_ptr, info_ptr);
-4. #        else
-3.             PNG_UNUSED(info_ptr)
-2. #        endif
-1.       }

 /*New in 1.6.0 this avoids the bug of doing the initializations twice*/

1.       else
2.          png_app_error(png_ptr,
3.              ""png_read_update_info/png_start_read_image: duplicate call"");
4.    }
5. }
6. #ifdef PNG_SEQUENTIAL_READ_SUPPORTED
7. /* Initialize palette, background, etc, after transformations
8.  * are set, but before any reading takes place.  This allows
9.  * the user to obtain a gamma-corrected palette, for example.
10.  * If the user doesn't call this, we will do it ourselves.",Useful
"/*Initialize palette, background, etc, after transformations
 * are set, but before any reading takes place.  This allows
 * the user to obtain a gamma-corrected palette, for example.
 * If the user doesn't call this, we will do it ourselves.*/","-6.       else
-5.          png_app_error(png_ptr,
-4.              ""png_read_update_info/png_start_read_image: duplicate call"");
-3.    }
-2. }
-1. #ifdef PNG_SEQUENTIAL_READ_SUPPORTED
/* Initialize palette, background, etc, after transformations
 * are set, but before any reading takes place.  This allows
 * the user to obtain a gamma-corrected palette, for example.
 * If the user doesn't call this, we will do it ourselves.

 /*Initialize palette, background, etc, after transformations
 * are set, but before any reading takes place.  This allows
 * the user to obtain a gamma-corrected palette, for example.
 * If the user doesn't call this, we will do it ourselves.*/

1.  */
2. void PNGAPI
3. png_start_read_image(png_structrp png_ptr)
4. {
5.    png_debug(1, ""in png_start_read_image"");
6.    if (png_ptr != NULL)
7.    {
8.       if ((png_ptr->flags & PNG_FLAG_ROW_INIT) == 0)
9.          png_read_start_row(png_ptr);",Useful
/*New in 1.6.0 this avoids the bug of doing the initializations twice*/,"-10.    {
-9.       if ((png_ptr->flags & PNG_FLAG_ROW_INIT) == 0)
-8.       {
-7.          png_read_start_row(png_ptr);
-6. #        ifdef PNG_READ_TRANSFORMS_SUPPORTED
-5.             png_read_transform_info(png_ptr, info_ptr);
-4. #        else
-3.             PNG_UNUSED(info_ptr)
-2. #        endif
-1.       }

 /*New in 1.6.0 this avoids the bug of doing the initializations twice*/

1.       else
2.          png_app_error(png_ptr,
3.              ""png_read_update_info/png_start_read_image: duplicate call"");
4.    }
5. }
6. #ifdef PNG_SEQUENTIAL_READ_SUPPORTED
7. /* Initialize palette, background, etc, after transformations
8.  * are set, but before any reading takes place.  This allows
9.  * the user to obtain a gamma-corrected palette, for example.
10.  * If the user doesn't call this, we will do it ourselves.",Useful
"/*Undoes intrapixel differencing,
 * NOTE: this is apparently only supported in the 'sequential' reader.*/","-2. #ifdef PNG_SEQUENTIAL_READ_SUPPORTED
-1. #ifdef PNG_MNG_FEATURES_SUPPORTED
/* Undoes intrapixel differencing,
 * NOTE: this is apparently only supported in the 'sequential' reader.

 /*Undoes intrapixel differencing,
 * NOTE: this is apparently only supported in the 'sequential' reader.*/

1.  */
2. static void
3. png_do_read_intrapixel(png_row_infop row_info, png_bytep row)
4. {
5.    png_debug(1, ""in png_do_read_intrapixel"");
6.    if (
7.        (row_info->color_type & PNG_COLOR_MASK_COLOR) != 0)
8.    {
9.       int bytes_per_pixel;
10.       png_uint_32 row_width = row_info->width;",Useful
/*1.5.6: row_info moved out of png_struct to a local here.*/,"-2.    if ((png_ptr->flags & PNG_FLAG_ROW_INIT) == 0)
-1.       png_read_start_row(png_ptr);

 /*1.5.6: row_info moved out of png_struct to a local here.*/

 ",Useful
/*Check for transforms that have been set but were defined out*/,"-8.    row_info.color_type = png_ptr->color_type;
-7.    row_info.bit_depth = png_ptr->bit_depth;
-6.    row_info.channels = png_ptr->channels;
-5.    row_info.pixel_depth = png_ptr->pixel_depth;
-4.    row_info.rowbytes = PNG_ROWBYTES(row_info.pixel_depth, row_info.width);
-3. #ifdef PNG_WARNINGS_SUPPORTED
-2.    if (png_ptr->row_number == 0 && png_ptr->pass == 0)
-1.    {

 /*Check for transforms that have been set but were defined out*/

1. #if defined(PNG_WRITE_INVERT_SUPPORTED) && !defined(PNG_READ_INVERT_SUPPORTED)
2.    if ((png_ptr->transformations & PNG_INVERT_MONO) != 0)
3.       png_warning(png_ptr, ""PNG_READ_INVERT_SUPPORTED is not defined"");
4. #endif
5. #if defined(PNG_WRITE_FILLER_SUPPORTED) && !defined(PNG_READ_FILLER_SUPPORTED)
6.    if ((png_ptr->transformations & PNG_FILLER) != 0)
7.       png_warning(png_ptr, ""PNG_READ_FILLER_SUPPORTED is not defined"");
8. #endif
9. #if defined(PNG_WRITE_PACKSWAP_SUPPORTED) && \
10.     !defined(PNG_READ_PACKSWAP_SUPPORTED)",Useful
"/*If interlaced and we do not need a new row, combine row and return.
    * Notice that the pixels we have from previous rows have been transformed
    * already; we can only combine like with like (transformed or
    * untransformed) and, because of the libpng API for interlaced images, this
    * means we must transform before de-interlacing.*/","-1. #ifdef PNG_READ_INTERLACING_SUPPORTED
   /* If interlaced and we do not need a new row, combine row and return.
    * Notice that the pixels we have from previous rows have been transformed
    * already; we can only combine like with like (transformed or
    * untransformed) and, because of the libpng API for interlaced images, this
    * means we must transform before de-interlacing.

 /*If interlaced and we do not need a new row, combine row and return.
    * Notice that the pixels we have from previous rows have been transformed
    * already; we can only combine like with like (transformed or
    * untransformed) and, because of the libpng API for interlaced images, this
    * means we must transform before de-interlacing.*/

1.     */
2.    if (png_ptr->interlaced != 0 &&
3.        (png_ptr->transformations & PNG_INTERLACE) != 0)
4.    {
5.       switch (png_ptr->pass)
6.       {
7.          case 0:
8.             if (png_ptr->row_number & 0x07)
9.             {
10.                if (dsp_row != NULL)",Useful
/*to force error if no data was found*/,"-10.                png_read_finish_row(png_ptr);
-9.                return;
-8.             }
-7.             break;
-6.       }
-5.    }
-4. #endif
-3.    if ((png_ptr->mode & PNG_HAVE_IDAT) == 0)
-2.       png_error(png_ptr, ""Invalid attempt to read row data"");

 /*to force error if no data was found*/

1.    png_read_IDAT_data(png_ptr, png_ptr->row_buf, row_info.rowbytes + 1);
2.    if (png_ptr->row_buf[0] > PNG_FILTER_VALUE_NONE)
3.    {
4.       if (png_ptr->row_buf[0] < PNG_FILTER_VALUE_LAST)
5.          png_read_filter_row(png_ptr, &row_info, png_ptr->row_buf + 1,
6.              png_ptr->prev_row + 1, png_ptr->row_buf[0]);
7.       else
8.          png_error(png_ptr, ""bad adaptive filter value"");
9.    }
10.    /* libpng 1.5.6: the following line was copying png_ptr->rowbytes before",Useful
"/*libpng 1.5.6: the following line was copying png_ptr->rowbytes before
    * 1.5.6, while the buffer really is this big in current versions of libpng
    * it may not be in the future, so this was changed just to copy the
    * interlaced count:*/","-9.    png_read_IDAT_data(png_ptr, png_ptr->row_buf, row_info.rowbytes + 1);
-8.    if (png_ptr->row_buf[0] > PNG_FILTER_VALUE_NONE)
-7.    {
-6.       if (png_ptr->row_buf[0] < PNG_FILTER_VALUE_LAST)
-5.          png_read_filter_row(png_ptr, &row_info, png_ptr->row_buf + 1,
-4.              png_ptr->prev_row + 1, png_ptr->row_buf[0]);
-3.       else
-2.          png_error(png_ptr, ""bad adaptive filter value"");
-1.    }
   /* libpng 1.5.6: the following line was copying png_ptr->rowbytes before
    * 1.5.6, while the buffer really is this big in current versions of libpng
    * it may not be in the future, so this was changed just to copy the
    * interlaced count:

 /*libpng 1.5.6: the following line was copying png_ptr->rowbytes before
    * 1.5.6, while the buffer really is this big in current versions of libpng
    * it may not be in the future, so this was changed just to copy the
    * interlaced count:*/

1.     */
2.    memcpy(png_ptr->prev_row, png_ptr->row_buf, row_info.rowbytes + 1);
3. #ifdef PNG_MNG_FEATURES_SUPPORTED
4.    if ((png_ptr->mng_features_permitted & PNG_FLAG_MNG_FILTER_64) != 0 &&
5.        (png_ptr->filter_type == PNG_INTRAPIXEL_DIFFERENCING))
6.    {",Useful
/*Expand interlaced rows to full size*/,"-9.    if (png_ptr->transformed_pixel_depth == 0)
-8.    {
-7.       png_ptr->transformed_pixel_depth = row_info.pixel_depth;
-6.       if (row_info.pixel_depth > png_ptr->maximum_pixel_depth)
-5.          png_error(png_ptr, ""sequential row overflow"");
-4.    }
-3.    else if (png_ptr->transformed_pixel_depth != row_info.pixel_depth)
-2.       png_error(png_ptr, ""internal sequential row size calculation error"");
-1. #ifdef PNG_READ_INTERLACING_SUPPORTED

 /*Expand interlaced rows to full size*/

1.    if (png_ptr->interlaced != 0 &&
2.       (png_ptr->transformations & PNG_INTERLACE) != 0)
3.    {
4.       if (png_ptr->pass < 6)
5.          png_do_read_interlace(&row_info, png_ptr->row_buf + 1, png_ptr->pass,
6.              png_ptr->transformations);
7.       if (dsp_row != NULL)",Useful
"/*Read one or more rows of image data.  If the image is interlaced,
 * and png_set_interlace_handling() has been called, the rows need to
 * contain the contents of the rows from the previous pass.  If the
 * image has alpha or transparency, and png_handle_alpha()[*] has been
 * called, the rows contents must be initialized to the contents of the
 * screen.
 *
 * ""row"" holds the actual image, and pixels are placed in it
 * as they arrive.  If the image is displayed after each pass, it will
 * appear to ""sparkle"" in.  ""display_row"" can be used to display a
 * ""chunky"" progressive image, with finer detail added as it becomes
 * available.  If you do not want this ""chunky"" display, you may pass
 * NULL for display_row.  If you do not want the sparkle display, and
 * you have not called png_handle_alpha(), you may pass NULL for rows.
 * If you have called png_handle_alpha(), and the image has either an
 * alpha channel or a transparency chunk, you must provide a buffer for
 * rows.  In this case, you do not have to provide a display_row buffer
 * also, but you may.  If the image is not interlaced, or if you have
 * not called png_set_interlace_handling(), the display_row buffer will
 * be ignored, so pass NULL to it.
 *
 * [*] png_handle_alpha() does not exist yet, as of this version of libpng*/","-1. #ifdef PNG_SEQUENTIAL_READ_SUPPORTED
/* Read one or more rows of image data.  If the image is interlaced,
 * and png_set_interlace_handling() has been called, the rows need to
 * contain the contents of the rows from the previous pass.  If the
 * image has alpha or transparency, and png_handle_alpha()[*] has been
 * called, the rows contents must be initialized to the contents of the
 * screen.
 *
 * ""row"" holds the actual image, and pixels are placed in it
 * as they arrive.  If the image is displayed after each pass, it will
 * appear to ""sparkle"" in.  ""display_row"" can be used to display a
 * ""chunky"" progressive image, with finer detail added as it becomes
 * available.  If you do not want this ""chunky"" display, you may pass
 * NULL for display_row.  If you do not want the sparkle display, and
 * you have not called png_handle_alpha(), you may pass NULL for rows.
 * If you have called png_handle_alpha(), and the image has either an
 * alpha channel or a transparency chunk, you must provide a buffer for
 * rows.  In this case, you do not have to provide a display_row buffer
 * also, but you may.  If the image is not interlaced, or if you have
 * not called png_set_interlace_handling(), the display_row buffer will
 * be ignored, so pass NULL to it.
 *
 * [*] png_handle_alpha() does not exist yet, as of this version of libpng

 /*Read one or more rows of image data.  If the image is interlaced,
 * and png_set_interlace_handling() has been called, the rows need to
 * contain the contents of the rows from the previous pass.  If the
 * image has alpha or transparency, and png_handle_alpha()[*] has been
 * called, the rows contents must be initialized to the contents of the
 * screen.
 *
 * ""row"" holds the actual image, and pixels are placed in it
 * as they arrive.  If the image is displayed after each pass, it will
 * appear to ""sparkle"" in.  ""display_row"" can be used to display a
 * ""chunky"" progressive image, with finer detail added as it becomes
 * available.  If you do not want this ""chunky"" display, you may pass
 * NULL for display_row.  If you do not want the sparkle display, and
 * you have not called png_handle_alpha(), you may pass NULL for rows.
 * If you have called png_handle_alpha(), and the image has either an
 * alpha channel or a transparency chunk, you must provide a buffer for
 * rows.  In this case, you do not have to provide a display_row buffer
 * also, but you may.  If the image is not interlaced, or if you have
 * not called png_set_interlace_handling(), the display_row buffer will
 * be ignored, so pass NULL to it.
 *
 * [*] png_handle_alpha() does not exist yet, as of this version of libpng*/

1.  */
2. void PNGAPI
3. png_read_rows(png_structrp png_ptr, png_bytepp row,
4.     png_bytepp display_row, png_uint_32 num_rows)
5. {
6.    png_uint_32 i;
7.    png_bytepp rp;
8.    png_bytepp dp;
9.    png_debug(1, ""in png_read_rows"");
10.    if (png_ptr == NULL)",Useful
"/*Read the entire image.  If the image has an alpha channel or a tRNS
 * chunk, and you have called png_handle_alpha()[*], you will need to
 * initialize the image to the current image that PNG will be overlaying.
 * We set the num_rows again here, in case it was incorrectly set in
 * png_read_start_row() by a call to png_read_update_info() or
 * png_start_read_image() if png_set_interlace_handling() wasn't called
 * prior to either of these functions like it should have been.  You can
 * only call this function once.  If you desire to have an image for
 * each pass of a interlaced image, use png_read_rows() instead.
 *
 * [*] png_handle_alpha() does not exist yet, as of this version of libpng*/","-1. #ifdef PNG_SEQUENTIAL_READ_SUPPORTED
/* Read the entire image.  If the image has an alpha channel or a tRNS
 * chunk, and you have called png_handle_alpha()[*], you will need to
 * initialize the image to the current image that PNG will be overlaying.
 * We set the num_rows again here, in case it was incorrectly set in
 * png_read_start_row() by a call to png_read_update_info() or
 * png_start_read_image() if png_set_interlace_handling() wasn't called
 * prior to either of these functions like it should have been.  You can
 * only call this function once.  If you desire to have an image for
 * each pass of a interlaced image, use png_read_rows() instead.
 *
 * [*] png_handle_alpha() does not exist yet, as of this version of libpng

 /*Read the entire image.  If the image has an alpha channel or a tRNS
 * chunk, and you have called png_handle_alpha()[*], you will need to
 * initialize the image to the current image that PNG will be overlaying.
 * We set the num_rows again here, in case it was incorrectly set in
 * png_read_start_row() by a call to png_read_update_info() or
 * png_start_read_image() if png_set_interlace_handling() wasn't called
 * prior to either of these functions like it should have been.  You can
 * only call this function once.  If you desire to have an image for
 * each pass of a interlaced image, use png_read_rows() instead.
 *
 * [*] png_handle_alpha() does not exist yet, as of this version of libpng*/

1.  */
2. void PNGAPI
3. png_read_image(png_structrp png_ptr, png_bytepp image)
4. {
5.    png_uint_32 i, image_height;
6.    int pass, j;
7.    png_bytepp rp;
8.    png_debug(1, ""in png_read_image"");
9.    if (png_ptr == NULL)
10.       return;",Useful
/*And make sure transforms are initialized.*/,"-10.    png_uint_32 i, image_height;
-9.    int pass, j;
-8.    png_bytepp rp;
-7.    png_debug(1, ""in png_read_image"");
-6.    if (png_ptr == NULL)
-5.       return;
-4. #ifdef PNG_READ_INTERLACING_SUPPORTED
-3.    if ((png_ptr->flags & PNG_FLAG_ROW_INIT) == 0)
-2.    {
-1.       pass = png_set_interlace_handling(png_ptr);

 /*And make sure transforms are initialized.*/

1.       png_start_read_image(png_ptr);
2.    }
3.    else
4.    {
5.       if (png_ptr->interlaced != 0 &&
6.           (png_ptr->transformations & PNG_INTERLACE) == 0)
7.       {
8.          /* Caller called png_start_read_image or png_read_update_info without
9.           * first turning on the PNG_INTERLACE transform.  We can fix this here,
10.           * but the caller should do it!",Useful
"/*Caller called png_start_read_image or png_read_update_info without
          * first turning on the PNG_INTERLACE transform.  We can fix this here,
          * but the caller should do it!*/","-7.       png_start_read_image(png_ptr);
-6.    }
-5.    else
-4.    {
-3.       if (png_ptr->interlaced != 0 &&
-2.           (png_ptr->transformations & PNG_INTERLACE) == 0)
-1.       {
         /* Caller called png_start_read_image or png_read_update_info without
          * first turning on the PNG_INTERLACE transform.  We can fix this here,
          * but the caller should do it!

 /*Caller called png_start_read_image or png_read_update_info without
          * first turning on the PNG_INTERLACE transform.  We can fix this here,
          * but the caller should do it!*/

1.           */
2.          png_warning(png_ptr, ""Interlace handling should be turned on when ""
3.              ""using png_read_image"");",Useful
"/*Obtain the pass number, which also turns on the PNG_INTERLACE flag in
       * the above error case.*/","-2.          png_ptr->num_rows = png_ptr->height;
-1.       }
      /* Obtain the pass number, which also turns on the PNG_INTERLACE flag in
       * the above error case.

 /*Obtain the pass number, which also turns on the PNG_INTERLACE flag in
       * the above error case.*/

1.        */
2.       pass = png_set_interlace_handling(png_ptr);
3.    }
4. #else
5.    if (png_ptr->interlaced)
6.       png_error(png_ptr,
7.           ""Cannot read interlaced image -- interlace handler disabled"");
8.    pass = 1;
9. #endif
10.    image_height=png_ptr->height;",Useful
"/*Read the end of the PNG file.  Will not read past the end of the
 * file, will verify the end is accurate, and will read any comments
 * or time information at the end of the file, if info is not NULL.*/","-1. #ifdef PNG_SEQUENTIAL_READ_SUPPORTED
/* Read the end of the PNG file.  Will not read past the end of the
 * file, will verify the end is accurate, and will read any comments
 * or time information at the end of the file, if info is not NULL.

 /*Read the end of the PNG file.  Will not read past the end of the
 * file, will verify the end is accurate, and will read any comments
 * or time information at the end of the file, if info is not NULL.*/

1.  */
2. void PNGAPI
3. png_read_end(png_structrp png_ptr, png_inforp info_ptr)
4. {
5. #ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED
6.    int keep;
7. #endif
8.    png_debug(1, ""in png_read_end"");
9.    if (png_ptr == NULL)
10.       return;",Useful
"/*If png_read_end is called in the middle of reading the rows there may
    * still be pending IDAT data and an owned zstream.  Deal with this here.*/","-10.  */
-9. void PNGAPI
-8. png_read_end(png_structrp png_ptr, png_inforp info_ptr)
-7. {
-6. #ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED
-5.    int keep;
-4. #endif
-3.    png_debug(1, ""in png_read_end"");
-2.    if (png_ptr == NULL)
-1.       return;
   /* If png_read_end is called in the middle of reading the rows there may
    * still be pending IDAT data and an owned zstream.  Deal with this here.

 /*If png_read_end is called in the middle of reading the rows there may
    * still be pending IDAT data and an owned zstream.  Deal with this here.*/

1.     */
2. #ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED
3.    if (png_chunk_unknown_handling(png_ptr, png_IDAT) == 0)
4. #endif
5.       png_read_finish_IDAT(png_ptr);
6. #ifdef PNG_READ_CHECK_FOR_INVALID_INDEX_SUPPORTED",Useful
/*Report invalid palette index; added at libng-1.5.10*/,"-5. #ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED
-4.    if (png_chunk_unknown_handling(png_ptr, png_IDAT) == 0)
-3. #endif
-2.       png_read_finish_IDAT(png_ptr);
-1. #ifdef PNG_READ_CHECK_FOR_INVALID_INDEX_SUPPORTED

 /*Report invalid palette index; added at libng-1.5.10*/

1.    if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE &&
2.        png_ptr->num_palette_max > png_ptr->num_palette)
3.       png_benign_error(png_ptr, ""Read palette index exceeding num_palette"");
4. #endif
5.    do
6.    {
7.       png_uint_32 length = png_read_chunk_header(png_ptr);
8.       png_uint_32 chunk_name = png_ptr->chunk_name;
9.       if (chunk_name != png_IDAT)
10.          png_ptr->mode |= PNG_HAVE_CHUNK_AFTER_IDAT;",Useful
"/*Zero length IDATs are legal after the last IDAT has been
          * read, but not after other chunks have been read.  1.6 does not
          * always read all the deflate data; specifically it cannot be relied
          * upon to read the Adler32 at the end.  If it doesn't ignore IDAT
          * chunks which are longer than zero as well:*/","-10.                 || (png_ptr->mode & PNG_HAVE_CHUNK_AFTER_IDAT) != 0)
-9.                png_benign_error(png_ptr, "".Too many IDATs found"");
-8.          }
-7.          png_handle_unknown(png_ptr, info_ptr, length, keep);
-6.          if (chunk_name == png_PLTE)
-5.             png_ptr->mode |= PNG_HAVE_PLTE;
-4.       }
-3. #endif
-2.       else if (chunk_name == png_IDAT)
-1.       {
         /* Zero length IDATs are legal after the last IDAT has been
          * read, but not after other chunks have been read.  1.6 does not
          * always read all the deflate data; specifically it cannot be relied
          * upon to read the Adler32 at the end.  If it doesn't ignore IDAT
          * chunks which are longer than zero as well:

 /*Zero length IDATs are legal after the last IDAT has been
          * read, but not after other chunks have been read.  1.6 does not
          * always read all the deflate data; specifically it cannot be relied
          * upon to read the Adler32 at the end.  If it doesn't ignore IDAT
          * chunks which are longer than zero as well:*/

1.           */
2.          if ((length > 0 && !(png_ptr->flags & PNG_FLAG_ZSTREAM_ENDED))
3.              || (png_ptr->mode & PNG_HAVE_CHUNK_AFTER_IDAT) != 0)
4.             png_benign_error(png_ptr, ""..Too many IDATs found"");
5.          png_crc_finish(png_ptr, length);
6.       }
7.       else if (chunk_name == png_PLTE)
8.          png_handle_PLTE(png_ptr, info_ptr, length);
9. #ifdef PNG_READ_bKGD_SUPPORTED
10.       else if (chunk_name == png_bKGD)",Useful
/*Free all memory used in the read struct*/,"-10. #ifdef PNG_READ_iTXt_SUPPORTED
-9.       else if (chunk_name == png_iTXt)
-8.          png_handle_iTXt(png_ptr, info_ptr, length);
-7. #endif
-6.       else
-5.          png_handle_unknown(png_ptr, info_ptr, length,
-4.              PNG_HANDLE_CHUNK_AS_DEFAULT);
-3.    } while ((png_ptr->mode & PNG_HAVE_IEND) == 0);
-2. }

 /*Free all memory used in the read struct*/

1. static void
2. png_read_destroy(png_structrp png_ptr)
3. {
4.    png_debug(1, ""in png_read_destroy"");
5. #ifdef PNG_READ_GAMMA_SUPPORTED
6.    png_destroy_gamma_table(png_ptr);
7. #endif
8.    png_free(png_ptr, png_ptr->big_row_buf);
9.    png_ptr->big_row_buf = NULL;
10.    png_free(png_ptr, png_ptr->big_prev_row);",Useful
"/*NOTE: the 'setjmp' buffer may still be allocated and the memory and error
    * callbacks are still set at this point.  They are required to complete the
    * destruction of the png_struct itself.*/","-10. #endif
-9. #if defined(PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED) && \
-8.    defined(PNG_READ_UNKNOWN_CHUNKS_SUPPORTED)
-7.    png_free(png_ptr, png_ptr->unknown_chunk.data);
-6.    png_ptr->unknown_chunk.data = NULL;
-5. #endif
-4. #ifdef PNG_SET_UNKNOWN_CHUNKS_SUPPORTED
-3.    png_free(png_ptr, png_ptr->chunk_list);
-2.    png_ptr->chunk_list = NULL;
-1. #endif
   /* NOTE: the 'setjmp' buffer may still be allocated and the memory and error
    * callbacks are still set at this point.  They are required to complete the
    * destruction of the png_struct itself.

 /*NOTE: the 'setjmp' buffer may still be allocated and the memory and error
    * callbacks are still set at this point.  They are required to complete the
    * destruction of the png_struct itself.*/

1.     */
2. }",Useful
/*Free all memory used by the read*/,"-1. }

 /*Free all memory used by the read*/

1. void PNGAPI
2. png_destroy_read_struct(png_structpp png_ptr_ptr, png_infopp info_ptr_ptr,
3.     png_infopp end_info_ptr_ptr)
4. {
5.    png_structrp png_ptr = NULL;
6.    png_debug(1, ""in png_destroy_read_struct"");
7.    if (png_ptr_ptr != NULL)
8.       png_ptr = *png_ptr_ptr;
9.    if (png_ptr == NULL)
10.       return;",Useful
"/*libpng 1.6.0: use the API to destroy info structs to ensure consistent
    * behavior.  Prior to 1.6.0 libpng did extra 'info' destruction in this API.
    * The extra was, apparently, unnecessary yet this hides memory leak bugs.*/","-10. void PNGAPI
-9. png_destroy_read_struct(png_structpp png_ptr_ptr, png_infopp info_ptr_ptr,
-8.     png_infopp end_info_ptr_ptr)
-7. {
-6.    png_structrp png_ptr = NULL;
-5.    png_debug(1, ""in png_destroy_read_struct"");
-4.    if (png_ptr_ptr != NULL)
-3.       png_ptr = *png_ptr_ptr;
-2.    if (png_ptr == NULL)
-1.       return;
   /* libpng 1.6.0: use the API to destroy info structs to ensure consistent
    * behavior.  Prior to 1.6.0 libpng did extra 'info' destruction in this API.
    * The extra was, apparently, unnecessary yet this hides memory leak bugs.

 /*libpng 1.6.0: use the API to destroy info structs to ensure consistent
    * behavior.  Prior to 1.6.0 libpng did extra 'info' destruction in this API.
    * The extra was, apparently, unnecessary yet this hides memory leak bugs.*/

1.     */
2.    png_destroy_info_struct(png_ptr, end_info_ptr_ptr);
3.    png_destroy_info_struct(png_ptr, info_ptr_ptr);
4.    *png_ptr_ptr = NULL;
5.    png_read_destroy(png_ptr);
6.    png_destroy_png_struct(png_ptr);
7. }
8. void PNGAPI
9. png_set_read_status_fn(png_structrp png_ptr, png_read_status_ptr read_row_fn)
10. {",Useful
"/*png_read_info() gives us all of the information from the
    * PNG file before the first IDAT (image data chunk).*/","-10.    png_ptr->read_row_fn = read_row_fn;
-9. }
-8. #ifdef PNG_SEQUENTIAL_READ_SUPPORTED
-7. #ifdef PNG_INFO_IMAGE_SUPPORTED
-6. void PNGAPI
-5. png_read_png(png_structrp png_ptr, png_inforp info_ptr,
-4.     int transforms, voidp params)
-3. {
-2.    if (png_ptr == NULL || info_ptr == NULL)
-1.       return;
   /* png_read_info() gives us all of the information from the
    * PNG file before the first IDAT (image data chunk).

 /*png_read_info() gives us all of the information from the
    * PNG file before the first IDAT (image data chunk).*/

1.     */
2.    png_read_info(png_ptr, info_ptr);
3.    if (info_ptr->height > PNG_UINT_32_MAX/(sizeof (png_bytep)))
4.       png_error(png_ptr, ""Image is too high to process with png_read_png()"");",Useful
/*-------------- image transformations start here -------------------*/,"-3.    png_read_info(png_ptr, info_ptr);
-2.    if (info_ptr->height > PNG_UINT_32_MAX/(sizeof (png_bytep)))
-1.       png_error(png_ptr, ""Image is too high to process with png_read_png()"");

 /*-------------- image transformations start here -------------------*/

 ",Useful
"/*libpng 1.6.10: add code to cause a png_app_error if a selected TRANSFORM
    * is not implemented.  This will only happen in de-configured (non-default)
    * libpng builds.  The results can be unexpected - png_read_png may return
    * short or mal-formed rows because the transform is skipped.*/","/* libpng 1.6.10: add code to cause a png_app_error if a selected TRANSFORM
    * is not implemented.  This will only happen in de-configured (non-default)
    * libpng builds.  The results can be unexpected - png_read_png may return
    * short or mal-formed rows because the transform is skipped.

 /*libpng 1.6.10: add code to cause a png_app_error if a selected TRANSFORM
    * is not implemented.  This will only happen in de-configured (non-default)
    * libpng builds.  The results can be unexpected - png_read_png may return
    * short or mal-formed rows because the transform is skipped.*/

1.     */",Useful
/*Tell libpng to strip 16-bit/color files down to 8 bits per color.*/,"/* Tell libpng to strip 16-bit/color files down to 8 bits per color.

 /*Tell libpng to strip 16-bit/color files down to 8 bits per color.*/

1.     */
2.    if ((transforms & PNG_TRANSFORM_SCALE_16) != 0)",Useful
"/*Added at libpng-1.5.4. ""strip_16"" produces the same result that it
       * did in earlier versions, while ""scale_16"" is now more accurate.*/","-1.    if ((transforms & PNG_TRANSFORM_SCALE_16) != 0)
      /* Added at libpng-1.5.4. ""strip_16"" produces the same result that it
       * did in earlier versions, while ""scale_16"" is now more accurate.

 /*Added at libpng-1.5.4. ""strip_16"" produces the same result that it
       * did in earlier versions, while ""scale_16"" is now more accurate.*/

1.        */
2. #ifdef PNG_READ_SCALE_16_TO_8_SUPPORTED
3.       png_set_scale_16(png_ptr);
4. #else
5.       png_app_error(png_ptr, ""PNG_TRANSFORM_SCALE_16 not supported"");
6. #endif",Useful
"/*If both SCALE and STRIP are required pngrtran will effectively cancel the
    * latter by doing SCALE first.  This is ok and allows apps not to check for
    * which is supported to get the right answer.*/","-5. #ifdef PNG_READ_SCALE_16_TO_8_SUPPORTED
-4.       png_set_scale_16(png_ptr);
-3. #else
-2.       png_app_error(png_ptr, ""PNG_TRANSFORM_SCALE_16 not supported"");
-1. #endif
   /* If both SCALE and STRIP are required pngrtran will effectively cancel the
    * latter by doing SCALE first.  This is ok and allows apps not to check for
    * which is supported to get the right answer.

 /*If both SCALE and STRIP are required pngrtran will effectively cancel the
    * latter by doing SCALE first.  This is ok and allows apps not to check for
    * which is supported to get the right answer.*/

1.     */
2.    if ((transforms & PNG_TRANSFORM_STRIP_16) != 0)
3. #ifdef PNG_READ_STRIP_16_TO_8_SUPPORTED
4.       png_set_strip_16(png_ptr);
5. #else
6.       png_app_error(png_ptr, ""PNG_TRANSFORM_STRIP_16 not supported"");
7. #endif",Useful
"/*Strip alpha bytes from the input data without combining with
    * the background (not recommended).*/","-6.    if ((transforms & PNG_TRANSFORM_STRIP_16) != 0)
-5. #ifdef PNG_READ_STRIP_16_TO_8_SUPPORTED
-4.       png_set_strip_16(png_ptr);
-3. #else
-2.       png_app_error(png_ptr, ""PNG_TRANSFORM_STRIP_16 not supported"");
-1. #endif
   /* Strip alpha bytes from the input data without combining with
    * the background (not recommended).

 /*Strip alpha bytes from the input data without combining with
    * the background (not recommended).*/

1.     */
2.    if ((transforms & PNG_TRANSFORM_STRIP_ALPHA) != 0)
3. #ifdef PNG_READ_STRIP_ALPHA_SUPPORTED
4.       png_set_strip_alpha(png_ptr);
5. #else
6.       png_app_error(png_ptr, ""PNG_TRANSFORM_STRIP_ALPHA not supported"");
7. #endif",Useful
"/*Extract multiple pixels with bit depths of 1, 2, or 4 from a single
    * byte into separate bytes (useful for paletted and grayscale images).*/","-6.    if ((transforms & PNG_TRANSFORM_STRIP_ALPHA) != 0)
-5. #ifdef PNG_READ_STRIP_ALPHA_SUPPORTED
-4.       png_set_strip_alpha(png_ptr);
-3. #else
-2.       png_app_error(png_ptr, ""PNG_TRANSFORM_STRIP_ALPHA not supported"");
-1. #endif
   /* Extract multiple pixels with bit depths of 1, 2, or 4 from a single
    * byte into separate bytes (useful for paletted and grayscale images).

 /*Extract multiple pixels with bit depths of 1, 2, or 4 from a single
    * byte into separate bytes (useful for paletted and grayscale images).*/

1.     */
2.    if ((transforms & PNG_TRANSFORM_PACKING) != 0)
3. #ifdef PNG_READ_PACK_SUPPORTED
4.       png_set_packing(png_ptr);
5. #else
6.       png_app_error(png_ptr, ""PNG_TRANSFORM_PACKING not supported"");
7. #endif",Useful
"/*Change the order of packed pixels to least significant bit first
    * (not useful if you are using png_set_packing).*/","-6.    if ((transforms & PNG_TRANSFORM_PACKING) != 0)
-5. #ifdef PNG_READ_PACK_SUPPORTED
-4.       png_set_packing(png_ptr);
-3. #else
-2.       png_app_error(png_ptr, ""PNG_TRANSFORM_PACKING not supported"");
-1. #endif
   /* Change the order of packed pixels to least significant bit first
    * (not useful if you are using png_set_packing).

 /*Change the order of packed pixels to least significant bit first
    * (not useful if you are using png_set_packing).*/

1.     */
2.    if ((transforms & PNG_TRANSFORM_PACKSWAP) != 0)
3. #ifdef PNG_READ_PACKSWAP_SUPPORTED
4.       png_set_packswap(png_ptr);
5. #else
6.       png_app_error(png_ptr, ""PNG_TRANSFORM_PACKSWAP not supported"");
7. #endif
8.    /* Expand paletted colors into true RGB triplets
9.     * Expand grayscale images to full 8 bits from 1, 2, or 4 bits/pixel
10.     * Expand paletted or RGB images with transparency to full alpha",Useful
"/*Expand paletted colors into true RGB triplets
    * Expand grayscale images to full 8 bits from 1, 2, or 4 bits/pixel
    * Expand paletted or RGB images with transparency to full alpha
    * channels so the data will be available as RGBA quartets.*/","-6.    if ((transforms & PNG_TRANSFORM_PACKSWAP) != 0)
-5. #ifdef PNG_READ_PACKSWAP_SUPPORTED
-4.       png_set_packswap(png_ptr);
-3. #else
-2.       png_app_error(png_ptr, ""PNG_TRANSFORM_PACKSWAP not supported"");
-1. #endif
   /* Expand paletted colors into true RGB triplets
    * Expand grayscale images to full 8 bits from 1, 2, or 4 bits/pixel
    * Expand paletted or RGB images with transparency to full alpha
    * channels so the data will be available as RGBA quartets.

 /*Expand paletted colors into true RGB triplets
    * Expand grayscale images to full 8 bits from 1, 2, or 4 bits/pixel
    * Expand paletted or RGB images with transparency to full alpha
    * channels so the data will be available as RGBA quartets.*/

1.     */
2.    if ((transforms & PNG_TRANSFORM_EXPAND) != 0)
3. #ifdef PNG_READ_EXPAND_SUPPORTED
4.       png_set_expand(png_ptr);
5. #else
6.       png_app_error(png_ptr, ""PNG_TRANSFORM_EXPAND not supported"");
7. #endif",Useful
/*We don't handle background color or gamma transformation or quantizing.*/,"-10.     * Expand grayscale images to full 8 bits from 1, 2, or 4 bits/pixel
-9.     * Expand paletted or RGB images with transparency to full alpha
-8.     * channels so the data will be available as RGBA quartets.
-7.     */
-6.    if ((transforms & PNG_TRANSFORM_EXPAND) != 0)
-5. #ifdef PNG_READ_EXPAND_SUPPORTED
-4.       png_set_expand(png_ptr);
-3. #else
-2.       png_app_error(png_ptr, ""PNG_TRANSFORM_EXPAND not supported"");
-1. #endif
   /* We don't handle background color or gamma transformation or quantizing.

 /*We don't handle background color or gamma transformation or quantizing.*/

1.     */",Useful
"/*If you want to shift the pixel values from the range [0,255] or
    * [0,65535] to the original [0,7] or [0,31], or whatever range the
    * colors were originally in:*/","-6.    if ((transforms & PNG_TRANSFORM_INVERT_MONO) != 0)
-5. #ifdef PNG_READ_INVERT_SUPPORTED
-4.       png_set_invert_mono(png_ptr);
-3. #else
-2.       png_app_error(png_ptr, ""PNG_TRANSFORM_INVERT_MONO not supported"");
-1. #endif
   /* If you want to shift the pixel values from the range [0,255] or
    * [0,65535] to the original [0,7] or [0,31], or whatever range the
    * colors were originally in:

 /*If you want to shift the pixel values from the range [0,255] or
    * [0,65535] to the original [0,7] or [0,31], or whatever range the
    * colors were originally in:*/

1.     */
2.    if ((transforms & PNG_TRANSFORM_SHIFT) != 0)
3. #ifdef PNG_READ_SHIFT_SUPPORTED
4.       if ((info_ptr->valid & PNG_INFO_sBIT) != 0)
5.          png_set_shift(png_ptr, &info_ptr->sig_bit);
6. #else
7.       png_app_error(png_ptr, ""PNG_TRANSFORM_SHIFT not supported"");
8. #endif",Useful
/*Flip the RGB pixels to BGR (or RGBA to BGRA)*/,"-10.     * [0,65535] to the original [0,7] or [0,31], or whatever range the
-9.     * colors were originally in:
-8.     */
-7.    if ((transforms & PNG_TRANSFORM_SHIFT) != 0)
-6. #ifdef PNG_READ_SHIFT_SUPPORTED
-5.       if ((info_ptr->valid & PNG_INFO_sBIT) != 0)
-4.          png_set_shift(png_ptr, &info_ptr->sig_bit);
-3. #else
-2.       png_app_error(png_ptr, ""PNG_TRANSFORM_SHIFT not supported"");
-1. #endif

 /*Flip the RGB pixels to BGR (or RGBA to BGRA)*/

1.    if ((transforms & PNG_TRANSFORM_BGR) != 0)
2. #ifdef PNG_READ_BGR_SUPPORTED
3.       png_set_bgr(png_ptr);
4. #else
5.       png_app_error(png_ptr, ""PNG_TRANSFORM_BGR not supported"");
6. #endif",Useful
/*Swap bytes of 16-bit files to least significant byte first*/,"-6.    if ((transforms & PNG_TRANSFORM_SWAP_ALPHA) != 0)
-5. #ifdef PNG_READ_SWAP_ALPHA_SUPPORTED
-4.       png_set_swap_alpha(png_ptr);
-3. #else
-2.       png_app_error(png_ptr, ""PNG_TRANSFORM_SWAP_ALPHA not supported"");
-1. #endif

 /*Swap bytes of 16-bit files to least significant byte first*/

1.    if ((transforms & PNG_TRANSFORM_SWAP_ENDIAN) != 0)
2. #ifdef PNG_READ_SWAP_SUPPORTED
3.       png_set_swap(png_ptr);
4. #else
5.       png_app_error(png_ptr, ""PNG_TRANSFORM_SWAP_ENDIAN not supported"");
6. #endif",Useful
/*Invert the alpha channel from opacity to transparency*/,"-7.    if ((transforms & PNG_TRANSFORM_SWAP_ENDIAN) != 0)
-6. #ifdef PNG_READ_SWAP_SUPPORTED
-5.       png_set_swap(png_ptr);
-4. #else
-3.       png_app_error(png_ptr, ""PNG_TRANSFORM_SWAP_ENDIAN not supported"");
-2. #endif

 /*Invert the alpha channel from opacity to transparency*/

1.    if ((transforms & PNG_TRANSFORM_INVERT_ALPHA) != 0)
2. #ifdef PNG_READ_INVERT_ALPHA_SUPPORTED
3.       png_set_invert_alpha(png_ptr);
4. #else
5.       png_app_error(png_ptr, ""PNG_TRANSFORM_INVERT_ALPHA not supported"");
6. #endif",Useful
/*Expand grayscale image to RGB*/,"-7.    if ((transforms & PNG_TRANSFORM_INVERT_ALPHA) != 0)
-6. #ifdef PNG_READ_INVERT_ALPHA_SUPPORTED
-5.       png_set_invert_alpha(png_ptr);
-4. #else
-3.       png_app_error(png_ptr, ""PNG_TRANSFORM_INVERT_ALPHA not supported"");
-2. #endif

 /*Expand grayscale image to RGB*/

1.    if ((transforms & PNG_TRANSFORM_GRAY_TO_RGB) != 0)
2. #ifdef PNG_READ_GRAY_TO_RGB_SUPPORTED
3.       png_set_gray_to_rgb(png_ptr);
4. #else
5.       png_app_error(png_ptr, ""PNG_TRANSFORM_GRAY_TO_RGB not supported"");
6. #endif",Useful
/*We don't handle adding filler bytes*/,"-6.    if ((transforms & PNG_TRANSFORM_EXPAND_16) != 0)
-5. #ifdef PNG_READ_EXPAND_16_SUPPORTED
-4.       png_set_expand_16(png_ptr);
-3. #else
-2.       png_app_error(png_ptr, ""PNG_TRANSFORM_EXPAND_16 not supported"");
-1. #endif

 /*We don't handle adding filler bytes*/

 ",Useful
"/*Optional call to gamma correct and add the background to the palette
    * and update info structure.  REQUIRED if you are expecting libpng to
    * update the palette for you (i.e., you selected such a transform above).*/","-1.    (void)png_set_interlace_handling(png_ptr);
   /* Optional call to gamma correct and add the background to the palette
    * and update info structure.  REQUIRED if you are expecting libpng to
    * update the palette for you (i.e., you selected such a transform above).

 /*Optional call to gamma correct and add the background to the palette
    * and update info structure.  REQUIRED if you are expecting libpng to
    * update the palette for you (i.e., you selected such a transform above).*/

1.     */
2.    png_read_update_info(png_ptr, info_ptr);",Useful
/*-------------- image transformations end here -------------------*/,"-1.    png_read_update_info(png_ptr, info_ptr);

 /*-------------- image transformations end here -------------------*/

1.    png_free_data(png_ptr, info_ptr, PNG_FREE_ROWS, 0);
2.    if (info_ptr->row_pointers == NULL)
3.    {
4.       png_uint_32 iptr;
5.       info_ptr->row_pointers = png_voidcast(png_bytepp, png_malloc(png_ptr,
6.           info_ptr->height * (sizeof (png_bytep))));
7.       for (iptr=0; iptr<info_ptr->height; iptr++)
8.          info_ptr->row_pointers[iptr] = NULL;
9.       info_ptr->free_me |= PNG_FREE_ROWS;
10.       for (iptr = 0; iptr < info_ptr->height; iptr++)",Useful
"/*Read rest of file, and get additional chunks in info_ptr - REQUIRED*/","-10.           info_ptr->height * (sizeof (png_bytep))));
-9.       for (iptr=0; iptr<info_ptr->height; iptr++)
-8.          info_ptr->row_pointers[iptr] = NULL;
-7.       info_ptr->free_me |= PNG_FREE_ROWS;
-6.       for (iptr = 0; iptr < info_ptr->height; iptr++)
-5.          info_ptr->row_pointers[iptr] = png_voidcast(png_bytep,
-4.              png_malloc(png_ptr, info_ptr->rowbytes));
-3.    }
-2.    png_read_image(png_ptr, info_ptr->row_pointers);
-1.    info_ptr->valid |= PNG_INFO_IDAT;

 /*Read rest of file, and get additional chunks in info_ptr - REQUIRED*/

1.    png_read_end(png_ptr, info_ptr);
2.    PNG_UNUSED(params)
3. }",Useful
"/*SIMPLIFIED READ
 *
 * This code currently relies on the sequential reader, though it could easily
 * be made to work with the progressive one.*/","-1. #ifdef PNG_SIMPLIFIED_READ_SUPPORTED
/* SIMPLIFIED READ
 *
 * This code currently relies on the sequential reader, though it could easily
 * be made to work with the progressive one.

 /*SIMPLIFIED READ
 *
 * This code currently relies on the sequential reader, though it could easily
 * be made to work with the progressive one.*/

1.  */",Useful
/*Encoding of PNG data (used by the color-map code)*/,"-7. #ifdef PNG_SIMPLIFIED_READ_SUPPORTED

 /*Encoding of PNG data (used by the color-map code)*/

 ",Useful
/*8-bit encoded to sRGB gamma*/,"-9. #ifdef PNG_SIMPLIFIED_READ_SUPPORTED

 /*8-bit encoded to sRGB gamma*/

 ",Useful
"/*8-bit encoded to file gamma, not sRGB or linear*/","-10. /* SIMPLIFIED READ
-9.  *
-8.  * This code currently relies on the sequential reader, though it could easily
-7.  * be made to work with the progressive one.
-6.  */
-5. /* Arguments to png_image_finish_read: */
-4. /* Encoding of PNG data (used by the color-map code) */
-3. #  define P_NOTSET  0 /* File encoding not yet known */
-2. #  define P_sRGB    1 /* 8-bit encoded to sRGB gamma */
-1. #  define P_LINEAR  2 /* 16-bit linear: not encoded, NOT pre-multiplied! */
#  define P_FILE    3 /* 8-bit encoded to file gamma, not sRGB or linear */

 /*8-bit encoded to file gamma, not sRGB or linear*/

 ",Useful
/*8-bit linear: only from a file value*/,"-10.  *
-9.  * This code currently relies on the sequential reader, though it could easily
-8.  * be made to work with the progressive one.
-7.  */

 /*8-bit linear: only from a file value*/

 ",Useful
"/*Color-map processing: after libpng has run on the PNG image further
 * processing may be needed to convert the data to color-map indices.*/","-10.  * This code currently relies on the sequential reader, though it could easily
-9.  * be made to work with the progressive one.
-8.  */

 /*Color-map processing: after libpng has run on the PNG image further
 * processing may be needed to convert the data to color-map indices.*/

1.  */
2. #define PNG_CMAP_NONE      0",Useful
/*Process GA data to a color-map with alpha*/,"-10. /* Encoding of PNG data (used by the color-map code) */
-9. #  define P_NOTSET  0 /* File encoding not yet known */
-8. #  define P_sRGB    1 /* 8-bit encoded to sRGB gamma */
-7. #  define P_LINEAR  2 /* 16-bit linear: not encoded, NOT pre-multiplied! */
-6. #  define P_FILE    3 /* 8-bit encoded to file gamma, not sRGB or linear */
-5. #  define P_LINEAR8 4 /* 8-bit linear: only from a file value */
-4. /* Color-map processing: after libpng has run on the PNG image further
-3.  * processing may be needed to convert the data to color-map indices.
-2.  */
-1. #define PNG_CMAP_NONE      0
#define PNG_CMAP_GA        1 /* Process GA data to a color-map with alpha */

 /*Process GA data to a color-map with alpha*/

 ",Useful
/*Process GA data to a background index*/,"-2. #define PNG_CMAP_NONE      0

 /*Process GA data to a background index*/

 ",Useful
/*The following document where the background is for each processing case.*/,"-5. #define PNG_CMAP_NONE      0

 /*The following document where the background is for each processing case.*/

1. #define PNG_CMAP_NONE_BACKGROUND      256
2. #define PNG_CMAP_GA_BACKGROUND        231
3. #define PNG_CMAP_TRANS_BACKGROUND     254
4. #define PNG_CMAP_RGB_BACKGROUND       256
5. #define PNG_CMAP_RGB_ALPHA_BACKGROUND 216
6. typedef struct
7. {",Useful
"/*Do all the *safe* initialization - 'safe' means that png_error won't be
 * called, so setting up the jmp_buf is not required.  This means that anything
 * called from here must *not* call png_malloc - it has to call png_malloc_warn
 * instead so that control is returned safely back to this routine.*/","-1. } png_image_read_control;
/* Do all the *safe* initialization - 'safe' means that png_error won't be
 * called, so setting up the jmp_buf is not required.  This means that anything
 * called from here must *not* call png_malloc - it has to call png_malloc_warn
 * instead so that control is returned safely back to this routine.

 /*Do all the *safe* initialization - 'safe' means that png_error won't be
 * called, so setting up the jmp_buf is not required.  This means that anything
 * called from here must *not* call png_malloc - it has to call png_malloc_warn
 * instead so that control is returned safely back to this routine.*/

1.  */
2. static int
3. png_image_read_init(png_imagep image)
4. {
5.    if (image->opaque == NULL)
6.    {
7.       png_structp png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING, image,
8.           png_safe_error, png_safe_warning);
9.       /* And set the rest of the structure to NULL to ensure that the various
10.        * fields are consistent.",Useful
"/*And set the rest of the structure to NULL to ensure that the various
       * fields are consistent.*/","-10.  * called from here must *not* call png_malloc - it has to call png_malloc_warn
-9.  * instead so that control is returned safely back to this routine.
-8.  */
-7. static int
-6. png_image_read_init(png_imagep image)
-5. {
-4.    if (image->opaque == NULL)
-3.    {
-2.       png_structp png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING, image,
-1.           png_safe_error, png_safe_warning);
      /* And set the rest of the structure to NULL to ensure that the various
       * fields are consistent.

 /*And set the rest of the structure to NULL to ensure that the various
       * fields are consistent.*/

1.        */
2.       memset(image, 0, (sizeof *image));
3.       image->version = PNG_IMAGE_VERSION;
4.       if (png_ptr != NULL)
5.       {
6.          png_infop info_ptr = png_create_info_struct(png_ptr);
7.          if (info_ptr != NULL)
8.          {
9.             png_controlp control = png_voidcast(png_controlp,
10.                 png_malloc_warn(png_ptr, (sizeof *control)));",Useful
"/*Use png_ptr here, not info_ptr, because by examination png_handle_tRNS
    * sets the png_struct fields; that's all we are interested in here.  The
    * precise interaction with an app call to png_set_tRNS and PNG file reading
    * is unclear.*/","-8. static png_uint_32
-7. png_image_format(png_structrp png_ptr)
-6. {
-5.    png_uint_32 format = 0;
-4.    if ((png_ptr->color_type & PNG_COLOR_MASK_COLOR) != 0)
-3.       format |= PNG_FORMAT_FLAG_COLOR;
-2.    if ((png_ptr->color_type & PNG_COLOR_MASK_ALPHA) != 0)
-1.       format |= PNG_FORMAT_FLAG_ALPHA;
   /* Use png_ptr here, not info_ptr, because by examination png_handle_tRNS
    * sets the png_struct fields; that's all we are interested in here.  The
    * precise interaction with an app call to png_set_tRNS and PNG file reading
    * is unclear.

 /*Use png_ptr here, not info_ptr, because by examination png_handle_tRNS
    * sets the png_struct fields; that's all we are interested in here.  The
    * precise interaction with an app call to png_set_tRNS and PNG file reading
    * is unclear.*/

1.     */
2.    else if (png_ptr->num_trans > 0)
3.       format |= PNG_FORMAT_FLAG_ALPHA;
4.    if (png_ptr->bit_depth == 16)
5.       format |= PNG_FORMAT_FLAG_LINEAR;
6.    if ((png_ptr->color_type & PNG_COLOR_MASK_PALETTE) != 0)
7.       format |= PNG_FORMAT_FLAG_COLORMAP;
8.    return format;
9. }
10. /* Is the given gamma significantly different from sRGB?  The test is the same",Useful
"/*Is the given gamma significantly different from sRGB?  The test is the same
 * one used in pngrtran.c when deciding whether to do gamma correction.  The
 * arithmetic optimizes the division by using the fact that the inverse of the
 * file sRGB gamma is 2.2*/","-10.     * is unclear.
-9.     */
-8.    else if (png_ptr->num_trans > 0)
-7.       format |= PNG_FORMAT_FLAG_ALPHA;
-6.    if (png_ptr->bit_depth == 16)
-5.       format |= PNG_FORMAT_FLAG_LINEAR;
-4.    if ((png_ptr->color_type & PNG_COLOR_MASK_PALETTE) != 0)
-3.       format |= PNG_FORMAT_FLAG_COLORMAP;
-2.    return format;
-1. }
/* Is the given gamma significantly different from sRGB?  The test is the same
 * one used in pngrtran.c when deciding whether to do gamma correction.  The
 * arithmetic optimizes the division by using the fact that the inverse of the
 * file sRGB gamma is 2.2

 /*Is the given gamma significantly different from sRGB?  The test is the same
 * one used in pngrtran.c when deciding whether to do gamma correction.  The
 * arithmetic optimizes the division by using the fact that the inverse of the
 * file sRGB gamma is 2.2*/

1.  */
2. static int
3. png_gamma_not_sRGB(png_fixed_point g)
4. {
5.    if (g < PNG_FP_1)
6.    {",Useful
